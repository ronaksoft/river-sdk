// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: updates.proto

package msg

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// RedirectTarget
type RedirectTarget int32

const (
	RedirectTargetRpc       RedirectTarget = 0
	RedirectTargetFile      RedirectTarget = 1
	RedirectTargetProxy     RedirectTarget = 2
	RedirectTargetReserved1 RedirectTarget = 3
	RedirectTargetReserved2 RedirectTarget = 4
	RedirectTargetReserved3 RedirectTarget = 5
	RedirectTargetReserved4 RedirectTarget = 6
)

var RedirectTarget_name = map[int32]string{
	0: "RedirectTargetRpc",
	1: "RedirectTargetFile",
	2: "RedirectTargetProxy",
	3: "RedirectTargetReserved1",
	4: "RedirectTargetReserved2",
	5: "RedirectTargetReserved3",
	6: "RedirectTargetReserved4",
}

var RedirectTarget_value = map[string]int32{
	"RedirectTargetRpc":       0,
	"RedirectTargetFile":      1,
	"RedirectTargetProxy":     2,
	"RedirectTargetReserved1": 3,
	"RedirectTargetReserved2": 4,
	"RedirectTargetReserved3": 5,
	"RedirectTargetReserved4": 6,
}

func (x RedirectTarget) String() string {
	return proto.EnumName(RedirectTarget_name, int32(x))
}

func (RedirectTarget) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{0}
}

// UpdateGetState
// @Function
// @Return: UpdateState
type UpdateGetState struct {
}

func (m *UpdateGetState) Reset()         { *m = UpdateGetState{} }
func (m *UpdateGetState) String() string { return proto.CompactTextString(m) }
func (*UpdateGetState) ProtoMessage()    {}
func (*UpdateGetState) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{0}
}
func (m *UpdateGetState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGetState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGetState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGetState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGetState.Merge(m, src)
}
func (m *UpdateGetState) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGetState) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGetState.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGetState proto.InternalMessageInfo

// UpdateGetDifference
// @Function
// @Return: UpdateDifference
type UpdateGetDifference struct {
	From  int64 `protobuf:"varint,1,opt,name=From,proto3" json:"From,omitempty"`
	Limit int32 `protobuf:"varint,2,opt,name=Limit,proto3" json:"Limit,omitempty"`
}

func (m *UpdateGetDifference) Reset()         { *m = UpdateGetDifference{} }
func (m *UpdateGetDifference) String() string { return proto.CompactTextString(m) }
func (*UpdateGetDifference) ProtoMessage()    {}
func (*UpdateGetDifference) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{1}
}
func (m *UpdateGetDifference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGetDifference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGetDifference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGetDifference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGetDifference.Merge(m, src)
}
func (m *UpdateGetDifference) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGetDifference) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGetDifference.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGetDifference proto.InternalMessageInfo

func (m *UpdateGetDifference) GetFrom() int64 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *UpdateGetDifference) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

// UpdateDifference
type UpdateDifference struct {
	More            bool              `protobuf:"varint,1,opt,name=More,proto3" json:"More,omitempty"`
	MaxUpdateID     int64             `protobuf:"varint,2,opt,name=MaxUpdateID,proto3" json:"MaxUpdateID,omitempty"`
	MinUpdateID     int64             `protobuf:"varint,3,opt,name=MinUpdateID,proto3" json:"MinUpdateID,omitempty"`
	Updates         []*UpdateEnvelope `protobuf:"bytes,4,rep,name=Updates,proto3" json:"Updates,omitempty"`
	Users           []*User           `protobuf:"bytes,5,rep,name=Users,proto3" json:"Users,omitempty"`
	Groups          []*Group          `protobuf:"bytes,6,rep,name=Groups,proto3" json:"Groups,omitempty"`
	CurrentUpdateID int64             `protobuf:"varint,7,opt,name=CurrentUpdateID,proto3" json:"CurrentUpdateID,omitempty"`
}

func (m *UpdateDifference) Reset()         { *m = UpdateDifference{} }
func (m *UpdateDifference) String() string { return proto.CompactTextString(m) }
func (*UpdateDifference) ProtoMessage()    {}
func (*UpdateDifference) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{2}
}
func (m *UpdateDifference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateDifference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateDifference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateDifference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateDifference.Merge(m, src)
}
func (m *UpdateDifference) XXX_Size() int {
	return m.Size()
}
func (m *UpdateDifference) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateDifference.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateDifference proto.InternalMessageInfo

func (m *UpdateDifference) GetMore() bool {
	if m != nil {
		return m.More
	}
	return false
}

func (m *UpdateDifference) GetMaxUpdateID() int64 {
	if m != nil {
		return m.MaxUpdateID
	}
	return 0
}

func (m *UpdateDifference) GetMinUpdateID() int64 {
	if m != nil {
		return m.MinUpdateID
	}
	return 0
}

func (m *UpdateDifference) GetUpdates() []*UpdateEnvelope {
	if m != nil {
		return m.Updates
	}
	return nil
}

func (m *UpdateDifference) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *UpdateDifference) GetGroups() []*Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *UpdateDifference) GetCurrentUpdateID() int64 {
	if m != nil {
		return m.CurrentUpdateID
	}
	return 0
}

// UpdateTooLong
type UpdateTooLong struct {
}

func (m *UpdateTooLong) Reset()         { *m = UpdateTooLong{} }
func (m *UpdateTooLong) String() string { return proto.CompactTextString(m) }
func (*UpdateTooLong) ProtoMessage()    {}
func (*UpdateTooLong) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{3}
}
func (m *UpdateTooLong) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTooLong) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTooLong.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateTooLong) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTooLong.Merge(m, src)
}
func (m *UpdateTooLong) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTooLong) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTooLong.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTooLong proto.InternalMessageInfo

// UpdateState
type UpdateState struct {
	UpdateID int64 `protobuf:"varint,1,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
}

func (m *UpdateState) Reset()         { *m = UpdateState{} }
func (m *UpdateState) String() string { return proto.CompactTextString(m) }
func (*UpdateState) ProtoMessage()    {}
func (*UpdateState) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{4}
}
func (m *UpdateState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateState.Merge(m, src)
}
func (m *UpdateState) XXX_Size() int {
	return m.Size()
}
func (m *UpdateState) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateState.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateState proto.InternalMessageInfo

func (m *UpdateState) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

// UpdateMessageID
type UpdateMessageID struct {
	UCount    int32 `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	MessageID int64 `protobuf:"varint,1,opt,name=MessageID,proto3" json:"MessageID,omitempty"`
	RandomID  int64 `protobuf:"varint,2,opt,name=RandomID,proto3" json:"RandomID,omitempty"`
}

func (m *UpdateMessageID) Reset()         { *m = UpdateMessageID{} }
func (m *UpdateMessageID) String() string { return proto.CompactTextString(m) }
func (*UpdateMessageID) ProtoMessage()    {}
func (*UpdateMessageID) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{5}
}
func (m *UpdateMessageID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateMessageID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateMessageID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateMessageID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateMessageID.Merge(m, src)
}
func (m *UpdateMessageID) XXX_Size() int {
	return m.Size()
}
func (m *UpdateMessageID) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateMessageID.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateMessageID proto.InternalMessageInfo

func (m *UpdateMessageID) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateMessageID) GetMessageID() int64 {
	if m != nil {
		return m.MessageID
	}
	return 0
}

func (m *UpdateMessageID) GetRandomID() int64 {
	if m != nil {
		return m.RandomID
	}
	return 0
}

// UpdateNewMessage
type UpdateNewMessage struct {
	UCount      int32        `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID    int64        `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	Message     *UserMessage `protobuf:"bytes,1,opt,name=Message,proto3" json:"Message,omitempty"`
	Sender      *User        `protobuf:"bytes,2,opt,name=Sender,proto3" json:"Sender,omitempty"`
	AccessHash  uint64       `protobuf:"fixed64,3,opt,name=AccessHash,proto3" json:"AccessHash,omitempty"`
	SenderRefID int64        `protobuf:"varint,4,opt,name=SenderRefID,proto3" json:"SenderRefID,omitempty"`
}

func (m *UpdateNewMessage) Reset()         { *m = UpdateNewMessage{} }
func (m *UpdateNewMessage) String() string { return proto.CompactTextString(m) }
func (*UpdateNewMessage) ProtoMessage()    {}
func (*UpdateNewMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{6}
}
func (m *UpdateNewMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateNewMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateNewMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateNewMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateNewMessage.Merge(m, src)
}
func (m *UpdateNewMessage) XXX_Size() int {
	return m.Size()
}
func (m *UpdateNewMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateNewMessage.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateNewMessage proto.InternalMessageInfo

func (m *UpdateNewMessage) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateNewMessage) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateNewMessage) GetMessage() *UserMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *UpdateNewMessage) GetSender() *User {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *UpdateNewMessage) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *UpdateNewMessage) GetSenderRefID() int64 {
	if m != nil {
		return m.SenderRefID
	}
	return 0
}

// UpdateMessageEdited
type UpdateMessageEdited struct {
	UCount   int32        `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID int64        `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	Message  *UserMessage `protobuf:"bytes,1,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *UpdateMessageEdited) Reset()         { *m = UpdateMessageEdited{} }
func (m *UpdateMessageEdited) String() string { return proto.CompactTextString(m) }
func (*UpdateMessageEdited) ProtoMessage()    {}
func (*UpdateMessageEdited) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{7}
}
func (m *UpdateMessageEdited) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateMessageEdited) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateMessageEdited.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateMessageEdited) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateMessageEdited.Merge(m, src)
}
func (m *UpdateMessageEdited) XXX_Size() int {
	return m.Size()
}
func (m *UpdateMessageEdited) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateMessageEdited.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateMessageEdited proto.InternalMessageInfo

func (m *UpdateMessageEdited) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateMessageEdited) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateMessageEdited) GetMessage() *UserMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

// UpdateMessageDeleted
type UpdateMessagesDeleted struct {
	UCount     int32   `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID   int64   `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	TeamID     int64   `protobuf:"varint,102,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	MessageIDs []int64 `protobuf:"varint,1,rep,packed,name=MessageIDs,proto3" json:"MessageIDs,omitempty"`
	Peer       *Peer   `protobuf:"bytes,2,opt,name=Peer,proto3" json:"Peer,omitempty"`
}

func (m *UpdateMessagesDeleted) Reset()         { *m = UpdateMessagesDeleted{} }
func (m *UpdateMessagesDeleted) String() string { return proto.CompactTextString(m) }
func (*UpdateMessagesDeleted) ProtoMessage()    {}
func (*UpdateMessagesDeleted) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{8}
}
func (m *UpdateMessagesDeleted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateMessagesDeleted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateMessagesDeleted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateMessagesDeleted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateMessagesDeleted.Merge(m, src)
}
func (m *UpdateMessagesDeleted) XXX_Size() int {
	return m.Size()
}
func (m *UpdateMessagesDeleted) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateMessagesDeleted.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateMessagesDeleted proto.InternalMessageInfo

func (m *UpdateMessagesDeleted) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateMessagesDeleted) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateMessagesDeleted) GetTeamID() int64 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *UpdateMessagesDeleted) GetMessageIDs() []int64 {
	if m != nil {
		return m.MessageIDs
	}
	return nil
}

func (m *UpdateMessagesDeleted) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

// UpdateReadHistoryInbox
type UpdateReadHistoryInbox struct {
	UCount   int32 `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID int64 `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	TeamID   int64 `protobuf:"varint,102,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	Peer     *Peer `protobuf:"bytes,1,opt,name=Peer,proto3" json:"Peer,omitempty"`
	MaxID    int64 `protobuf:"varint,2,opt,name=MaxID,proto3" json:"MaxID,omitempty"`
}

func (m *UpdateReadHistoryInbox) Reset()         { *m = UpdateReadHistoryInbox{} }
func (m *UpdateReadHistoryInbox) String() string { return proto.CompactTextString(m) }
func (*UpdateReadHistoryInbox) ProtoMessage()    {}
func (*UpdateReadHistoryInbox) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{9}
}
func (m *UpdateReadHistoryInbox) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateReadHistoryInbox) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateReadHistoryInbox.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateReadHistoryInbox) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateReadHistoryInbox.Merge(m, src)
}
func (m *UpdateReadHistoryInbox) XXX_Size() int {
	return m.Size()
}
func (m *UpdateReadHistoryInbox) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateReadHistoryInbox.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateReadHistoryInbox proto.InternalMessageInfo

func (m *UpdateReadHistoryInbox) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateReadHistoryInbox) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateReadHistoryInbox) GetTeamID() int64 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *UpdateReadHistoryInbox) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *UpdateReadHistoryInbox) GetMaxID() int64 {
	if m != nil {
		return m.MaxID
	}
	return 0
}

// UpdateReadHistoryOutbox
type UpdateReadHistoryOutbox struct {
	UCount   int32 `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID int64 `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	TeamID   int64 `protobuf:"varint,102,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	Peer     *Peer `protobuf:"bytes,1,opt,name=Peer,proto3" json:"Peer,omitempty"`
	MaxID    int64 `protobuf:"varint,2,opt,name=MaxID,proto3" json:"MaxID,omitempty"`
	UserID   int64 `protobuf:"varint,3,opt,name=UserID,proto3" json:"UserID,omitempty"`
}

func (m *UpdateReadHistoryOutbox) Reset()         { *m = UpdateReadHistoryOutbox{} }
func (m *UpdateReadHistoryOutbox) String() string { return proto.CompactTextString(m) }
func (*UpdateReadHistoryOutbox) ProtoMessage()    {}
func (*UpdateReadHistoryOutbox) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{10}
}
func (m *UpdateReadHistoryOutbox) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateReadHistoryOutbox) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateReadHistoryOutbox.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateReadHistoryOutbox) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateReadHistoryOutbox.Merge(m, src)
}
func (m *UpdateReadHistoryOutbox) XXX_Size() int {
	return m.Size()
}
func (m *UpdateReadHistoryOutbox) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateReadHistoryOutbox.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateReadHistoryOutbox proto.InternalMessageInfo

func (m *UpdateReadHistoryOutbox) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateReadHistoryOutbox) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateReadHistoryOutbox) GetTeamID() int64 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *UpdateReadHistoryOutbox) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *UpdateReadHistoryOutbox) GetMaxID() int64 {
	if m != nil {
		return m.MaxID
	}
	return 0
}

func (m *UpdateReadHistoryOutbox) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

// UpdateMessagePinned
type UpdateMessagePinned struct {
	UCount   int32 `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID int64 `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	TeamID   int64 `protobuf:"varint,102,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	Peer     *Peer `protobuf:"bytes,1,opt,name=Peer,proto3" json:"Peer,omitempty"`
	UserID   int64 `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID,omitempty"`
	MsgID    int64 `protobuf:"varint,3,opt,name=MsgID,proto3" json:"MsgID,omitempty"`
	Version  int64 `protobuf:"varint,5,opt,name=Version,proto3" json:"Version,omitempty"`
}

func (m *UpdateMessagePinned) Reset()         { *m = UpdateMessagePinned{} }
func (m *UpdateMessagePinned) String() string { return proto.CompactTextString(m) }
func (*UpdateMessagePinned) ProtoMessage()    {}
func (*UpdateMessagePinned) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{11}
}
func (m *UpdateMessagePinned) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateMessagePinned) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateMessagePinned.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateMessagePinned) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateMessagePinned.Merge(m, src)
}
func (m *UpdateMessagePinned) XXX_Size() int {
	return m.Size()
}
func (m *UpdateMessagePinned) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateMessagePinned.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateMessagePinned proto.InternalMessageInfo

func (m *UpdateMessagePinned) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateMessagePinned) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateMessagePinned) GetTeamID() int64 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *UpdateMessagePinned) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *UpdateMessagePinned) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UpdateMessagePinned) GetMsgID() int64 {
	if m != nil {
		return m.MsgID
	}
	return 0
}

func (m *UpdateMessagePinned) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

// UpdateUserTyping
type UpdateUserTyping struct {
	UCount   int32        `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	TeamID   int64        `protobuf:"varint,102,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	UserID   int64        `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	Action   TypingAction `protobuf:"varint,2,opt,name=Action,proto3,enum=msg.TypingAction" json:"Action,omitempty"`
	PeerID   int64        `protobuf:"varint,3,opt,name=PeerID,proto3" json:"PeerID,omitempty"`
	PeerType int32        `protobuf:"varint,4,opt,name=PeerType,proto3" json:"PeerType,omitempty"`
}

func (m *UpdateUserTyping) Reset()         { *m = UpdateUserTyping{} }
func (m *UpdateUserTyping) String() string { return proto.CompactTextString(m) }
func (*UpdateUserTyping) ProtoMessage()    {}
func (*UpdateUserTyping) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{12}
}
func (m *UpdateUserTyping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateUserTyping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateUserTyping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateUserTyping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateUserTyping.Merge(m, src)
}
func (m *UpdateUserTyping) XXX_Size() int {
	return m.Size()
}
func (m *UpdateUserTyping) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateUserTyping.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateUserTyping proto.InternalMessageInfo

func (m *UpdateUserTyping) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateUserTyping) GetTeamID() int64 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *UpdateUserTyping) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UpdateUserTyping) GetAction() TypingAction {
	if m != nil {
		return m.Action
	}
	return TypingActionTyping
}

func (m *UpdateUserTyping) GetPeerID() int64 {
	if m != nil {
		return m.PeerID
	}
	return 0
}

func (m *UpdateUserTyping) GetPeerType() int32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

// UpdateUserStatus
type UpdateUserStatus struct {
	UCount int32 `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UserID int64 `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	Status int32 `protobuf:"varint,2,opt,name=Status,proto3" json:"Status,omitempty"`
}

func (m *UpdateUserStatus) Reset()         { *m = UpdateUserStatus{} }
func (m *UpdateUserStatus) String() string { return proto.CompactTextString(m) }
func (*UpdateUserStatus) ProtoMessage()    {}
func (*UpdateUserStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{13}
}
func (m *UpdateUserStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateUserStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateUserStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateUserStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateUserStatus.Merge(m, src)
}
func (m *UpdateUserStatus) XXX_Size() int {
	return m.Size()
}
func (m *UpdateUserStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateUserStatus.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateUserStatus proto.InternalMessageInfo

func (m *UpdateUserStatus) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateUserStatus) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UpdateUserStatus) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

// UpdateUsername
type UpdateUsername struct {
	UCount    int32  `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID  int64  `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	UserID    int64  `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	Username  string `protobuf:"bytes,2,opt,name=Username,proto3" json:"Username,omitempty"`
	FirstName string `protobuf:"bytes,3,opt,name=FirstName,proto3" json:"FirstName,omitempty"`
	LastName  string `protobuf:"bytes,4,opt,name=LastName,proto3" json:"LastName,omitempty"`
	Bio       string `protobuf:"bytes,5,opt,name=Bio,proto3" json:"Bio,omitempty"`
	Phone     string `protobuf:"bytes,6,opt,name=Phone,proto3" json:"Phone,omitempty"`
}

func (m *UpdateUsername) Reset()         { *m = UpdateUsername{} }
func (m *UpdateUsername) String() string { return proto.CompactTextString(m) }
func (*UpdateUsername) ProtoMessage()    {}
func (*UpdateUsername) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{14}
}
func (m *UpdateUsername) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateUsername) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateUsername.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateUsername) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateUsername.Merge(m, src)
}
func (m *UpdateUsername) XXX_Size() int {
	return m.Size()
}
func (m *UpdateUsername) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateUsername.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateUsername proto.InternalMessageInfo

func (m *UpdateUsername) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateUsername) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateUsername) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UpdateUsername) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *UpdateUsername) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *UpdateUsername) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *UpdateUsername) GetBio() string {
	if m != nil {
		return m.Bio
	}
	return ""
}

func (m *UpdateUsername) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

// UpdateUserPhoto
type UpdateUserPhoto struct {
	UCount          int32      `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID        int64      `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	UserID          int64      `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	Photo           *UserPhoto `protobuf:"bytes,2,opt,name=Photo,proto3" json:"Photo,omitempty"`
	PhotoID         int64      `protobuf:"varint,3,opt,name=PhotoID,proto3" json:"PhotoID,omitempty"`
	DeletedPhotoIDs []int64    `protobuf:"varint,4,rep,packed,name=DeletedPhotoIDs,proto3" json:"DeletedPhotoIDs,omitempty"`
}

func (m *UpdateUserPhoto) Reset()         { *m = UpdateUserPhoto{} }
func (m *UpdateUserPhoto) String() string { return proto.CompactTextString(m) }
func (*UpdateUserPhoto) ProtoMessage()    {}
func (*UpdateUserPhoto) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{15}
}
func (m *UpdateUserPhoto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateUserPhoto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateUserPhoto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateUserPhoto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateUserPhoto.Merge(m, src)
}
func (m *UpdateUserPhoto) XXX_Size() int {
	return m.Size()
}
func (m *UpdateUserPhoto) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateUserPhoto.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateUserPhoto proto.InternalMessageInfo

func (m *UpdateUserPhoto) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateUserPhoto) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateUserPhoto) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UpdateUserPhoto) GetPhoto() *UserPhoto {
	if m != nil {
		return m.Photo
	}
	return nil
}

func (m *UpdateUserPhoto) GetPhotoID() int64 {
	if m != nil {
		return m.PhotoID
	}
	return 0
}

func (m *UpdateUserPhoto) GetDeletedPhotoIDs() []int64 {
	if m != nil {
		return m.DeletedPhotoIDs
	}
	return nil
}

// UpdateNotifySettings
type UpdateNotifySettings struct {
	UCount     int32               `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID   int64               `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	TeamID     int64               `protobuf:"varint,102,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	UserID     int64               `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	NotifyPeer *Peer               `protobuf:"bytes,2,opt,name=NotifyPeer,proto3" json:"NotifyPeer,omitempty"`
	Settings   *PeerNotifySettings `protobuf:"bytes,3,opt,name=Settings,proto3" json:"Settings,omitempty"`
}

func (m *UpdateNotifySettings) Reset()         { *m = UpdateNotifySettings{} }
func (m *UpdateNotifySettings) String() string { return proto.CompactTextString(m) }
func (*UpdateNotifySettings) ProtoMessage()    {}
func (*UpdateNotifySettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{16}
}
func (m *UpdateNotifySettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateNotifySettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateNotifySettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateNotifySettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateNotifySettings.Merge(m, src)
}
func (m *UpdateNotifySettings) XXX_Size() int {
	return m.Size()
}
func (m *UpdateNotifySettings) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateNotifySettings.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateNotifySettings proto.InternalMessageInfo

func (m *UpdateNotifySettings) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateNotifySettings) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateNotifySettings) GetTeamID() int64 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *UpdateNotifySettings) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UpdateNotifySettings) GetNotifyPeer() *Peer {
	if m != nil {
		return m.NotifyPeer
	}
	return nil
}

func (m *UpdateNotifySettings) GetSettings() *PeerNotifySettings {
	if m != nil {
		return m.Settings
	}
	return nil
}

// UpdateGroupParticipantAdd
type UpdateGroupParticipantAdd struct {
	UCount    int32 `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID  int64 `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	GroupID   int64 `protobuf:"varint,1,opt,name=GroupID,proto3" json:"GroupID,omitempty"`
	UserID    int64 `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID,omitempty"`
	InviterID int64 `protobuf:"varint,3,opt,name=InviterID,proto3" json:"InviterID,omitempty"`
	Date      int64 `protobuf:"varint,4,opt,name=Date,proto3" json:"Date,omitempty"`
}

func (m *UpdateGroupParticipantAdd) Reset()         { *m = UpdateGroupParticipantAdd{} }
func (m *UpdateGroupParticipantAdd) String() string { return proto.CompactTextString(m) }
func (*UpdateGroupParticipantAdd) ProtoMessage()    {}
func (*UpdateGroupParticipantAdd) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{17}
}
func (m *UpdateGroupParticipantAdd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGroupParticipantAdd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGroupParticipantAdd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGroupParticipantAdd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGroupParticipantAdd.Merge(m, src)
}
func (m *UpdateGroupParticipantAdd) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGroupParticipantAdd) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGroupParticipantAdd.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGroupParticipantAdd proto.InternalMessageInfo

func (m *UpdateGroupParticipantAdd) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateGroupParticipantAdd) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateGroupParticipantAdd) GetGroupID() int64 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *UpdateGroupParticipantAdd) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UpdateGroupParticipantAdd) GetInviterID() int64 {
	if m != nil {
		return m.InviterID
	}
	return 0
}

func (m *UpdateGroupParticipantAdd) GetDate() int64 {
	if m != nil {
		return m.Date
	}
	return 0
}

// UpdateGroupParticipantDeleted
type UpdateGroupParticipantDeleted struct {
	UCount   int32 `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID int64 `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	GroupID  int64 `protobuf:"varint,1,opt,name=GroupID,proto3" json:"GroupID,omitempty"`
	UserID   int64 `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID,omitempty"`
}

func (m *UpdateGroupParticipantDeleted) Reset()         { *m = UpdateGroupParticipantDeleted{} }
func (m *UpdateGroupParticipantDeleted) String() string { return proto.CompactTextString(m) }
func (*UpdateGroupParticipantDeleted) ProtoMessage()    {}
func (*UpdateGroupParticipantDeleted) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{18}
}
func (m *UpdateGroupParticipantDeleted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGroupParticipantDeleted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGroupParticipantDeleted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGroupParticipantDeleted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGroupParticipantDeleted.Merge(m, src)
}
func (m *UpdateGroupParticipantDeleted) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGroupParticipantDeleted) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGroupParticipantDeleted.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGroupParticipantDeleted proto.InternalMessageInfo

func (m *UpdateGroupParticipantDeleted) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateGroupParticipantDeleted) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateGroupParticipantDeleted) GetGroupID() int64 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *UpdateGroupParticipantDeleted) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

// UpdateGroupParticipantAdmin
type UpdateGroupParticipantAdmin struct {
	UCount   int32 `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID int64 `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	GroupID  int64 `protobuf:"varint,1,opt,name=GroupID,proto3" json:"GroupID,omitempty"`
	UserID   int64 `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID,omitempty"`
	IsAdmin  bool  `protobuf:"varint,3,opt,name=IsAdmin,proto3" json:"IsAdmin,omitempty"`
}

func (m *UpdateGroupParticipantAdmin) Reset()         { *m = UpdateGroupParticipantAdmin{} }
func (m *UpdateGroupParticipantAdmin) String() string { return proto.CompactTextString(m) }
func (*UpdateGroupParticipantAdmin) ProtoMessage()    {}
func (*UpdateGroupParticipantAdmin) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{19}
}
func (m *UpdateGroupParticipantAdmin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGroupParticipantAdmin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGroupParticipantAdmin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGroupParticipantAdmin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGroupParticipantAdmin.Merge(m, src)
}
func (m *UpdateGroupParticipantAdmin) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGroupParticipantAdmin) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGroupParticipantAdmin.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGroupParticipantAdmin proto.InternalMessageInfo

func (m *UpdateGroupParticipantAdmin) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateGroupParticipantAdmin) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateGroupParticipantAdmin) GetGroupID() int64 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *UpdateGroupParticipantAdmin) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UpdateGroupParticipantAdmin) GetIsAdmin() bool {
	if m != nil {
		return m.IsAdmin
	}
	return false
}

// UpdateGroupAdmins
type UpdateGroupAdmins struct {
	UCount       int32 `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID     int64 `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	GroupID      int64 `protobuf:"varint,1,opt,name=GroupID,proto3" json:"GroupID,omitempty"`
	AdminEnabled bool  `protobuf:"varint,2,opt,name=AdminEnabled,proto3" json:"AdminEnabled,omitempty"`
}

func (m *UpdateGroupAdmins) Reset()         { *m = UpdateGroupAdmins{} }
func (m *UpdateGroupAdmins) String() string { return proto.CompactTextString(m) }
func (*UpdateGroupAdmins) ProtoMessage()    {}
func (*UpdateGroupAdmins) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{20}
}
func (m *UpdateGroupAdmins) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGroupAdmins) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGroupAdmins.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGroupAdmins) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGroupAdmins.Merge(m, src)
}
func (m *UpdateGroupAdmins) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGroupAdmins) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGroupAdmins.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGroupAdmins proto.InternalMessageInfo

func (m *UpdateGroupAdmins) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateGroupAdmins) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateGroupAdmins) GetGroupID() int64 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *UpdateGroupAdmins) GetAdminEnabled() bool {
	if m != nil {
		return m.AdminEnabled
	}
	return false
}

// UpdateGroupPhoto
type UpdateGroupPhoto struct {
	UCount   int32       `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID int64       `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	GroupID  int64       `protobuf:"varint,1,opt,name=GroupID,proto3" json:"GroupID,omitempty"`
	Photo    *GroupPhoto `protobuf:"bytes,2,opt,name=Photo,proto3" json:"Photo,omitempty"`
	PhotoID  int64       `protobuf:"varint,3,opt,name=PhotoID,proto3" json:"PhotoID,omitempty"`
}

func (m *UpdateGroupPhoto) Reset()         { *m = UpdateGroupPhoto{} }
func (m *UpdateGroupPhoto) String() string { return proto.CompactTextString(m) }
func (*UpdateGroupPhoto) ProtoMessage()    {}
func (*UpdateGroupPhoto) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{21}
}
func (m *UpdateGroupPhoto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGroupPhoto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGroupPhoto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGroupPhoto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGroupPhoto.Merge(m, src)
}
func (m *UpdateGroupPhoto) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGroupPhoto) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGroupPhoto.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGroupPhoto proto.InternalMessageInfo

func (m *UpdateGroupPhoto) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateGroupPhoto) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateGroupPhoto) GetGroupID() int64 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *UpdateGroupPhoto) GetPhoto() *GroupPhoto {
	if m != nil {
		return m.Photo
	}
	return nil
}

func (m *UpdateGroupPhoto) GetPhotoID() int64 {
	if m != nil {
		return m.PhotoID
	}
	return 0
}

// UpdateReadMessagesContents
type UpdateReadMessagesContents struct {
	UCount     int32   `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID   int64   `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	TeamID     int64   `protobuf:"varint,102,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	MessageIDs []int64 `protobuf:"varint,1,rep,packed,name=MessageIDs,proto3" json:"MessageIDs,omitempty"`
	Peer       *Peer   `protobuf:"bytes,2,opt,name=Peer,proto3" json:"Peer,omitempty"`
}

func (m *UpdateReadMessagesContents) Reset()         { *m = UpdateReadMessagesContents{} }
func (m *UpdateReadMessagesContents) String() string { return proto.CompactTextString(m) }
func (*UpdateReadMessagesContents) ProtoMessage()    {}
func (*UpdateReadMessagesContents) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{22}
}
func (m *UpdateReadMessagesContents) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateReadMessagesContents) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateReadMessagesContents.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateReadMessagesContents) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateReadMessagesContents.Merge(m, src)
}
func (m *UpdateReadMessagesContents) XXX_Size() int {
	return m.Size()
}
func (m *UpdateReadMessagesContents) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateReadMessagesContents.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateReadMessagesContents proto.InternalMessageInfo

func (m *UpdateReadMessagesContents) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateReadMessagesContents) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateReadMessagesContents) GetTeamID() int64 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *UpdateReadMessagesContents) GetMessageIDs() []int64 {
	if m != nil {
		return m.MessageIDs
	}
	return nil
}

func (m *UpdateReadMessagesContents) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

// UpdateAuthorizationReset
type UpdateAuthorizationReset struct {
	UCount   int32 `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID int64 `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
}

func (m *UpdateAuthorizationReset) Reset()         { *m = UpdateAuthorizationReset{} }
func (m *UpdateAuthorizationReset) String() string { return proto.CompactTextString(m) }
func (*UpdateAuthorizationReset) ProtoMessage()    {}
func (*UpdateAuthorizationReset) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{23}
}
func (m *UpdateAuthorizationReset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateAuthorizationReset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateAuthorizationReset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateAuthorizationReset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateAuthorizationReset.Merge(m, src)
}
func (m *UpdateAuthorizationReset) XXX_Size() int {
	return m.Size()
}
func (m *UpdateAuthorizationReset) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateAuthorizationReset.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateAuthorizationReset proto.InternalMessageInfo

func (m *UpdateAuthorizationReset) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateAuthorizationReset) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

// UpdateDraftMessage
type UpdateDraftMessage struct {
	UCount   int32         `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID int64         `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	Message  *DraftMessage `protobuf:"bytes,1,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *UpdateDraftMessage) Reset()         { *m = UpdateDraftMessage{} }
func (m *UpdateDraftMessage) String() string { return proto.CompactTextString(m) }
func (*UpdateDraftMessage) ProtoMessage()    {}
func (*UpdateDraftMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{24}
}
func (m *UpdateDraftMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateDraftMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateDraftMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateDraftMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateDraftMessage.Merge(m, src)
}
func (m *UpdateDraftMessage) XXX_Size() int {
	return m.Size()
}
func (m *UpdateDraftMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateDraftMessage.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateDraftMessage proto.InternalMessageInfo

func (m *UpdateDraftMessage) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateDraftMessage) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateDraftMessage) GetMessage() *DraftMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

// UpdateDraftMessageCleared
type UpdateDraftMessageCleared struct {
	UCount   int32 `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID int64 `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	TeamID   int64 `protobuf:"varint,102,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	Peer     *Peer `protobuf:"bytes,1,opt,name=Peer,proto3" json:"Peer,omitempty"`
}

func (m *UpdateDraftMessageCleared) Reset()         { *m = UpdateDraftMessageCleared{} }
func (m *UpdateDraftMessageCleared) String() string { return proto.CompactTextString(m) }
func (*UpdateDraftMessageCleared) ProtoMessage()    {}
func (*UpdateDraftMessageCleared) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{25}
}
func (m *UpdateDraftMessageCleared) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateDraftMessageCleared) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateDraftMessageCleared.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateDraftMessageCleared) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateDraftMessageCleared.Merge(m, src)
}
func (m *UpdateDraftMessageCleared) XXX_Size() int {
	return m.Size()
}
func (m *UpdateDraftMessageCleared) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateDraftMessageCleared.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateDraftMessageCleared proto.InternalMessageInfo

func (m *UpdateDraftMessageCleared) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateDraftMessageCleared) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateDraftMessageCleared) GetTeamID() int64 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *UpdateDraftMessageCleared) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

// UpdateDialogPinned
type UpdateDialogPinned struct {
	UCount   int32 `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID int64 `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	TeamID   int64 `protobuf:"varint,102,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	Peer     *Peer `protobuf:"bytes,1,opt,name=Peer,proto3" json:"Peer,omitempty"`
	Pinned   bool  `protobuf:"varint,2,opt,name=Pinned,proto3" json:"Pinned,omitempty"`
}

func (m *UpdateDialogPinned) Reset()         { *m = UpdateDialogPinned{} }
func (m *UpdateDialogPinned) String() string { return proto.CompactTextString(m) }
func (*UpdateDialogPinned) ProtoMessage()    {}
func (*UpdateDialogPinned) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{26}
}
func (m *UpdateDialogPinned) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateDialogPinned) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateDialogPinned.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateDialogPinned) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateDialogPinned.Merge(m, src)
}
func (m *UpdateDialogPinned) XXX_Size() int {
	return m.Size()
}
func (m *UpdateDialogPinned) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateDialogPinned.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateDialogPinned proto.InternalMessageInfo

func (m *UpdateDialogPinned) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateDialogPinned) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateDialogPinned) GetTeamID() int64 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *UpdateDialogPinned) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *UpdateDialogPinned) GetPinned() bool {
	if m != nil {
		return m.Pinned
	}
	return false
}

// UpdateDialogPinnedOrder
type UpdateDialogPinnedReorder struct {
	UCount   int32   `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID int64   `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	Peer     []*Peer `protobuf:"bytes,1,rep,name=Peer,proto3" json:"Peer,omitempty"`
}

func (m *UpdateDialogPinnedReorder) Reset()         { *m = UpdateDialogPinnedReorder{} }
func (m *UpdateDialogPinnedReorder) String() string { return proto.CompactTextString(m) }
func (*UpdateDialogPinnedReorder) ProtoMessage()    {}
func (*UpdateDialogPinnedReorder) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{27}
}
func (m *UpdateDialogPinnedReorder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateDialogPinnedReorder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateDialogPinnedReorder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateDialogPinnedReorder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateDialogPinnedReorder.Merge(m, src)
}
func (m *UpdateDialogPinnedReorder) XXX_Size() int {
	return m.Size()
}
func (m *UpdateDialogPinnedReorder) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateDialogPinnedReorder.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateDialogPinnedReorder proto.InternalMessageInfo

func (m *UpdateDialogPinnedReorder) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateDialogPinnedReorder) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateDialogPinnedReorder) GetPeer() []*Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

// UpdateAccountPrivacy
type UpdateAccountPrivacy struct {
	UCount           int32          `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID         int64          `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	ChatInvite       []*PrivacyRule `protobuf:"bytes,1,rep,name=ChatInvite,proto3" json:"ChatInvite,omitempty"`
	LastSeen         []*PrivacyRule `protobuf:"bytes,2,rep,name=LastSeen,proto3" json:"LastSeen,omitempty"`
	PhoneNumber      []*PrivacyRule `protobuf:"bytes,3,rep,name=PhoneNumber,proto3" json:"PhoneNumber,omitempty"`
	ProfilePhoto     []*PrivacyRule `protobuf:"bytes,4,rep,name=ProfilePhoto,proto3" json:"ProfilePhoto,omitempty"`
	ForwardedMessage []*PrivacyRule `protobuf:"bytes,5,rep,name=ForwardedMessage,proto3" json:"ForwardedMessage,omitempty"`
	Call             []*PrivacyRule `protobuf:"bytes,6,rep,name=Call,proto3" json:"Call,omitempty"`
}

func (m *UpdateAccountPrivacy) Reset()         { *m = UpdateAccountPrivacy{} }
func (m *UpdateAccountPrivacy) String() string { return proto.CompactTextString(m) }
func (*UpdateAccountPrivacy) ProtoMessage()    {}
func (*UpdateAccountPrivacy) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{28}
}
func (m *UpdateAccountPrivacy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateAccountPrivacy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateAccountPrivacy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateAccountPrivacy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateAccountPrivacy.Merge(m, src)
}
func (m *UpdateAccountPrivacy) XXX_Size() int {
	return m.Size()
}
func (m *UpdateAccountPrivacy) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateAccountPrivacy.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateAccountPrivacy proto.InternalMessageInfo

func (m *UpdateAccountPrivacy) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateAccountPrivacy) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateAccountPrivacy) GetChatInvite() []*PrivacyRule {
	if m != nil {
		return m.ChatInvite
	}
	return nil
}

func (m *UpdateAccountPrivacy) GetLastSeen() []*PrivacyRule {
	if m != nil {
		return m.LastSeen
	}
	return nil
}

func (m *UpdateAccountPrivacy) GetPhoneNumber() []*PrivacyRule {
	if m != nil {
		return m.PhoneNumber
	}
	return nil
}

func (m *UpdateAccountPrivacy) GetProfilePhoto() []*PrivacyRule {
	if m != nil {
		return m.ProfilePhoto
	}
	return nil
}

func (m *UpdateAccountPrivacy) GetForwardedMessage() []*PrivacyRule {
	if m != nil {
		return m.ForwardedMessage
	}
	return nil
}

func (m *UpdateAccountPrivacy) GetCall() []*PrivacyRule {
	if m != nil {
		return m.Call
	}
	return nil
}

// UpdateLabelItemAdded
type UpdateLabelItemsAdded struct {
	UCount     int32    `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID   int64    `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	TeamID     int64    `protobuf:"varint,102,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	Peer       *Peer    `protobuf:"bytes,1,opt,name=Peer,proto3" json:"Peer,omitempty"`
	MessageIDs []int64  `protobuf:"varint,3,rep,packed,name=MessageIDs,proto3" json:"MessageIDs,omitempty"`
	LabelIDs   []int32  `protobuf:"varint,4,rep,packed,name=LabelIDs,proto3" json:"LabelIDs,omitempty"`
	Labels     []*Label `protobuf:"bytes,5,rep,name=Labels,proto3" json:"Labels,omitempty"`
}

func (m *UpdateLabelItemsAdded) Reset()         { *m = UpdateLabelItemsAdded{} }
func (m *UpdateLabelItemsAdded) String() string { return proto.CompactTextString(m) }
func (*UpdateLabelItemsAdded) ProtoMessage()    {}
func (*UpdateLabelItemsAdded) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{29}
}
func (m *UpdateLabelItemsAdded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateLabelItemsAdded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateLabelItemsAdded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateLabelItemsAdded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateLabelItemsAdded.Merge(m, src)
}
func (m *UpdateLabelItemsAdded) XXX_Size() int {
	return m.Size()
}
func (m *UpdateLabelItemsAdded) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateLabelItemsAdded.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateLabelItemsAdded proto.InternalMessageInfo

func (m *UpdateLabelItemsAdded) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateLabelItemsAdded) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateLabelItemsAdded) GetTeamID() int64 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *UpdateLabelItemsAdded) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *UpdateLabelItemsAdded) GetMessageIDs() []int64 {
	if m != nil {
		return m.MessageIDs
	}
	return nil
}

func (m *UpdateLabelItemsAdded) GetLabelIDs() []int32 {
	if m != nil {
		return m.LabelIDs
	}
	return nil
}

func (m *UpdateLabelItemsAdded) GetLabels() []*Label {
	if m != nil {
		return m.Labels
	}
	return nil
}

// UpdateLabelItemsRemoved
type UpdateLabelItemsRemoved struct {
	UCount     int32    `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID   int64    `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	TeamID     int64    `protobuf:"varint,102,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	Peer       *Peer    `protobuf:"bytes,1,opt,name=Peer,proto3" json:"Peer,omitempty"`
	MessageIDs []int64  `protobuf:"varint,3,rep,packed,name=MessageIDs,proto3" json:"MessageIDs,omitempty"`
	LabelIDs   []int32  `protobuf:"varint,4,rep,packed,name=LabelIDs,proto3" json:"LabelIDs,omitempty"`
	Labels     []*Label `protobuf:"bytes,5,rep,name=Labels,proto3" json:"Labels,omitempty"`
}

func (m *UpdateLabelItemsRemoved) Reset()         { *m = UpdateLabelItemsRemoved{} }
func (m *UpdateLabelItemsRemoved) String() string { return proto.CompactTextString(m) }
func (*UpdateLabelItemsRemoved) ProtoMessage()    {}
func (*UpdateLabelItemsRemoved) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{30}
}
func (m *UpdateLabelItemsRemoved) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateLabelItemsRemoved) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateLabelItemsRemoved.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateLabelItemsRemoved) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateLabelItemsRemoved.Merge(m, src)
}
func (m *UpdateLabelItemsRemoved) XXX_Size() int {
	return m.Size()
}
func (m *UpdateLabelItemsRemoved) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateLabelItemsRemoved.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateLabelItemsRemoved proto.InternalMessageInfo

func (m *UpdateLabelItemsRemoved) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateLabelItemsRemoved) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateLabelItemsRemoved) GetTeamID() int64 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *UpdateLabelItemsRemoved) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *UpdateLabelItemsRemoved) GetMessageIDs() []int64 {
	if m != nil {
		return m.MessageIDs
	}
	return nil
}

func (m *UpdateLabelItemsRemoved) GetLabelIDs() []int32 {
	if m != nil {
		return m.LabelIDs
	}
	return nil
}

func (m *UpdateLabelItemsRemoved) GetLabels() []*Label {
	if m != nil {
		return m.Labels
	}
	return nil
}

// UpdateLabelSet
type UpdateLabelSet struct {
	UCount   int32    `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID int64    `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	Labels   []*Label `protobuf:"bytes,1,rep,name=Labels,proto3" json:"Labels,omitempty"`
}

func (m *UpdateLabelSet) Reset()         { *m = UpdateLabelSet{} }
func (m *UpdateLabelSet) String() string { return proto.CompactTextString(m) }
func (*UpdateLabelSet) ProtoMessage()    {}
func (*UpdateLabelSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{31}
}
func (m *UpdateLabelSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateLabelSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateLabelSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateLabelSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateLabelSet.Merge(m, src)
}
func (m *UpdateLabelSet) XXX_Size() int {
	return m.Size()
}
func (m *UpdateLabelSet) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateLabelSet.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateLabelSet proto.InternalMessageInfo

func (m *UpdateLabelSet) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateLabelSet) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateLabelSet) GetLabels() []*Label {
	if m != nil {
		return m.Labels
	}
	return nil
}

// UpdateLabelDeleted
type UpdateLabelDeleted struct {
	UCount   int32   `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID int64   `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	LabelIDs []int32 `protobuf:"varint,1,rep,packed,name=LabelIDs,proto3" json:"LabelIDs,omitempty"`
}

func (m *UpdateLabelDeleted) Reset()         { *m = UpdateLabelDeleted{} }
func (m *UpdateLabelDeleted) String() string { return proto.CompactTextString(m) }
func (*UpdateLabelDeleted) ProtoMessage()    {}
func (*UpdateLabelDeleted) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{32}
}
func (m *UpdateLabelDeleted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateLabelDeleted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateLabelDeleted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateLabelDeleted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateLabelDeleted.Merge(m, src)
}
func (m *UpdateLabelDeleted) XXX_Size() int {
	return m.Size()
}
func (m *UpdateLabelDeleted) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateLabelDeleted.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateLabelDeleted proto.InternalMessageInfo

func (m *UpdateLabelDeleted) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateLabelDeleted) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateLabelDeleted) GetLabelIDs() []int32 {
	if m != nil {
		return m.LabelIDs
	}
	return nil
}

// UpdateUserBlocked
type UpdateUserBlocked struct {
	UCount   int32 `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID int64 `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	UserID   int64 `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	Blocked  bool  `protobuf:"varint,2,opt,name=Blocked,proto3" json:"Blocked,omitempty"`
}

func (m *UpdateUserBlocked) Reset()         { *m = UpdateUserBlocked{} }
func (m *UpdateUserBlocked) String() string { return proto.CompactTextString(m) }
func (*UpdateUserBlocked) ProtoMessage()    {}
func (*UpdateUserBlocked) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{33}
}
func (m *UpdateUserBlocked) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateUserBlocked) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateUserBlocked.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateUserBlocked) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateUserBlocked.Merge(m, src)
}
func (m *UpdateUserBlocked) XXX_Size() int {
	return m.Size()
}
func (m *UpdateUserBlocked) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateUserBlocked.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateUserBlocked proto.InternalMessageInfo

func (m *UpdateUserBlocked) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateUserBlocked) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateUserBlocked) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UpdateUserBlocked) GetBlocked() bool {
	if m != nil {
		return m.Blocked
	}
	return false
}

// UpdateMessagePoll
type UpdateMessagePoll struct {
	UCount   int32        `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID int64        `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	PollID   int64        `protobuf:"varint,1,opt,name=PollID,proto3" json:"PollID,omitempty"`
	Poll     *MediaPoll   `protobuf:"bytes,2,opt,name=Poll,proto3" json:"Poll,omitempty"`
	Results  *PollResults `protobuf:"bytes,3,opt,name=Results,proto3" json:"Results,omitempty"`
}

func (m *UpdateMessagePoll) Reset()         { *m = UpdateMessagePoll{} }
func (m *UpdateMessagePoll) String() string { return proto.CompactTextString(m) }
func (*UpdateMessagePoll) ProtoMessage()    {}
func (*UpdateMessagePoll) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{34}
}
func (m *UpdateMessagePoll) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateMessagePoll) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateMessagePoll.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateMessagePoll) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateMessagePoll.Merge(m, src)
}
func (m *UpdateMessagePoll) XXX_Size() int {
	return m.Size()
}
func (m *UpdateMessagePoll) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateMessagePoll.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateMessagePoll proto.InternalMessageInfo

func (m *UpdateMessagePoll) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateMessagePoll) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateMessagePoll) GetPollID() int64 {
	if m != nil {
		return m.PollID
	}
	return 0
}

func (m *UpdateMessagePoll) GetPoll() *MediaPoll {
	if m != nil {
		return m.Poll
	}
	return nil
}

func (m *UpdateMessagePoll) GetResults() *PollResults {
	if m != nil {
		return m.Results
	}
	return nil
}

// UpdateBotCallbackQuery
type UpdateBotCallbackQuery struct {
	UCount    int32  `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID  int64  `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	QueryID   int64  `protobuf:"varint,1,opt,name=QueryID,proto3" json:"QueryID,omitempty"`
	UserID    int64  `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID,omitempty"`
	Peer      *Peer  `protobuf:"bytes,3,opt,name=Peer,proto3" json:"Peer,omitempty"`
	MessageID int64  `protobuf:"varint,4,opt,name=MessageID,proto3" json:"MessageID,omitempty"`
	Data      []byte `protobuf:"bytes,5,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *UpdateBotCallbackQuery) Reset()         { *m = UpdateBotCallbackQuery{} }
func (m *UpdateBotCallbackQuery) String() string { return proto.CompactTextString(m) }
func (*UpdateBotCallbackQuery) ProtoMessage()    {}
func (*UpdateBotCallbackQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{35}
}
func (m *UpdateBotCallbackQuery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateBotCallbackQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateBotCallbackQuery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateBotCallbackQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateBotCallbackQuery.Merge(m, src)
}
func (m *UpdateBotCallbackQuery) XXX_Size() int {
	return m.Size()
}
func (m *UpdateBotCallbackQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateBotCallbackQuery.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateBotCallbackQuery proto.InternalMessageInfo

func (m *UpdateBotCallbackQuery) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateBotCallbackQuery) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateBotCallbackQuery) GetQueryID() int64 {
	if m != nil {
		return m.QueryID
	}
	return 0
}

func (m *UpdateBotCallbackQuery) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UpdateBotCallbackQuery) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *UpdateBotCallbackQuery) GetMessageID() int64 {
	if m != nil {
		return m.MessageID
	}
	return 0
}

func (m *UpdateBotCallbackQuery) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// UpdateBotInlineQuery
type UpdateBotInlineQuery struct {
	UCount   int32        `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID int64        `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	QueryID  int64        `protobuf:"varint,1,opt,name=QueryID,proto3" json:"QueryID,omitempty"`
	UserID   int64        `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID,omitempty"`
	Peer     *Peer        `protobuf:"bytes,3,opt,name=Peer,proto3" json:"Peer,omitempty"`
	Query    string       `protobuf:"bytes,4,opt,name=Query,proto3" json:"Query,omitempty"`
	Offset   string       `protobuf:"bytes,5,opt,name=Offset,proto3" json:"Offset,omitempty"`
	Geo      *GeoLocation `protobuf:"bytes,6,opt,name=Geo,proto3" json:"Geo,omitempty"`
}

func (m *UpdateBotInlineQuery) Reset()         { *m = UpdateBotInlineQuery{} }
func (m *UpdateBotInlineQuery) String() string { return proto.CompactTextString(m) }
func (*UpdateBotInlineQuery) ProtoMessage()    {}
func (*UpdateBotInlineQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{36}
}
func (m *UpdateBotInlineQuery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateBotInlineQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateBotInlineQuery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateBotInlineQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateBotInlineQuery.Merge(m, src)
}
func (m *UpdateBotInlineQuery) XXX_Size() int {
	return m.Size()
}
func (m *UpdateBotInlineQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateBotInlineQuery.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateBotInlineQuery proto.InternalMessageInfo

func (m *UpdateBotInlineQuery) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateBotInlineQuery) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateBotInlineQuery) GetQueryID() int64 {
	if m != nil {
		return m.QueryID
	}
	return 0
}

func (m *UpdateBotInlineQuery) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UpdateBotInlineQuery) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *UpdateBotInlineQuery) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *UpdateBotInlineQuery) GetOffset() string {
	if m != nil {
		return m.Offset
	}
	return ""
}

func (m *UpdateBotInlineQuery) GetGeo() *GeoLocation {
	if m != nil {
		return m.Geo
	}
	return nil
}

// UpdateBotInlineSend
type UpdateBotInlineSend struct {
	UCount   int32        `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID int64        `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	UserID   int64        `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID,omitempty"`
	Query    string       `protobuf:"bytes,3,opt,name=Query,proto3" json:"Query,omitempty"`
	ResultID string       `protobuf:"bytes,4,opt,name=ResultID,proto3" json:"ResultID,omitempty"`
	Geo      *GeoLocation `protobuf:"bytes,5,opt,name=Geo,proto3" json:"Geo,omitempty"`
}

func (m *UpdateBotInlineSend) Reset()         { *m = UpdateBotInlineSend{} }
func (m *UpdateBotInlineSend) String() string { return proto.CompactTextString(m) }
func (*UpdateBotInlineSend) ProtoMessage()    {}
func (*UpdateBotInlineSend) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{37}
}
func (m *UpdateBotInlineSend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateBotInlineSend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateBotInlineSend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateBotInlineSend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateBotInlineSend.Merge(m, src)
}
func (m *UpdateBotInlineSend) XXX_Size() int {
	return m.Size()
}
func (m *UpdateBotInlineSend) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateBotInlineSend.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateBotInlineSend proto.InternalMessageInfo

func (m *UpdateBotInlineSend) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateBotInlineSend) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateBotInlineSend) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UpdateBotInlineSend) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *UpdateBotInlineSend) GetResultID() string {
	if m != nil {
		return m.ResultID
	}
	return ""
}

func (m *UpdateBotInlineSend) GetGeo() *GeoLocation {
	if m != nil {
		return m.Geo
	}
	return nil
}

// UpdateTeamCreated
type UpdateTeamCreated struct {
	UCount   int32 `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID int64 `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	Team     *Team `protobuf:"bytes,1,opt,name=Team,proto3" json:"Team,omitempty"`
}

func (m *UpdateTeamCreated) Reset()         { *m = UpdateTeamCreated{} }
func (m *UpdateTeamCreated) String() string { return proto.CompactTextString(m) }
func (*UpdateTeamCreated) ProtoMessage()    {}
func (*UpdateTeamCreated) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{38}
}
func (m *UpdateTeamCreated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTeamCreated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTeamCreated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateTeamCreated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTeamCreated.Merge(m, src)
}
func (m *UpdateTeamCreated) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTeamCreated) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTeamCreated.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTeamCreated proto.InternalMessageInfo

func (m *UpdateTeamCreated) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateTeamCreated) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateTeamCreated) GetTeam() *Team {
	if m != nil {
		return m.Team
	}
	return nil
}

// UpdateTeamMemberAdded
type UpdateTeamMemberAdded struct {
	UCount   int32        `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID int64        `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	TeamID   int64        `protobuf:"varint,1,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	User     *User        `protobuf:"bytes,2,opt,name=User,proto3" json:"User,omitempty"`
	Contact  *ContactUser `protobuf:"bytes,3,opt,name=Contact,proto3" json:"Contact,omitempty"`
	AdderID  int64        `protobuf:"varint,4,opt,name=AdderID,proto3" json:"AdderID,omitempty"`
	Hash     uint32       `protobuf:"fixed32,5,opt,name=Hash,proto3" json:"Hash,omitempty"`
}

func (m *UpdateTeamMemberAdded) Reset()         { *m = UpdateTeamMemberAdded{} }
func (m *UpdateTeamMemberAdded) String() string { return proto.CompactTextString(m) }
func (*UpdateTeamMemberAdded) ProtoMessage()    {}
func (*UpdateTeamMemberAdded) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{39}
}
func (m *UpdateTeamMemberAdded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTeamMemberAdded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTeamMemberAdded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateTeamMemberAdded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTeamMemberAdded.Merge(m, src)
}
func (m *UpdateTeamMemberAdded) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTeamMemberAdded) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTeamMemberAdded.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTeamMemberAdded proto.InternalMessageInfo

func (m *UpdateTeamMemberAdded) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateTeamMemberAdded) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateTeamMemberAdded) GetTeamID() int64 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *UpdateTeamMemberAdded) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *UpdateTeamMemberAdded) GetContact() *ContactUser {
	if m != nil {
		return m.Contact
	}
	return nil
}

func (m *UpdateTeamMemberAdded) GetAdderID() int64 {
	if m != nil {
		return m.AdderID
	}
	return 0
}

func (m *UpdateTeamMemberAdded) GetHash() uint32 {
	if m != nil {
		return m.Hash
	}
	return 0
}

// UpdateTeamMemberRemoved
type UpdateTeamMemberRemoved struct {
	UCount    int32  `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID  int64  `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	TeamID    int64  `protobuf:"varint,1,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	UserID    int64  `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID,omitempty"`
	RemoverID int64  `protobuf:"varint,3,opt,name=RemoverID,proto3" json:"RemoverID,omitempty"`
	Hash      uint32 `protobuf:"fixed32,4,opt,name=Hash,proto3" json:"Hash,omitempty"`
}

func (m *UpdateTeamMemberRemoved) Reset()         { *m = UpdateTeamMemberRemoved{} }
func (m *UpdateTeamMemberRemoved) String() string { return proto.CompactTextString(m) }
func (*UpdateTeamMemberRemoved) ProtoMessage()    {}
func (*UpdateTeamMemberRemoved) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{40}
}
func (m *UpdateTeamMemberRemoved) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTeamMemberRemoved) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTeamMemberRemoved.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateTeamMemberRemoved) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTeamMemberRemoved.Merge(m, src)
}
func (m *UpdateTeamMemberRemoved) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTeamMemberRemoved) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTeamMemberRemoved.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTeamMemberRemoved proto.InternalMessageInfo

func (m *UpdateTeamMemberRemoved) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateTeamMemberRemoved) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateTeamMemberRemoved) GetTeamID() int64 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *UpdateTeamMemberRemoved) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UpdateTeamMemberRemoved) GetRemoverID() int64 {
	if m != nil {
		return m.RemoverID
	}
	return 0
}

func (m *UpdateTeamMemberRemoved) GetHash() uint32 {
	if m != nil {
		return m.Hash
	}
	return 0
}

// UpdateTeamMemberStatus
type UpdateTeamMemberStatus struct {
	UCount    int32 `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID  int64 `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	TeamID    int64 `protobuf:"varint,1,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	ChangerID int64 `protobuf:"varint,3,opt,name=ChangerID,proto3" json:"ChangerID,omitempty"`
	Admin     bool  `protobuf:"varint,4,opt,name=Admin,proto3" json:"Admin,omitempty"`
}

func (m *UpdateTeamMemberStatus) Reset()         { *m = UpdateTeamMemberStatus{} }
func (m *UpdateTeamMemberStatus) String() string { return proto.CompactTextString(m) }
func (*UpdateTeamMemberStatus) ProtoMessage()    {}
func (*UpdateTeamMemberStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{41}
}
func (m *UpdateTeamMemberStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTeamMemberStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTeamMemberStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateTeamMemberStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTeamMemberStatus.Merge(m, src)
}
func (m *UpdateTeamMemberStatus) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTeamMemberStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTeamMemberStatus.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTeamMemberStatus proto.InternalMessageInfo

func (m *UpdateTeamMemberStatus) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateTeamMemberStatus) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateTeamMemberStatus) GetTeamID() int64 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *UpdateTeamMemberStatus) GetChangerID() int64 {
	if m != nil {
		return m.ChangerID
	}
	return 0
}

func (m *UpdateTeamMemberStatus) GetAdmin() bool {
	if m != nil {
		return m.Admin
	}
	return false
}

// UpdateTeamPhoto
type UpdateTeamPhoto struct {
	UCount   int32      `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID int64      `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	TeamID   int64      `protobuf:"varint,1,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	Photo    *TeamPhoto `protobuf:"bytes,2,opt,name=Photo,proto3" json:"Photo,omitempty"`
}

func (m *UpdateTeamPhoto) Reset()         { *m = UpdateTeamPhoto{} }
func (m *UpdateTeamPhoto) String() string { return proto.CompactTextString(m) }
func (*UpdateTeamPhoto) ProtoMessage()    {}
func (*UpdateTeamPhoto) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{42}
}
func (m *UpdateTeamPhoto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTeamPhoto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTeamPhoto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateTeamPhoto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTeamPhoto.Merge(m, src)
}
func (m *UpdateTeamPhoto) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTeamPhoto) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTeamPhoto.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTeamPhoto proto.InternalMessageInfo

func (m *UpdateTeamPhoto) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateTeamPhoto) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateTeamPhoto) GetTeamID() int64 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *UpdateTeamPhoto) GetPhoto() *TeamPhoto {
	if m != nil {
		return m.Photo
	}
	return nil
}

// UpdateTeam
type UpdateTeam struct {
	UCount   int32  `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID int64  `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	TeamID   int64  `protobuf:"varint,1,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	Name     string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
}

func (m *UpdateTeam) Reset()         { *m = UpdateTeam{} }
func (m *UpdateTeam) String() string { return proto.CompactTextString(m) }
func (*UpdateTeam) ProtoMessage()    {}
func (*UpdateTeam) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{43}
}
func (m *UpdateTeam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTeam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTeam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateTeam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTeam.Merge(m, src)
}
func (m *UpdateTeam) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTeam) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTeam.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTeam proto.InternalMessageInfo

func (m *UpdateTeam) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateTeam) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateTeam) GetTeamID() int64 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *UpdateTeam) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// UpdateCommunityMessage
type UpdateCommunityMessage struct {
	TeamID      int64            `protobuf:"varint,100,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	SenderID    int64            `protobuf:"varint,1,opt,name=SenderID,proto3" json:"SenderID,omitempty"`
	ReceiverID  int64            `protobuf:"varint,2,opt,name=ReceiverID,proto3" json:"ReceiverID,omitempty"`
	Body        string           `protobuf:"bytes,3,opt,name=Body,proto3" json:"Body,omitempty"`
	CreatedOn   int64            `protobuf:"varint,4,opt,name=CreatedOn,proto3" json:"CreatedOn,omitempty"`
	GlobalMsgID uint64           `protobuf:"varint,5,opt,name=GlobalMsgID,proto3" json:"GlobalMsgID,omitempty"`
	Entities    []*MessageEntity `protobuf:"bytes,6,rep,name=Entities,proto3" json:"Entities,omitempty"`
	SenderMsgID int64            `protobuf:"varint,7,opt,name=SenderMsgID,proto3" json:"SenderMsgID,omitempty"`
}

func (m *UpdateCommunityMessage) Reset()         { *m = UpdateCommunityMessage{} }
func (m *UpdateCommunityMessage) String() string { return proto.CompactTextString(m) }
func (*UpdateCommunityMessage) ProtoMessage()    {}
func (*UpdateCommunityMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{44}
}
func (m *UpdateCommunityMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateCommunityMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateCommunityMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateCommunityMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateCommunityMessage.Merge(m, src)
}
func (m *UpdateCommunityMessage) XXX_Size() int {
	return m.Size()
}
func (m *UpdateCommunityMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateCommunityMessage.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateCommunityMessage proto.InternalMessageInfo

func (m *UpdateCommunityMessage) GetTeamID() int64 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *UpdateCommunityMessage) GetSenderID() int64 {
	if m != nil {
		return m.SenderID
	}
	return 0
}

func (m *UpdateCommunityMessage) GetReceiverID() int64 {
	if m != nil {
		return m.ReceiverID
	}
	return 0
}

func (m *UpdateCommunityMessage) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

func (m *UpdateCommunityMessage) GetCreatedOn() int64 {
	if m != nil {
		return m.CreatedOn
	}
	return 0
}

func (m *UpdateCommunityMessage) GetGlobalMsgID() uint64 {
	if m != nil {
		return m.GlobalMsgID
	}
	return 0
}

func (m *UpdateCommunityMessage) GetEntities() []*MessageEntity {
	if m != nil {
		return m.Entities
	}
	return nil
}

func (m *UpdateCommunityMessage) GetSenderMsgID() int64 {
	if m != nil {
		return m.SenderMsgID
	}
	return 0
}

// UpdateCommunityReadOutbox
type UpdateCommunityReadOutbox struct {
	TeamID      int64 `protobuf:"varint,100,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	SenderID    int64 `protobuf:"varint,1,opt,name=SenderID,proto3" json:"SenderID,omitempty"`
	ReceiverID  int64 `protobuf:"varint,2,opt,name=ReceiverID,proto3" json:"ReceiverID,omitempty"`
	SenderMsgID int64 `protobuf:"varint,3,opt,name=SenderMsgID,proto3" json:"SenderMsgID,omitempty"`
}

func (m *UpdateCommunityReadOutbox) Reset()         { *m = UpdateCommunityReadOutbox{} }
func (m *UpdateCommunityReadOutbox) String() string { return proto.CompactTextString(m) }
func (*UpdateCommunityReadOutbox) ProtoMessage()    {}
func (*UpdateCommunityReadOutbox) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{45}
}
func (m *UpdateCommunityReadOutbox) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateCommunityReadOutbox) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateCommunityReadOutbox.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateCommunityReadOutbox) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateCommunityReadOutbox.Merge(m, src)
}
func (m *UpdateCommunityReadOutbox) XXX_Size() int {
	return m.Size()
}
func (m *UpdateCommunityReadOutbox) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateCommunityReadOutbox.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateCommunityReadOutbox proto.InternalMessageInfo

func (m *UpdateCommunityReadOutbox) GetTeamID() int64 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *UpdateCommunityReadOutbox) GetSenderID() int64 {
	if m != nil {
		return m.SenderID
	}
	return 0
}

func (m *UpdateCommunityReadOutbox) GetReceiverID() int64 {
	if m != nil {
		return m.ReceiverID
	}
	return 0
}

func (m *UpdateCommunityReadOutbox) GetSenderMsgID() int64 {
	if m != nil {
		return m.SenderMsgID
	}
	return 0
}

// UpdateCommunityTyping
type UpdateCommunityTyping struct {
	TeamID     int64        `protobuf:"varint,100,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	SenderID   int64        `protobuf:"varint,1,opt,name=SenderID,proto3" json:"SenderID,omitempty"`
	ReceiverID int64        `protobuf:"varint,2,opt,name=ReceiverID,proto3" json:"ReceiverID,omitempty"`
	Action     TypingAction `protobuf:"varint,3,opt,name=Action,proto3,enum=msg.TypingAction" json:"Action,omitempty"`
}

func (m *UpdateCommunityTyping) Reset()         { *m = UpdateCommunityTyping{} }
func (m *UpdateCommunityTyping) String() string { return proto.CompactTextString(m) }
func (*UpdateCommunityTyping) ProtoMessage()    {}
func (*UpdateCommunityTyping) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{46}
}
func (m *UpdateCommunityTyping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateCommunityTyping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateCommunityTyping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateCommunityTyping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateCommunityTyping.Merge(m, src)
}
func (m *UpdateCommunityTyping) XXX_Size() int {
	return m.Size()
}
func (m *UpdateCommunityTyping) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateCommunityTyping.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateCommunityTyping proto.InternalMessageInfo

func (m *UpdateCommunityTyping) GetTeamID() int64 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *UpdateCommunityTyping) GetSenderID() int64 {
	if m != nil {
		return m.SenderID
	}
	return 0
}

func (m *UpdateCommunityTyping) GetReceiverID() int64 {
	if m != nil {
		return m.ReceiverID
	}
	return 0
}

func (m *UpdateCommunityTyping) GetAction() TypingAction {
	if m != nil {
		return m.Action
	}
	return TypingActionTyping
}

// UpdateReaction
type UpdateReaction struct {
	UCount        int32              `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID      int64              `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	MessageID     int64              `protobuf:"varint,1,opt,name=MessageID,proto3" json:"MessageID,omitempty"`
	Counter       []*ReactionCounter `protobuf:"bytes,2,rep,name=Counter,proto3" json:"Counter,omitempty"`
	TeamID        int64              `protobuf:"varint,3,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	Peer          *Peer              `protobuf:"bytes,4,opt,name=Peer,proto3" json:"Peer,omitempty"`
	Sender        *User              `protobuf:"bytes,5,opt,name=Sender,proto3" json:"Sender,omitempty"`
	YourReactions []string           `protobuf:"bytes,6,rep,name=YourReactions,proto3" json:"YourReactions,omitempty"`
	Reaction      string             `protobuf:"bytes,7,opt,name=Reaction,proto3" json:"Reaction,omitempty"`
}

func (m *UpdateReaction) Reset()         { *m = UpdateReaction{} }
func (m *UpdateReaction) String() string { return proto.CompactTextString(m) }
func (*UpdateReaction) ProtoMessage()    {}
func (*UpdateReaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{47}
}
func (m *UpdateReaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateReaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateReaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateReaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateReaction.Merge(m, src)
}
func (m *UpdateReaction) XXX_Size() int {
	return m.Size()
}
func (m *UpdateReaction) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateReaction.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateReaction proto.InternalMessageInfo

func (m *UpdateReaction) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateReaction) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateReaction) GetMessageID() int64 {
	if m != nil {
		return m.MessageID
	}
	return 0
}

func (m *UpdateReaction) GetCounter() []*ReactionCounter {
	if m != nil {
		return m.Counter
	}
	return nil
}

func (m *UpdateReaction) GetTeamID() int64 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *UpdateReaction) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *UpdateReaction) GetSender() *User {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *UpdateReaction) GetYourReactions() []string {
	if m != nil {
		return m.YourReactions
	}
	return nil
}

func (m *UpdateReaction) GetReaction() string {
	if m != nil {
		return m.Reaction
	}
	return ""
}

// UpdateCalendarEventAdded
type UpdateCalendarEventAdded struct {
	UCount   int32          `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID int64          `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	Event    *CalendarEvent `protobuf:"bytes,1,opt,name=Event,proto3" json:"Event,omitempty"`
}

func (m *UpdateCalendarEventAdded) Reset()         { *m = UpdateCalendarEventAdded{} }
func (m *UpdateCalendarEventAdded) String() string { return proto.CompactTextString(m) }
func (*UpdateCalendarEventAdded) ProtoMessage()    {}
func (*UpdateCalendarEventAdded) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{48}
}
func (m *UpdateCalendarEventAdded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateCalendarEventAdded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateCalendarEventAdded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateCalendarEventAdded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateCalendarEventAdded.Merge(m, src)
}
func (m *UpdateCalendarEventAdded) XXX_Size() int {
	return m.Size()
}
func (m *UpdateCalendarEventAdded) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateCalendarEventAdded.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateCalendarEventAdded proto.InternalMessageInfo

func (m *UpdateCalendarEventAdded) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateCalendarEventAdded) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateCalendarEventAdded) GetEvent() *CalendarEvent {
	if m != nil {
		return m.Event
	}
	return nil
}

// UpdateCalendarEventRemoved
type UpdateCalendarEventRemoved struct {
	UCount   int32 `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID int64 `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	EventID  int64 `protobuf:"varint,102,opt,name=EventID,proto3" json:"EventID,omitempty"`
}

func (m *UpdateCalendarEventRemoved) Reset()         { *m = UpdateCalendarEventRemoved{} }
func (m *UpdateCalendarEventRemoved) String() string { return proto.CompactTextString(m) }
func (*UpdateCalendarEventRemoved) ProtoMessage()    {}
func (*UpdateCalendarEventRemoved) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{49}
}
func (m *UpdateCalendarEventRemoved) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateCalendarEventRemoved) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateCalendarEventRemoved.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateCalendarEventRemoved) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateCalendarEventRemoved.Merge(m, src)
}
func (m *UpdateCalendarEventRemoved) XXX_Size() int {
	return m.Size()
}
func (m *UpdateCalendarEventRemoved) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateCalendarEventRemoved.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateCalendarEventRemoved proto.InternalMessageInfo

func (m *UpdateCalendarEventRemoved) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateCalendarEventRemoved) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateCalendarEventRemoved) GetEventID() int64 {
	if m != nil {
		return m.EventID
	}
	return 0
}

// UpdateCalendarEventEdited
type UpdateCalendarEventEdited struct {
	UCount   int32          `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID int64          `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	Event    *CalendarEvent `protobuf:"bytes,1,opt,name=Event,proto3" json:"Event,omitempty"`
}

func (m *UpdateCalendarEventEdited) Reset()         { *m = UpdateCalendarEventEdited{} }
func (m *UpdateCalendarEventEdited) String() string { return proto.CompactTextString(m) }
func (*UpdateCalendarEventEdited) ProtoMessage()    {}
func (*UpdateCalendarEventEdited) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{50}
}
func (m *UpdateCalendarEventEdited) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateCalendarEventEdited) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateCalendarEventEdited.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateCalendarEventEdited) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateCalendarEventEdited.Merge(m, src)
}
func (m *UpdateCalendarEventEdited) XXX_Size() int {
	return m.Size()
}
func (m *UpdateCalendarEventEdited) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateCalendarEventEdited.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateCalendarEventEdited proto.InternalMessageInfo

func (m *UpdateCalendarEventEdited) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateCalendarEventEdited) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateCalendarEventEdited) GetEvent() *CalendarEvent {
	if m != nil {
		return m.Event
	}
	return nil
}

// UpdateRedirect
type UpdateRedirect struct {
	UCount    int32             `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	UpdateID  int64             `protobuf:"varint,101,opt,name=UpdateID,proto3" json:"UpdateID,omitempty"`
	Redirects []*ClientRedirect `protobuf:"bytes,1,rep,name=Redirects,proto3" json:"Redirects,omitempty"`
	Empty     bool              `protobuf:"varint,2,opt,name=Empty,proto3" json:"Empty,omitempty"`
}

func (m *UpdateRedirect) Reset()         { *m = UpdateRedirect{} }
func (m *UpdateRedirect) String() string { return proto.CompactTextString(m) }
func (*UpdateRedirect) ProtoMessage()    {}
func (*UpdateRedirect) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{51}
}
func (m *UpdateRedirect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateRedirect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateRedirect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateRedirect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateRedirect.Merge(m, src)
}
func (m *UpdateRedirect) XXX_Size() int {
	return m.Size()
}
func (m *UpdateRedirect) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateRedirect.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateRedirect proto.InternalMessageInfo

func (m *UpdateRedirect) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateRedirect) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateRedirect) GetRedirects() []*ClientRedirect {
	if m != nil {
		return m.Redirects
	}
	return nil
}

func (m *UpdateRedirect) GetEmpty() bool {
	if m != nil {
		return m.Empty
	}
	return false
}

// ClientRedirect
type ClientRedirect struct {
	HostPort     string         `protobuf:"bytes,1,opt,name=HostPort,proto3" json:"HostPort,omitempty"`
	Permanent    bool           `protobuf:"varint,2,opt,name=Permanent,proto3" json:"Permanent,omitempty"`
	Target       RedirectTarget `protobuf:"varint,3,opt,name=Target,proto3,enum=msg.RedirectTarget" json:"Target,omitempty"`
	Alternatives []string       `protobuf:"bytes,4,rep,name=Alternatives,proto3" json:"Alternatives,omitempty"`
}

func (m *ClientRedirect) Reset()         { *m = ClientRedirect{} }
func (m *ClientRedirect) String() string { return proto.CompactTextString(m) }
func (*ClientRedirect) ProtoMessage()    {}
func (*ClientRedirect) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{52}
}
func (m *ClientRedirect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientRedirect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientRedirect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientRedirect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientRedirect.Merge(m, src)
}
func (m *ClientRedirect) XXX_Size() int {
	return m.Size()
}
func (m *ClientRedirect) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientRedirect.DiscardUnknown(m)
}

var xxx_messageInfo_ClientRedirect proto.InternalMessageInfo

func (m *ClientRedirect) GetHostPort() string {
	if m != nil {
		return m.HostPort
	}
	return ""
}

func (m *ClientRedirect) GetPermanent() bool {
	if m != nil {
		return m.Permanent
	}
	return false
}

func (m *ClientRedirect) GetTarget() RedirectTarget {
	if m != nil {
		return m.Target
	}
	return RedirectTargetRpc
}

func (m *ClientRedirect) GetAlternatives() []string {
	if m != nil {
		return m.Alternatives
	}
	return nil
}

// UpdatePhone
type UpdatePhoneCall struct {
	UCount     int32           `protobuf:"varint,100,opt,name=UCount,proto3" json:"UCount,omitempty"`
	TeamID     int64           `protobuf:"varint,1,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	PeerID     int64           `protobuf:"varint,2,opt,name=PeerID,proto3" json:"PeerID,omitempty"`
	PeerType   int32           `protobuf:"varint,3,opt,name=PeerType,proto3" json:"PeerType,omitempty"`
	CallID     int64           `protobuf:"varint,4,opt,name=CallID,proto3" json:"CallID,omitempty"`
	UserID     int64           `protobuf:"varint,5,opt,name=UserID,proto3" json:"UserID,omitempty"`
	AccessHash uint64          `protobuf:"fixed64,6,opt,name=AccessHash,proto3" json:"AccessHash,omitempty"`
	Action     PhoneCallAction `protobuf:"varint,7,opt,name=Action,proto3,enum=msg.PhoneCallAction" json:"Action,omitempty"`
	ActionData []byte          `protobuf:"bytes,8,opt,name=ActionData,proto3" json:"ActionData,omitempty"`
}

func (m *UpdatePhoneCall) Reset()         { *m = UpdatePhoneCall{} }
func (m *UpdatePhoneCall) String() string { return proto.CompactTextString(m) }
func (*UpdatePhoneCall) ProtoMessage()    {}
func (*UpdatePhoneCall) Descriptor() ([]byte, []int) {
	return fileDescriptor_675fc0bf03cd96fd, []int{53}
}
func (m *UpdatePhoneCall) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdatePhoneCall) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdatePhoneCall.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdatePhoneCall) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdatePhoneCall.Merge(m, src)
}
func (m *UpdatePhoneCall) XXX_Size() int {
	return m.Size()
}
func (m *UpdatePhoneCall) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdatePhoneCall.DiscardUnknown(m)
}

var xxx_messageInfo_UpdatePhoneCall proto.InternalMessageInfo

func (m *UpdatePhoneCall) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdatePhoneCall) GetTeamID() int64 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *UpdatePhoneCall) GetPeerID() int64 {
	if m != nil {
		return m.PeerID
	}
	return 0
}

func (m *UpdatePhoneCall) GetPeerType() int32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *UpdatePhoneCall) GetCallID() int64 {
	if m != nil {
		return m.CallID
	}
	return 0
}

func (m *UpdatePhoneCall) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UpdatePhoneCall) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *UpdatePhoneCall) GetAction() PhoneCallAction {
	if m != nil {
		return m.Action
	}
	return PhoneCallEmpty
}

func (m *UpdatePhoneCall) GetActionData() []byte {
	if m != nil {
		return m.ActionData
	}
	return nil
}

func init() {
	proto.RegisterEnum("msg.RedirectTarget", RedirectTarget_name, RedirectTarget_value)
	proto.RegisterType((*UpdateGetState)(nil), "msg.UpdateGetState")
	proto.RegisterType((*UpdateGetDifference)(nil), "msg.UpdateGetDifference")
	proto.RegisterType((*UpdateDifference)(nil), "msg.UpdateDifference")
	proto.RegisterType((*UpdateTooLong)(nil), "msg.UpdateTooLong")
	proto.RegisterType((*UpdateState)(nil), "msg.UpdateState")
	proto.RegisterType((*UpdateMessageID)(nil), "msg.UpdateMessageID")
	proto.RegisterType((*UpdateNewMessage)(nil), "msg.UpdateNewMessage")
	proto.RegisterType((*UpdateMessageEdited)(nil), "msg.UpdateMessageEdited")
	proto.RegisterType((*UpdateMessagesDeleted)(nil), "msg.UpdateMessagesDeleted")
	proto.RegisterType((*UpdateReadHistoryInbox)(nil), "msg.UpdateReadHistoryInbox")
	proto.RegisterType((*UpdateReadHistoryOutbox)(nil), "msg.UpdateReadHistoryOutbox")
	proto.RegisterType((*UpdateMessagePinned)(nil), "msg.UpdateMessagePinned")
	proto.RegisterType((*UpdateUserTyping)(nil), "msg.UpdateUserTyping")
	proto.RegisterType((*UpdateUserStatus)(nil), "msg.UpdateUserStatus")
	proto.RegisterType((*UpdateUsername)(nil), "msg.UpdateUsername")
	proto.RegisterType((*UpdateUserPhoto)(nil), "msg.UpdateUserPhoto")
	proto.RegisterType((*UpdateNotifySettings)(nil), "msg.UpdateNotifySettings")
	proto.RegisterType((*UpdateGroupParticipantAdd)(nil), "msg.UpdateGroupParticipantAdd")
	proto.RegisterType((*UpdateGroupParticipantDeleted)(nil), "msg.UpdateGroupParticipantDeleted")
	proto.RegisterType((*UpdateGroupParticipantAdmin)(nil), "msg.UpdateGroupParticipantAdmin")
	proto.RegisterType((*UpdateGroupAdmins)(nil), "msg.UpdateGroupAdmins")
	proto.RegisterType((*UpdateGroupPhoto)(nil), "msg.UpdateGroupPhoto")
	proto.RegisterType((*UpdateReadMessagesContents)(nil), "msg.UpdateReadMessagesContents")
	proto.RegisterType((*UpdateAuthorizationReset)(nil), "msg.UpdateAuthorizationReset")
	proto.RegisterType((*UpdateDraftMessage)(nil), "msg.UpdateDraftMessage")
	proto.RegisterType((*UpdateDraftMessageCleared)(nil), "msg.UpdateDraftMessageCleared")
	proto.RegisterType((*UpdateDialogPinned)(nil), "msg.UpdateDialogPinned")
	proto.RegisterType((*UpdateDialogPinnedReorder)(nil), "msg.UpdateDialogPinnedReorder")
	proto.RegisterType((*UpdateAccountPrivacy)(nil), "msg.UpdateAccountPrivacy")
	proto.RegisterType((*UpdateLabelItemsAdded)(nil), "msg.UpdateLabelItemsAdded")
	proto.RegisterType((*UpdateLabelItemsRemoved)(nil), "msg.UpdateLabelItemsRemoved")
	proto.RegisterType((*UpdateLabelSet)(nil), "msg.UpdateLabelSet")
	proto.RegisterType((*UpdateLabelDeleted)(nil), "msg.UpdateLabelDeleted")
	proto.RegisterType((*UpdateUserBlocked)(nil), "msg.UpdateUserBlocked")
	proto.RegisterType((*UpdateMessagePoll)(nil), "msg.UpdateMessagePoll")
	proto.RegisterType((*UpdateBotCallbackQuery)(nil), "msg.UpdateBotCallbackQuery")
	proto.RegisterType((*UpdateBotInlineQuery)(nil), "msg.UpdateBotInlineQuery")
	proto.RegisterType((*UpdateBotInlineSend)(nil), "msg.UpdateBotInlineSend")
	proto.RegisterType((*UpdateTeamCreated)(nil), "msg.UpdateTeamCreated")
	proto.RegisterType((*UpdateTeamMemberAdded)(nil), "msg.UpdateTeamMemberAdded")
	proto.RegisterType((*UpdateTeamMemberRemoved)(nil), "msg.UpdateTeamMemberRemoved")
	proto.RegisterType((*UpdateTeamMemberStatus)(nil), "msg.UpdateTeamMemberStatus")
	proto.RegisterType((*UpdateTeamPhoto)(nil), "msg.UpdateTeamPhoto")
	proto.RegisterType((*UpdateTeam)(nil), "msg.UpdateTeam")
	proto.RegisterType((*UpdateCommunityMessage)(nil), "msg.UpdateCommunityMessage")
	proto.RegisterType((*UpdateCommunityReadOutbox)(nil), "msg.UpdateCommunityReadOutbox")
	proto.RegisterType((*UpdateCommunityTyping)(nil), "msg.UpdateCommunityTyping")
	proto.RegisterType((*UpdateReaction)(nil), "msg.UpdateReaction")
	proto.RegisterType((*UpdateCalendarEventAdded)(nil), "msg.UpdateCalendarEventAdded")
	proto.RegisterType((*UpdateCalendarEventRemoved)(nil), "msg.UpdateCalendarEventRemoved")
	proto.RegisterType((*UpdateCalendarEventEdited)(nil), "msg.UpdateCalendarEventEdited")
	proto.RegisterType((*UpdateRedirect)(nil), "msg.UpdateRedirect")
	proto.RegisterType((*ClientRedirect)(nil), "msg.ClientRedirect")
	proto.RegisterType((*UpdatePhoneCall)(nil), "msg.UpdatePhoneCall")
}

func init() { proto.RegisterFile("updates.proto", fileDescriptor_675fc0bf03cd96fd) }

var fileDescriptor_675fc0bf03cd96fd = []byte{
	// 2327 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x5a, 0x4d, 0x6c, 0x1c, 0x49,
	0x15, 0x4e, 0xcf, 0xaf, 0xfd, 0xbc, 0x71, 0x26, 0x95, 0x6c, 0x32, 0x78, 0x13, 0x63, 0x8a, 0x20,
	0x79, 0xb3, 0x59, 0xef, 0xae, 0xb3, 0x37, 0x90, 0x90, 0x3d, 0x76, 0x12, 0x4b, 0x71, 0x32, 0x94,
	0x13, 0x24, 0x38, 0x20, 0xb5, 0xa7, 0x6b, 0xc6, 0xad, 0xed, 0xe9, 0x1a, 0x75, 0xd7, 0x78, 0x33,
	0x48, 0x9c, 0xf9, 0x91, 0x56, 0xe2, 0x02, 0x07, 0x56, 0x48, 0x5c, 0x00, 0x21, 0x0e, 0x48, 0x1c,
	0xe0, 0xc0, 0x81, 0x13, 0x12, 0x87, 0x95, 0x88, 0xc4, 0x05, 0x09, 0x09, 0x41, 0x82, 0x10, 0x17,
	0xee, 0x1c, 0x51, 0xbd, 0xfa, 0xe9, 0xee, 0xf1, 0x8c, 0x13, 0xc6, 0x4e, 0x88, 0xb8, 0xd5, 0x7b,
	0xf5, 0xaa, 0xde, 0x57, 0xd5, 0x55, 0xef, 0xaf, 0x1a, 0xce, 0x0e, 0x07, 0x81, 0x2f, 0x79, 0xba,
	0x36, 0x48, 0x84, 0x14, 0xa4, 0xdc, 0x4f, 0x7b, 0x4b, 0x8d, 0x8e, 0x48, 0xf8, 0x9a, 0x1c, 0x0d,
	0x2c, 0x7b, 0x69, 0xb1, 0xe3, 0x47, 0x3c, 0x0e, 0xfc, 0xc4, 0xd0, 0x4b, 0x9d, 0x03, 0x5f, 0xae,
	0xf5, 0x79, 0x9a, 0xfa, 0x3d, 0x9e, 0xae, 0xf5, 0x79, 0x10, 0xfa, 0x56, 0xb6, 0x81, 0x7d, 0x83,
	0x03, 0x11, 0x73, 0xc3, 0x79, 0xbb, 0x17, 0xca, 0x83, 0xe1, 0xfe, 0x5a, 0x47, 0xf4, 0xdf, 0xe9,
	0x89, 0x9e, 0x78, 0x07, 0xd9, 0xfb, 0xc3, 0x2e, 0x52, 0x48, 0x60, 0x4b, 0x8b, 0xd3, 0x06, 0x2c,
	0x3e, 0x44, 0x50, 0xb7, 0xb9, 0xdc, 0x93, 0xbe, 0xe4, 0xf4, 0x8b, 0x70, 0xc1, 0x71, 0xb6, 0xc2,
	0x6e, 0x97, 0x27, 0x3c, 0xee, 0x70, 0x42, 0xa0, 0x72, 0x2b, 0x11, 0xfd, 0xa6, 0xb7, 0xe2, 0xad,
	0x96, 0x19, 0xb6, 0xc9, 0x45, 0xa8, 0xde, 0x0d, 0xfb, 0xa1, 0x6c, 0x96, 0x56, 0xbc, 0xd5, 0x2a,
	0xd3, 0x04, 0xfd, 0x56, 0x09, 0x1a, 0x7a, 0x86, 0xe2, 0xf0, 0x5d, 0x91, 0x70, 0x1c, 0x3e, 0xc7,
	0xb0, 0x4d, 0x56, 0x60, 0x61, 0xd7, 0x7f, 0xa4, 0x45, 0x77, 0xb6, 0x70, 0x92, 0x32, 0xcb, 0xb3,
	0x50, 0x22, 0x8c, 0x9d, 0x44, 0xd9, 0x48, 0x64, 0x2c, 0xf2, 0x36, 0xd4, 0x75, 0x3b, 0x6d, 0x56,
	0x56, 0xca, 0xab, 0x0b, 0xeb, 0x17, 0xd6, 0xfa, 0x69, 0x6f, 0x4d, 0xf3, 0xb6, 0xe3, 0x43, 0x1e,
	0x89, 0x01, 0x67, 0x56, 0x86, 0x7c, 0x1a, 0xaa, 0x0f, 0x53, 0x9e, 0xa4, 0xcd, 0x2a, 0x0a, 0xcf,
	0x6b, 0xe1, 0x94, 0x27, 0x4c, 0xf3, 0x09, 0x85, 0xda, 0xed, 0x44, 0x0c, 0x07, 0x69, 0xb3, 0x86,
	0x12, 0x80, 0x12, 0xc8, 0x62, 0xa6, 0x87, 0xac, 0xc2, 0xb9, 0xd6, 0x30, 0x49, 0x78, 0x2c, 0x1d,
	0xb2, 0x3a, 0x22, 0x1b, 0x67, 0xd3, 0x73, 0x70, 0x56, 0xb7, 0x1f, 0x08, 0x71, 0x57, 0xc4, 0x3d,
	0xfa, 0x26, 0x2c, 0x68, 0x06, 0xee, 0x35, 0x59, 0x82, 0x39, 0x37, 0x85, 0xde, 0x58, 0x47, 0xd3,
	0x0e, 0x9c, 0xd3, 0xed, 0x5d, 0xfd, 0xe5, 0x77, 0xb6, 0xc8, 0x25, 0xa8, 0x3d, 0x6c, 0x89, 0x61,
	0x2c, 0x9b, 0x01, 0x6e, 0xb8, 0xa1, 0xc8, 0x15, 0x98, 0x77, 0x42, 0x66, 0x9e, 0x8c, 0xa1, 0x94,
	0x30, 0x3f, 0x0e, 0x44, 0xdf, 0xed, 0xb1, 0xa3, 0xe9, 0x9f, 0x3d, 0xfb, 0xad, 0xee, 0xf1, 0x0f,
	0xcd, 0x90, 0xa9, 0x6a, 0xf2, 0x68, 0x79, 0x11, 0x2d, 0xb9, 0x0e, 0x75, 0x33, 0x1c, 0x01, 0x2c,
	0xac, 0x37, 0xdc, 0xd6, 0x1a, 0x3e, 0xb3, 0x02, 0xe4, 0x33, 0x50, 0xdb, 0xe3, 0x71, 0xc0, 0x13,
	0x84, 0x53, 0xf8, 0x0a, 0xa6, 0x83, 0x50, 0x80, 0x8d, 0x4e, 0x87, 0xa7, 0xe9, 0x1d, 0x3f, 0x3d,
	0xc0, 0xef, 0x5e, 0xdb, 0x2c, 0xbd, 0xeb, 0xb1, 0x1c, 0x57, 0x1d, 0x0e, 0x2d, 0xcd, 0x78, 0x77,
	0x67, 0xab, 0x59, 0xd1, 0x87, 0x23, 0xc7, 0xa2, 0x43, 0x7b, 0x94, 0x8d, 0xe6, 0xed, 0x20, 0x94,
	0x3c, 0x78, 0xd1, 0xeb, 0xa3, 0x3f, 0xf1, 0xe0, 0xf5, 0x82, 0xde, 0x74, 0x8b, 0x47, 0x7c, 0x56,
	0xcd, 0x4b, 0x50, 0x7b, 0xc0, 0x7d, 0xf5, 0xf1, 0xba, 0xaa, 0x07, 0xb7, 0xc1, 0x70, 0xc8, 0x32,
	0x80, 0xfb, 0xce, 0x69, 0xd3, 0x5b, 0x29, 0xaf, 0x96, 0x59, 0x8e, 0x43, 0xae, 0x42, 0xa5, 0xcd,
	0xc7, 0xf6, 0x59, 0x31, 0x18, 0xb2, 0xe9, 0x0f, 0x3d, 0xb8, 0xa4, 0xf5, 0x30, 0xee, 0x07, 0x77,
	0xc2, 0x54, 0x8a, 0x64, 0xb4, 0x13, 0xef, 0x8b, 0x47, 0xa7, 0x8e, 0xd4, 0x22, 0xf1, 0x26, 0x22,
	0x51, 0x96, 0x64, 0xd7, 0x7f, 0xe4, 0x0e, 0xa8, 0x26, 0xe8, 0xaf, 0x3c, 0xb8, 0x7c, 0x04, 0xdf,
	0xfd, 0xa1, 0x7c, 0x55, 0x00, 0x22, 0x88, 0x94, 0x27, 0xce, 0x34, 0x19, 0x8a, 0x7e, 0xe2, 0x8d,
	0x9d, 0xbc, 0x76, 0x18, 0xc7, 0x2f, 0xe0, 0xfb, 0x3f, 0x03, 0x74, 0x06, 0xaf, 0x94, 0x87, 0x87,
	0x8b, 0x49, 0x7b, 0x0e, 0xb5, 0x26, 0x48, 0x13, 0xea, 0x5f, 0xe6, 0x49, 0x1a, 0x8a, 0xb8, 0x59,
	0x45, 0xbe, 0x25, 0xe9, 0xef, 0x9c, 0x95, 0x50, 0x13, 0x3c, 0x18, 0x0d, 0xc2, 0xb8, 0x77, 0xcc,
	0x5a, 0xa6, 0xe3, 0x5d, 0x72, 0x80, 0xbc, 0xac, 0xcf, 0x80, 0x7a, 0x13, 0x6a, 0x1b, 0x1d, 0xa9,
	0xb4, 0x2b, 0xb0, 0x8b, 0xeb, 0xe7, 0x71, 0x35, 0x5a, 0x99, 0xee, 0x60, 0x46, 0x40, 0x4d, 0xa3,
	0xd6, 0x67, 0x17, 0xa0, 0xa7, 0xd1, 0x1c, 0xb5, 0x95, 0xaa, 0xf5, 0x60, 0x34, 0xe0, 0x68, 0x12,
	0xaa, 0xcc, 0xd1, 0xf4, 0x6b, 0xf9, 0x65, 0x28, 0x0b, 0x3c, 0x4c, 0x8f, 0x5b, 0xc6, 0x54, 0xa8,
	0x97, 0xa0, 0xa6, 0x47, 0x1b, 0xc7, 0x67, 0x28, 0xfa, 0x17, 0xcf, 0x7a, 0x53, 0x25, 0x18, 0xfb,
	0x7d, 0x3e, 0xeb, 0x17, 0x9f, 0xaa, 0x5a, 0x8d, 0x33, 0x73, 0xa3, 0xf2, 0x79, 0xe6, 0x68, 0xe5,
	0x06, 0x6e, 0x85, 0x49, 0x2a, 0xef, 0xa9, 0xce, 0x32, 0x76, 0x66, 0x0c, 0x35, 0xf2, 0xae, 0x6f,
	0x3a, 0x2b, 0x7a, 0xa4, 0xa5, 0x49, 0x03, 0xca, 0x9b, 0xa1, 0xc0, 0xcf, 0x3e, 0xcf, 0x54, 0x53,
	0x1d, 0x91, 0xb6, 0x8a, 0x2a, 0x9a, 0x35, 0xe4, 0x69, 0x82, 0xfe, 0xd1, 0xb3, 0x4e, 0x49, 0x29,
	0x6d, 0x1f, 0xa8, 0x28, 0xe6, 0xb4, 0x57, 0x78, 0x0d, 0x35, 0x4b, 0x61, 0x8c, 0xd6, 0xa2, 0xb3,
	0xb3, 0xc8, 0x65, 0xba, 0x93, 0x5c, 0x81, 0x3a, 0x36, 0x0a, 0x67, 0xc0, 0xb2, 0xc8, 0x0d, 0x38,
	0x67, 0x4c, 0xae, 0xe1, 0xe8, 0xe8, 0x40, 0x4b, 0x8d, 0x77, 0xd1, 0x27, 0x1e, 0x5c, 0x34, 0x4e,
	0x50, 0xc8, 0xb0, 0x3b, 0xda, 0xe3, 0x52, 0x86, 0x71, 0x2f, 0x3d, 0xf5, 0xeb, 0x7a, 0xfc, 0xf1,
	0x07, 0xad, 0x7d, 0xb2, 0xc1, 0xce, 0x75, 0x92, 0x9b, 0x30, 0x67, 0x21, 0xe2, 0xe2, 0x17, 0xd6,
	0x2f, 0x3b, 0xc1, 0xe2, 0x0a, 0x98, 0x13, 0xa4, 0xbf, 0xf5, 0xe0, 0x53, 0x26, 0xae, 0x53, 0x51,
	0x4c, 0xdb, 0x4f, 0x64, 0xd8, 0x09, 0x07, 0x7e, 0x2c, 0x37, 0x82, 0xd9, 0x0c, 0xd3, 0x15, 0xa8,
	0xe3, 0x54, 0x85, 0xe5, 0x58, 0x56, 0x6e, 0xad, 0xa5, 0x23, 0x6b, 0x5d, 0x81, 0xf9, 0x9d, 0xf8,
	0x30, 0x94, 0x63, 0x57, 0x38, 0x63, 0xaa, 0x70, 0x71, 0xcb, 0x97, 0xdc, 0x38, 0x75, 0x6c, 0xd3,
	0x8f, 0x3c, 0xb8, 0x3a, 0x79, 0x05, 0x27, 0x71, 0xaf, 0x33, 0xaf, 0x82, 0xfe, 0xd8, 0x83, 0x37,
	0xa6, 0xed, 0x68, 0x3f, 0x8c, 0x5f, 0xf2, 0x9e, 0x36, 0xa1, 0xbe, 0x93, 0xa2, 0x62, 0xdc, 0xd1,
	0x39, 0x66, 0x49, 0xfa, 0x6d, 0x0f, 0xce, 0xe7, 0x70, 0x22, 0x33, 0x7d, 0x01, 0xe8, 0x28, 0xbc,
	0x86, 0x73, 0x6f, 0xc7, 0xfe, 0x7e, 0xc4, 0x03, 0xc4, 0x38, 0xc7, 0x0a, 0x3c, 0xfa, 0x33, 0xe7,
	0x49, 0xf4, 0x9e, 0xcd, 0x6c, 0x41, 0x8e, 0x87, 0xf2, 0xb9, 0xa2, 0x0d, 0x39, 0x97, 0x05, 0xf1,
	0xcf, 0x6f, 0x44, 0xe8, 0xcf, 0x3d, 0x58, 0xca, 0xa2, 0x0f, 0x1b, 0xca, 0xb5, 0x44, 0x2c, 0x79,
	0x2c, 0xd3, 0x57, 0x2d, 0x96, 0xbb, 0x07, 0x4d, 0xad, 0x66, 0x63, 0x28, 0x0f, 0x44, 0x12, 0x7e,
	0xdd, 0x47, 0x97, 0xc9, 0x53, 0x2e, 0x67, 0x81, 0x4a, 0x87, 0x40, 0x4c, 0x12, 0x97, 0xf8, 0x5d,
	0x79, 0x92, 0xd4, 0xe0, 0xad, 0xf1, 0xd0, 0x59, 0x7b, 0xf6, 0xfc, 0xbc, 0x59, 0xec, 0xfc, 0x1d,
	0x67, 0xa6, 0xf2, 0xfd, 0xad, 0x88, 0xfb, 0xc9, 0x4b, 0x8f, 0x9f, 0xe8, 0xc7, 0x9e, 0xdb, 0x84,
	0xd0, 0x8f, 0x44, 0xef, 0x7f, 0x16, 0xc5, 0x69, 0xc5, 0xe6, 0x46, 0x19, 0x8a, 0xc6, 0x6e, 0xa7,
	0x72, 0xe0, 0x18, 0x17, 0x49, 0x60, 0x42, 0xbf, 0xff, 0x16, 0x63, 0x86, 0xa3, 0x3c, 0x69, 0x37,
	0xfe, 0x5d, 0xb2, 0x6e, 0x72, 0xa3, 0xd3, 0x51, 0x93, 0xb5, 0x93, 0xf0, 0xd0, 0xef, 0x8c, 0x66,
	0xd2, 0xf5, 0x2e, 0x40, 0xeb, 0xc0, 0x97, 0xda, 0xe2, 0x1b, 0x8d, 0x3a, 0xa5, 0x32, 0xb3, 0xb2,
	0x61, 0xc4, 0x59, 0x4e, 0x86, 0xdc, 0xd0, 0xf1, 0xcb, 0x1e, 0xe7, 0x2a, 0x42, 0x9c, 0x2c, 0xef,
	0x24, 0xc8, 0x3a, 0x2c, 0x60, 0xc8, 0x72, 0x6f, 0xd8, 0xdf, 0xe7, 0x49, 0xb3, 0x3c, 0x65, 0x40,
	0x5e, 0x88, 0xbc, 0x0f, 0xaf, 0xb5, 0x13, 0xd1, 0x0d, 0x23, 0xae, 0x8d, 0x47, 0x65, 0xca, 0xa0,
	0x82, 0x14, 0xf9, 0x02, 0x34, 0x6e, 0x89, 0xe4, 0x43, 0x3f, 0x09, 0xb8, 0x35, 0x12, 0xa6, 0xba,
	0x70, 0x74, 0xe4, 0x11, 0x49, 0x72, 0x0d, 0x2a, 0x2d, 0x3f, 0x8a, 0x4c, 0xb5, 0xe1, 0xe8, 0x08,
	0xec, 0xa5, 0xff, 0x70, 0x19, 0xe5, 0x5d, 0x7f, 0x9f, 0x47, 0x3b, 0x92, 0xf7, 0xd3, 0x8d, 0x20,
	0x78, 0xf9, 0x67, 0xb1, 0x68, 0xa4, 0xca, 0x47, 0x8c, 0x14, 0x06, 0x99, 0x0a, 0xa1, 0x89, 0xb8,
	0xaa, 0xcc, 0xd1, 0x84, 0x42, 0x0d, 0xdb, 0xb6, 0xf8, 0xa2, 0x4b, 0x2b, 0xc8, 0x62, 0xa6, 0x87,
	0xfe, 0xd3, 0x65, 0x7c, 0xd9, 0x42, 0x19, 0xef, 0x8b, 0xc3, 0xff, 0xbf, 0xa5, 0x1e, 0xd8, 0x5c,
	0x01, 0xe9, 0xbd, 0xd9, 0xcc, 0x74, 0x4e, 0x93, 0x37, 0x55, 0x53, 0x60, 0xad, 0x18, 0xd2, 0x27,
	0xab, 0x45, 0x64, 0x6b, 0xf6, 0x8a, 0x6b, 0xa6, 0xdf, 0xb0, 0x51, 0x86, 0x0a, 0x48, 0x36, 0x23,
	0xd1, 0xf9, 0x60, 0xf6, 0x6f, 0x36, 0x35, 0x4a, 0x6e, 0x42, 0xdd, 0x4c, 0x6d, 0x8c, 0xa1, 0x25,
	0xe9, 0x2f, 0x5c, 0x94, 0x63, 0x53, 0x6e, 0x11, 0x45, 0x33, 0xe9, 0x57, 0xf6, 0x56, 0x44, 0x91,
	0x2b, 0xa5, 0x19, 0x8a, 0x50, 0xa8, 0xa8, 0x56, 0x21, 0x2f, 0xd9, 0xe5, 0x41, 0xe8, 0x2b, 0x2e,
	0xc3, 0x3e, 0x72, 0x1d, 0xea, 0x8c, 0xa7, 0xc3, 0x48, 0xda, 0xc8, 0xdc, 0xdc, 0x68, 0x25, 0xa1,
	0xf9, 0xcc, 0x0a, 0xd0, 0x3f, 0xb8, 0xea, 0xcb, 0xa6, 0x90, 0xea, 0x9a, 0xef, 0xfb, 0x9d, 0x0f,
	0xbe, 0x34, 0xe4, 0xc9, 0x6c, 0x16, 0xb5, 0x09, 0x75, 0x1c, 0xec, 0x70, 0x5b, 0x72, 0x6a, 0x19,
	0xc0, 0x5e, 0x80, 0xf2, 0xe4, 0x0b, 0x50, 0xa8, 0x2a, 0x56, 0xc6, 0xab, 0x8a, 0x3a, 0x42, 0xf7,
	0x31, 0x67, 0x7c, 0x0d, 0x23, 0x74, 0x9f, 0xfe, 0xcb, 0x25, 0x52, 0x9b, 0x42, 0xee, 0xc4, 0x51,
	0x18, 0xf3, 0x57, 0x68, 0x3d, 0x17, 0xa1, 0x8a, 0x33, 0x98, 0xec, 0xb7, 0xea, 0xa0, 0xdd, 0xef,
	0x76, 0x53, 0x2e, 0x4d, 0xf6, 0x6b, 0x28, 0x42, 0xa1, 0x7c, 0x9b, 0x0b, 0x4c, 0x7f, 0xed, 0x57,
	0xbc, 0xcd, 0xc5, 0x5d, 0xd1, 0xd1, 0x71, 0x95, 0xea, 0xa4, 0xbf, 0x76, 0x65, 0x1e, 0xb7, 0xde,
	0x3d, 0x1e, 0x07, 0xb3, 0x9e, 0xba, 0x69, 0xb5, 0x1a, 0x8d, 0xba, 0x9c, 0x47, 0xbd, 0x04, 0x73,
	0xfa, 0x18, 0x99, 0x4f, 0x33, 0xcf, 0x1c, 0x6d, 0x91, 0x57, 0x8f, 0x43, 0xde, 0xb5, 0x97, 0x45,
	0xd9, 0xc2, 0x56, 0xc2, 0xfd, 0x59, 0x2d, 0xc2, 0x55, 0xa8, 0xa8, 0x29, 0x0a, 0x46, 0x54, 0x31,
	0x18, 0xb2, 0xe9, 0xdf, 0x9d, 0xe3, 0x52, 0xe4, 0x2e, 0x57, 0x7e, 0xf6, 0x34, 0x1c, 0x97, 0x37,
	0xc9, 0x9a, 0xab, 0x1d, 0x3b, 0x5a, 0x52, 0x46, 0xb6, 0xba, 0x98, 0x2a, 0x72, 0xf7, 0x3b, 0xb2,
	0x70, 0x31, 0x0d, 0x0f, 0x05, 0xad, 0x80, 0x4a, 0x0b, 0x14, 0xc6, 0xc4, 0x1e, 0x7b, 0x9d, 0x16,
	0x18, 0x96, 0x3a, 0xf8, 0x58, 0x94, 0x56, 0xfb, 0x5b, 0x67, 0xd8, 0xa6, 0xbf, 0x71, 0x6e, 0x2b,
	0x5b, 0xe6, 0xe9, 0xb8, 0x2d, 0xef, 0x98, 0x22, 0xc2, 0xc4, 0xc4, 0x5a, 0xab, 0x1d, 0x4b, 0xac,
	0x1d, 0xd3, 0xa1, 0xaf, 0xe4, 0xd0, 0xff, 0xc8, 0x19, 0xa2, 0x0c, 0xfd, 0x33, 0xab, 0x63, 0xb3,
	0x81, 0x5f, 0x81, 0xf9, 0xd6, 0x81, 0x1f, 0xf7, 0xc6, 0x01, 0x3a, 0xa6, 0x3a, 0xef, 0x3a, 0x8b,
	0xad, 0xa0, 0x7d, 0xd7, 0x04, 0xfd, 0xa6, 0x2b, 0x3c, 0xa9, 0x89, 0x4e, 0x54, 0x78, 0x9a, 0x8a,
	0x6d, 0x62, 0xe1, 0xc9, 0xa9, 0x33, 0x39, 0x23, 0x1d, 0x00, 0x64, 0x40, 0x4e, 0x1d, 0x03, 0x81,
	0xca, 0xbd, 0xac, 0xb4, 0x87, 0x6d, 0xfa, 0xfd, 0x92, 0xfd, 0x3c, 0x2d, 0xd1, 0xef, 0x0f, 0xe3,
	0x50, 0x8e, 0x6c, 0xf4, 0x98, 0x4d, 0x15, 0x4c, 0x38, 0x27, 0x73, 0xfa, 0x2d, 0x24, 0x7b, 0x5b,
	0xb2, 0xb4, 0x8a, 0x6d, 0x18, 0xef, 0xf0, 0xf0, 0x30, 0x67, 0x70, 0x72, 0x1c, 0x05, 0x63, 0x53,
	0x04, 0xd6, 0xe6, 0x60, 0x5b, 0xb9, 0x03, 0x63, 0x28, 0xee, 0xc7, 0xd6, 0x1d, 0x38, 0x06, 0x59,
	0x81, 0x85, 0xdb, 0x91, 0xd8, 0xf7, 0x23, 0x5d, 0x58, 0x56, 0x97, 0xa3, 0xc2, 0xf2, 0x2c, 0xb2,
	0x06, 0x73, 0xdb, 0xb1, 0x0c, 0x65, 0xc8, 0xed, 0xdb, 0x1a, 0x31, 0x2e, 0x54, 0xbf, 0xcd, 0xa8,
	0xbe, 0x11, 0x73, 0x32, 0xd9, 0xf3, 0x8e, 0x9e, 0xb1, 0x9e, 0x7f, 0xde, 0x41, 0x16, 0xfd, 0x9e,
	0xcb, 0x15, 0xdd, 0xc6, 0xa8, 0x4c, 0xdd, 0x3c, 0x10, 0xbc, 0xa8, 0xbd, 0x19, 0xc3, 0x55, 0x3e,
	0x8a, 0xeb, 0x07, 0xce, 0xe8, 0x39, 0x5c, 0xa6, 0x66, 0xfe, 0xa2, 0x30, 0x65, 0xb5, 0xf3, 0xf2,
	0x33, 0x6a, 0xe7, 0xf4, 0x97, 0x25, 0x1b, 0x77, 0x32, 0xee, 0xeb, 0x72, 0xfa, 0x6c, 0xf5, 0x97,
	0xe3, 0x9e, 0x1c, 0xd7, 0x94, 0xb5, 0x1d, 0xc6, 0x12, 0xed, 0xb1, 0xfa, 0xd4, 0x17, 0x11, 0x90,
	0xd5, 0x68, 0xfa, 0x98, 0x15, 0xca, 0xed, 0x4b, 0x79, 0x6a, 0x98, 0x5e, 0x99, 0xec, 0xd5, 0xb3,
	0xc7, 0xc4, 0xea, 0xb4, 0xc7, 0xc4, 0x6b, 0x70, 0xf6, 0x2b, 0x62, 0x98, 0x58, 0xed, 0xfa, 0xf8,
	0xcd, 0xb3, 0x22, 0x53, 0xbb, 0x54, 0x4d, 0xe0, 0x61, 0x43, 0x97, 0xaa, 0x69, 0xfa, 0xc8, 0x16,
	0x57, 0x5a, 0xe6, 0x69, 0x7e, 0xfb, 0x90, 0x63, 0xe1, 0x74, 0x46, 0xfb, 0xbe, 0x0a, 0x55, 0x9c,
	0xc1, 0xb8, 0x4d, 0x7d, 0x11, 0x0a, 0x73, 0x33, 0x2d, 0x40, 0x63, 0x5b, 0x83, 0x2a, 0xf6, 0x9e,
	0xc0, 0xb7, 0x5c, 0x81, 0x3a, 0xce, 0x51, 0xc8, 0x89, 0x2c, 0x8b, 0x8e, 0xdc, 0x95, 0xca, 0xeb,
	0x3b, 0xc1, 0xc3, 0xe9, 0xf3, 0x2f, 0xf5, 0x23, 0x2f, 0x3b, 0x99, 0x41, 0x98, 0xf0, 0xce, 0x6c,
	0x19, 0xd1, 0x7b, 0xca, 0x07, 0xea, 0xf1, 0x36, 0x29, 0xd2, 0xff, 0x04, 0xb4, 0xa2, 0x10, 0xb7,
	0x4e, 0xf7, 0xb1, 0x4c, 0x4a, 0xf9, 0x9c, 0xed, 0xfe, 0x40, 0x8e, 0x4c, 0x4e, 0xa1, 0x09, 0xfa,
	0xb1, 0x07, 0x8b, 0xc5, 0x31, 0x4a, 0xef, 0x1d, 0x91, 0xca, 0xb6, 0x48, 0xf4, 0x7a, 0xe6, 0x99,
	0xa3, 0xd5, 0x8d, 0x68, 0xf3, 0xa4, 0xef, 0xc7, 0x6a, 0xb1, 0x7a, 0xa2, 0x8c, 0x41, 0xde, 0x82,
	0xda, 0x03, 0x3f, 0xe9, 0x71, 0x69, 0x6e, 0xe8, 0x05, 0x73, 0x21, 0xf4, 0xc4, 0xba, 0x8b, 0x19,
	0x11, 0xac, 0xa4, 0x46, 0x92, 0x27, 0xb1, 0x2f, 0xc3, 0x43, 0xf3, 0x67, 0xc3, 0x3c, 0x2b, 0xf0,
	0xe8, 0x4f, 0x4b, 0xd6, 0x23, 0x62, 0x09, 0x43, 0xe5, 0x0f, 0xcf, 0xf1, 0x24, 0x37, 0x31, 0x9c,
	0x30, 0x6f, 0x69, 0xa5, 0x63, 0xdf, 0xd2, 0xca, 0xc5, 0xb7, 0x34, 0x35, 0x4e, 0xe9, 0x2c, 0xc4,
	0x48, 0x86, 0x93, 0x0b, 0x51, 0xaa, 0x47, 0x42, 0x94, 0xe2, 0xcb, 0x7e, 0x6d, 0xe2, 0xcb, 0xfe,
	0x0d, 0x67, 0xce, 0xea, 0xb8, 0x59, 0xda, 0x7a, 0xb8, 0x75, 0x8e, 0xbd, 0x06, 0x2e, 0xab, 0x19,
	0x55, 0x0b, 0xf3, 0x91, 0x39, 0xcc, 0x47, 0x72, 0x9c, 0xeb, 0x9f, 0x78, 0xb0, 0x58, 0xdc, 0x68,
	0xf2, 0x3a, 0x9c, 0x1f, 0xdb, 0xfa, 0x41, 0xa7, 0x71, 0x86, 0x5c, 0x02, 0x52, 0x64, 0xdf, 0x0a,
	0x23, 0xde, 0xf0, 0xc8, 0x65, 0xb8, 0x50, 0xe4, 0xb7, 0x13, 0xf1, 0x68, 0xd4, 0x28, 0x91, 0x37,
	0xe0, 0xf2, 0xd8, 0x3c, 0x3c, 0xe5, 0xc9, 0x21, 0x0f, 0xde, 0x6b, 0x94, 0xa7, 0x77, 0xae, 0x37,
	0x2a, 0xd3, 0x3b, 0x6f, 0x36, 0xaa, 0xd3, 0x3b, 0xdf, 0x6f, 0xd4, 0x36, 0x3f, 0xfb, 0xf8, 0x6f,
	0xcb, 0x67, 0x7e, 0xff, 0x64, 0xd9, 0x7b, 0xfc, 0x64, 0xd9, 0xfb, 0xeb, 0x93, 0x65, 0xef, 0xbb,
	0x4f, 0x97, 0xcf, 0x3c, 0x7e, 0xba, 0x7c, 0xe6, 0x4f, 0x4f, 0x97, 0xcf, 0x7c, 0xb5, 0xba, 0xf6,
	0xf9, 0x7e, 0xda, 0xdb, 0xaf, 0xe1, 0xdf, 0x3d, 0x37, 0xff, 0x13, 0x00, 0x00, 0xff, 0xff, 0x76,
	0xa8, 0xeb, 0x1a, 0x72, 0x24, 0x00, 0x00,
}

func (m *UpdateGetState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGetState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGetState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *UpdateGetDifference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGetDifference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGetDifference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x10
	}
	if m.From != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.From))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateDifference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateDifference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateDifference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CurrentUpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.CurrentUpdateID))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Groups) > 0 {
		for iNdEx := len(m.Groups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Groups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpdates(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Users) > 0 {
		for iNdEx := len(m.Users) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Users[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpdates(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Updates) > 0 {
		for iNdEx := len(m.Updates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Updates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpdates(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.MinUpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.MinUpdateID))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxUpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.MaxUpdateID))
		i--
		dAtA[i] = 0x10
	}
	if m.More {
		i--
		if m.More {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateTooLong) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTooLong) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateTooLong) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *UpdateState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateMessageID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateMessageID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateMessageID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.RandomID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.RandomID))
		i--
		dAtA[i] = 0x10
	}
	if m.MessageID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.MessageID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateNewMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateNewMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateNewMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.SenderRefID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.SenderRefID))
		i--
		dAtA[i] = 0x20
	}
	if m.AccessHash != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
		i--
		dAtA[i] = 0x19
	}
	if m.Sender != nil {
		{
			size, err := m.Sender.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateMessageEdited) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateMessageEdited) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateMessageEdited) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateMessagesDeleted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateMessagesDeleted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateMessagesDeleted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TeamID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb0
	}
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Peer != nil {
		{
			size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.MessageIDs) > 0 {
		dAtA6 := make([]byte, len(m.MessageIDs)*10)
		var j5 int
		for _, num1 := range m.MessageIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintUpdates(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateReadHistoryInbox) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateReadHistoryInbox) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateReadHistoryInbox) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TeamID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb0
	}
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.MaxID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.MaxID))
		i--
		dAtA[i] = 0x10
	}
	if m.Peer != nil {
		{
			size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateReadHistoryOutbox) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateReadHistoryOutbox) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateReadHistoryOutbox) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TeamID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb0
	}
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.UserID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.MaxID))
		i--
		dAtA[i] = 0x10
	}
	if m.Peer != nil {
		{
			size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateMessagePinned) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateMessagePinned) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateMessagePinned) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TeamID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb0
	}
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Version != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x28
	}
	if m.MsgID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.MsgID))
		i--
		dAtA[i] = 0x18
	}
	if m.UserID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	if m.Peer != nil {
		{
			size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateUserTyping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUserTyping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateUserTyping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TeamID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb0
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.PeerType != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.PeerType))
		i--
		dAtA[i] = 0x20
	}
	if m.PeerID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.PeerID))
		i--
		dAtA[i] = 0x18
	}
	if m.Action != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x10
	}
	if m.UserID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateUserStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUserStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateUserStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Status != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.UserID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateUsername) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUsername) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateUsername) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Phone) > 0 {
		i -= len(m.Phone)
		copy(dAtA[i:], m.Phone)
		i = encodeVarintUpdates(dAtA, i, uint64(len(m.Phone)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Bio) > 0 {
		i -= len(m.Bio)
		copy(dAtA[i:], m.Bio)
		i = encodeVarintUpdates(dAtA, i, uint64(len(m.Bio)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.LastName) > 0 {
		i -= len(m.LastName)
		copy(dAtA[i:], m.LastName)
		i = encodeVarintUpdates(dAtA, i, uint64(len(m.LastName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FirstName) > 0 {
		i -= len(m.FirstName)
		copy(dAtA[i:], m.FirstName)
		i = encodeVarintUpdates(dAtA, i, uint64(len(m.FirstName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintUpdates(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x12
	}
	if m.UserID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateUserPhoto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUserPhoto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateUserPhoto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.DeletedPhotoIDs) > 0 {
		dAtA11 := make([]byte, len(m.DeletedPhotoIDs)*10)
		var j10 int
		for _, num1 := range m.DeletedPhotoIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintUpdates(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0x22
	}
	if m.PhotoID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.PhotoID))
		i--
		dAtA[i] = 0x18
	}
	if m.Photo != nil {
		{
			size, err := m.Photo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.UserID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateNotifySettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateNotifySettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateNotifySettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TeamID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb0
	}
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Settings != nil {
		{
			size, err := m.Settings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.NotifyPeer != nil {
		{
			size, err := m.NotifyPeer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.UserID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGroupParticipantAdd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroupParticipantAdd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGroupParticipantAdd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Date != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x20
	}
	if m.InviterID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.InviterID))
		i--
		dAtA[i] = 0x18
	}
	if m.UserID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGroupParticipantDeleted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroupParticipantDeleted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGroupParticipantDeleted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.UserID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGroupParticipantAdmin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroupParticipantAdmin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGroupParticipantAdmin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.IsAdmin {
		i--
		if m.IsAdmin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.UserID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGroupAdmins) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroupAdmins) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGroupAdmins) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.AdminEnabled {
		i--
		if m.AdminEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.GroupID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGroupPhoto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroupPhoto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGroupPhoto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.PhotoID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.PhotoID))
		i--
		dAtA[i] = 0x18
	}
	if m.Photo != nil {
		{
			size, err := m.Photo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.GroupID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateReadMessagesContents) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateReadMessagesContents) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateReadMessagesContents) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TeamID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb0
	}
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Peer != nil {
		{
			size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.MessageIDs) > 0 {
		dAtA18 := make([]byte, len(m.MessageIDs)*10)
		var j17 int
		for _, num1 := range m.MessageIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		i -= j17
		copy(dAtA[i:], dAtA18[:j17])
		i = encodeVarintUpdates(dAtA, i, uint64(j17))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateAuthorizationReset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateAuthorizationReset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateAuthorizationReset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	return len(dAtA) - i, nil
}

func (m *UpdateDraftMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateDraftMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateDraftMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateDraftMessageCleared) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateDraftMessageCleared) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateDraftMessageCleared) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TeamID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb0
	}
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Peer != nil {
		{
			size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateDialogPinned) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateDialogPinned) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateDialogPinned) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TeamID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb0
	}
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Pinned {
		i--
		if m.Pinned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Peer != nil {
		{
			size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateDialogPinnedReorder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateDialogPinnedReorder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateDialogPinnedReorder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Peer) > 0 {
		for iNdEx := len(m.Peer) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Peer[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpdates(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UpdateAccountPrivacy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateAccountPrivacy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateAccountPrivacy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Call) > 0 {
		for iNdEx := len(m.Call) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Call[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpdates(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ForwardedMessage) > 0 {
		for iNdEx := len(m.ForwardedMessage) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForwardedMessage[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpdates(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ProfilePhoto) > 0 {
		for iNdEx := len(m.ProfilePhoto) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProfilePhoto[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpdates(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PhoneNumber) > 0 {
		for iNdEx := len(m.PhoneNumber) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PhoneNumber[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpdates(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.LastSeen) > 0 {
		for iNdEx := len(m.LastSeen) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LastSeen[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpdates(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ChatInvite) > 0 {
		for iNdEx := len(m.ChatInvite) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ChatInvite[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpdates(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UpdateLabelItemsAdded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateLabelItemsAdded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateLabelItemsAdded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TeamID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb0
	}
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Labels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpdates(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.LabelIDs) > 0 {
		dAtA23 := make([]byte, len(m.LabelIDs)*10)
		var j22 int
		for _, num1 := range m.LabelIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j22++
			}
			dAtA23[j22] = uint8(num)
			j22++
		}
		i -= j22
		copy(dAtA[i:], dAtA23[:j22])
		i = encodeVarintUpdates(dAtA, i, uint64(j22))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MessageIDs) > 0 {
		dAtA25 := make([]byte, len(m.MessageIDs)*10)
		var j24 int
		for _, num1 := range m.MessageIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		i -= j24
		copy(dAtA[i:], dAtA25[:j24])
		i = encodeVarintUpdates(dAtA, i, uint64(j24))
		i--
		dAtA[i] = 0x1a
	}
	if m.Peer != nil {
		{
			size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateLabelItemsRemoved) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateLabelItemsRemoved) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateLabelItemsRemoved) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TeamID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb0
	}
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Labels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpdates(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.LabelIDs) > 0 {
		dAtA28 := make([]byte, len(m.LabelIDs)*10)
		var j27 int
		for _, num1 := range m.LabelIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA28[j27] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j27++
			}
			dAtA28[j27] = uint8(num)
			j27++
		}
		i -= j27
		copy(dAtA[i:], dAtA28[:j27])
		i = encodeVarintUpdates(dAtA, i, uint64(j27))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MessageIDs) > 0 {
		dAtA30 := make([]byte, len(m.MessageIDs)*10)
		var j29 int
		for _, num1 := range m.MessageIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA30[j29] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j29++
			}
			dAtA30[j29] = uint8(num)
			j29++
		}
		i -= j29
		copy(dAtA[i:], dAtA30[:j29])
		i = encodeVarintUpdates(dAtA, i, uint64(j29))
		i--
		dAtA[i] = 0x1a
	}
	if m.Peer != nil {
		{
			size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateLabelSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateLabelSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateLabelSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Labels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpdates(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UpdateLabelDeleted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateLabelDeleted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateLabelDeleted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.LabelIDs) > 0 {
		dAtA33 := make([]byte, len(m.LabelIDs)*10)
		var j32 int
		for _, num1 := range m.LabelIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA33[j32] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j32++
			}
			dAtA33[j32] = uint8(num)
			j32++
		}
		i -= j32
		copy(dAtA[i:], dAtA33[:j32])
		i = encodeVarintUpdates(dAtA, i, uint64(j32))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateUserBlocked) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUserBlocked) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateUserBlocked) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Blocked {
		i--
		if m.Blocked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.UserID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateMessagePoll) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateMessagePoll) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateMessagePoll) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Results != nil {
		{
			size, err := m.Results.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Poll != nil {
		{
			size, err := m.Poll.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PollID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.PollID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateBotCallbackQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateBotCallbackQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateBotCallbackQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintUpdates(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x2a
	}
	if m.MessageID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.MessageID))
		i--
		dAtA[i] = 0x20
	}
	if m.Peer != nil {
		{
			size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.UserID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	if m.QueryID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.QueryID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateBotInlineQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateBotInlineQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateBotInlineQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Geo != nil {
		{
			size, err := m.Geo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Offset) > 0 {
		i -= len(m.Offset)
		copy(dAtA[i:], m.Offset)
		i = encodeVarintUpdates(dAtA, i, uint64(len(m.Offset)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintUpdates(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x22
	}
	if m.Peer != nil {
		{
			size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.UserID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	if m.QueryID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.QueryID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateBotInlineSend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateBotInlineSend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateBotInlineSend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Geo != nil {
		{
			size, err := m.Geo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ResultID) > 0 {
		i -= len(m.ResultID)
		copy(dAtA[i:], m.ResultID)
		i = encodeVarintUpdates(dAtA, i, uint64(len(m.ResultID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintUpdates(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x1a
	}
	if m.UserID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *UpdateTeamCreated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTeamCreated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateTeamCreated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Team != nil {
		{
			size, err := m.Team.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateTeamMemberAdded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTeamMemberAdded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateTeamMemberAdded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Hash != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.Hash))
		i--
		dAtA[i] = 0x2d
	}
	if m.AdderID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.AdderID))
		i--
		dAtA[i] = 0x20
	}
	if m.Contact != nil {
		{
			size, err := m.Contact.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.User != nil {
		{
			size, err := m.User.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TeamID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateTeamMemberRemoved) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTeamMemberRemoved) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateTeamMemberRemoved) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Hash != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.Hash))
		i--
		dAtA[i] = 0x25
	}
	if m.RemoverID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.RemoverID))
		i--
		dAtA[i] = 0x18
	}
	if m.UserID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	if m.TeamID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateTeamMemberStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTeamMemberStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateTeamMemberStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Admin {
		i--
		if m.Admin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.ChangerID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.ChangerID))
		i--
		dAtA[i] = 0x18
	}
	if m.TeamID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateTeamPhoto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTeamPhoto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateTeamPhoto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Photo != nil {
		{
			size, err := m.Photo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TeamID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateTeam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTeam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateTeam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintUpdates(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.TeamID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateCommunityMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateCommunityMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateCommunityMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TeamID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.SenderMsgID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.SenderMsgID))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Entities) > 0 {
		for iNdEx := len(m.Entities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpdates(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.GlobalMsgID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.GlobalMsgID))
		i--
		dAtA[i] = 0x28
	}
	if m.CreatedOn != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.CreatedOn))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintUpdates(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ReceiverID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.ReceiverID))
		i--
		dAtA[i] = 0x10
	}
	if m.SenderID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.SenderID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateCommunityReadOutbox) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateCommunityReadOutbox) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateCommunityReadOutbox) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TeamID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.SenderMsgID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.SenderMsgID))
		i--
		dAtA[i] = 0x18
	}
	if m.ReceiverID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.ReceiverID))
		i--
		dAtA[i] = 0x10
	}
	if m.SenderID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.SenderID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateCommunityTyping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateCommunityTyping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateCommunityTyping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TeamID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Action != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x18
	}
	if m.ReceiverID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.ReceiverID))
		i--
		dAtA[i] = 0x10
	}
	if m.SenderID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.SenderID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateReaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateReaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateReaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Reaction) > 0 {
		i -= len(m.Reaction)
		copy(dAtA[i:], m.Reaction)
		i = encodeVarintUpdates(dAtA, i, uint64(len(m.Reaction)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.YourReactions) > 0 {
		for iNdEx := len(m.YourReactions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.YourReactions[iNdEx])
			copy(dAtA[i:], m.YourReactions[iNdEx])
			i = encodeVarintUpdates(dAtA, i, uint64(len(m.YourReactions[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Sender != nil {
		{
			size, err := m.Sender.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Peer != nil {
		{
			size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.TeamID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Counter) > 0 {
		for iNdEx := len(m.Counter) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Counter[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpdates(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.MessageID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.MessageID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateCalendarEventAdded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateCalendarEventAdded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateCalendarEventAdded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Event != nil {
		{
			size, err := m.Event.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateCalendarEventRemoved) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateCalendarEventRemoved) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateCalendarEventRemoved) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EventID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.EventID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb0
	}
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	return len(dAtA) - i, nil
}

func (m *UpdateCalendarEventEdited) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateCalendarEventEdited) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateCalendarEventEdited) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Event != nil {
		{
			size, err := m.Event.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateRedirect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateRedirect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateRedirect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UpdateID))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Empty {
		i--
		if m.Empty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Redirects) > 0 {
		for iNdEx := len(m.Redirects) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Redirects[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpdates(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ClientRedirect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientRedirect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientRedirect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Alternatives) > 0 {
		for iNdEx := len(m.Alternatives) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Alternatives[iNdEx])
			copy(dAtA[i:], m.Alternatives[iNdEx])
			i = encodeVarintUpdates(dAtA, i, uint64(len(m.Alternatives[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Target != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.Target))
		i--
		dAtA[i] = 0x18
	}
	if m.Permanent {
		i--
		if m.Permanent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.HostPort) > 0 {
		i -= len(m.HostPort)
		copy(dAtA[i:], m.HostPort)
		i = encodeVarintUpdates(dAtA, i, uint64(len(m.HostPort)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdatePhoneCall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdatePhoneCall) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdatePhoneCall) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UCount != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UCount))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.ActionData) > 0 {
		i -= len(m.ActionData)
		copy(dAtA[i:], m.ActionData)
		i = encodeVarintUpdates(dAtA, i, uint64(len(m.ActionData)))
		i--
		dAtA[i] = 0x42
	}
	if m.Action != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x38
	}
	if m.AccessHash != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
		i--
		dAtA[i] = 0x31
	}
	if m.UserID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x28
	}
	if m.CallID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.CallID))
		i--
		dAtA[i] = 0x20
	}
	if m.PeerType != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.PeerType))
		i--
		dAtA[i] = 0x18
	}
	if m.PeerID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.PeerID))
		i--
		dAtA[i] = 0x10
	}
	if m.TeamID != 0 {
		i = encodeVarintUpdates(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintUpdates(dAtA []byte, offset int, v uint64) int {
	offset -= sovUpdates(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UpdateGetState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *UpdateGetDifference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.From != 0 {
		n += 1 + sovUpdates(uint64(m.From))
	}
	if m.Limit != 0 {
		n += 1 + sovUpdates(uint64(m.Limit))
	}
	return n
}

func (m *UpdateDifference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.More {
		n += 2
	}
	if m.MaxUpdateID != 0 {
		n += 1 + sovUpdates(uint64(m.MaxUpdateID))
	}
	if m.MinUpdateID != 0 {
		n += 1 + sovUpdates(uint64(m.MinUpdateID))
	}
	if len(m.Updates) > 0 {
		for _, e := range m.Updates {
			l = e.Size()
			n += 1 + l + sovUpdates(uint64(l))
		}
	}
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovUpdates(uint64(l))
		}
	}
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovUpdates(uint64(l))
		}
	}
	if m.CurrentUpdateID != 0 {
		n += 1 + sovUpdates(uint64(m.CurrentUpdateID))
	}
	return n
}

func (m *UpdateTooLong) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *UpdateState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateID != 0 {
		n += 1 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateMessageID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MessageID != 0 {
		n += 1 + sovUpdates(uint64(m.MessageID))
	}
	if m.RandomID != 0 {
		n += 1 + sovUpdates(uint64(m.RandomID))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	return n
}

func (m *UpdateNewMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.AccessHash != 0 {
		n += 9
	}
	if m.SenderRefID != 0 {
		n += 1 + sovUpdates(uint64(m.SenderRefID))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateMessageEdited) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateMessagesDeleted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MessageIDs) > 0 {
		l = 0
		for _, e := range m.MessageIDs {
			l += sovUpdates(uint64(e))
		}
		n += 1 + sovUpdates(uint64(l)) + l
	}
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	if m.TeamID != 0 {
		n += 2 + sovUpdates(uint64(m.TeamID))
	}
	return n
}

func (m *UpdateReadHistoryInbox) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.MaxID != 0 {
		n += 1 + sovUpdates(uint64(m.MaxID))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	if m.TeamID != 0 {
		n += 2 + sovUpdates(uint64(m.TeamID))
	}
	return n
}

func (m *UpdateReadHistoryOutbox) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.MaxID != 0 {
		n += 1 + sovUpdates(uint64(m.MaxID))
	}
	if m.UserID != 0 {
		n += 1 + sovUpdates(uint64(m.UserID))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	if m.TeamID != 0 {
		n += 2 + sovUpdates(uint64(m.TeamID))
	}
	return n
}

func (m *UpdateMessagePinned) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.UserID != 0 {
		n += 1 + sovUpdates(uint64(m.UserID))
	}
	if m.MsgID != 0 {
		n += 1 + sovUpdates(uint64(m.MsgID))
	}
	if m.Version != 0 {
		n += 1 + sovUpdates(uint64(m.Version))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	if m.TeamID != 0 {
		n += 2 + sovUpdates(uint64(m.TeamID))
	}
	return n
}

func (m *UpdateUserTyping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovUpdates(uint64(m.UserID))
	}
	if m.Action != 0 {
		n += 1 + sovUpdates(uint64(m.Action))
	}
	if m.PeerID != 0 {
		n += 1 + sovUpdates(uint64(m.PeerID))
	}
	if m.PeerType != 0 {
		n += 1 + sovUpdates(uint64(m.PeerType))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.TeamID != 0 {
		n += 2 + sovUpdates(uint64(m.TeamID))
	}
	return n
}

func (m *UpdateUserStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovUpdates(uint64(m.UserID))
	}
	if m.Status != 0 {
		n += 1 + sovUpdates(uint64(m.Status))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	return n
}

func (m *UpdateUsername) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovUpdates(uint64(m.UserID))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovUpdates(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovUpdates(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovUpdates(uint64(l))
	}
	l = len(m.Bio)
	if l > 0 {
		n += 1 + l + sovUpdates(uint64(l))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateUserPhoto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovUpdates(uint64(m.UserID))
	}
	if m.Photo != nil {
		l = m.Photo.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.PhotoID != 0 {
		n += 1 + sovUpdates(uint64(m.PhotoID))
	}
	if len(m.DeletedPhotoIDs) > 0 {
		l = 0
		for _, e := range m.DeletedPhotoIDs {
			l += sovUpdates(uint64(e))
		}
		n += 1 + sovUpdates(uint64(l)) + l
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateNotifySettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovUpdates(uint64(m.UserID))
	}
	if m.NotifyPeer != nil {
		l = m.NotifyPeer.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.Settings != nil {
		l = m.Settings.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	if m.TeamID != 0 {
		n += 2 + sovUpdates(uint64(m.TeamID))
	}
	return n
}

func (m *UpdateGroupParticipantAdd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupID != 0 {
		n += 1 + sovUpdates(uint64(m.GroupID))
	}
	if m.UserID != 0 {
		n += 1 + sovUpdates(uint64(m.UserID))
	}
	if m.InviterID != 0 {
		n += 1 + sovUpdates(uint64(m.InviterID))
	}
	if m.Date != 0 {
		n += 1 + sovUpdates(uint64(m.Date))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateGroupParticipantDeleted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupID != 0 {
		n += 1 + sovUpdates(uint64(m.GroupID))
	}
	if m.UserID != 0 {
		n += 1 + sovUpdates(uint64(m.UserID))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateGroupParticipantAdmin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupID != 0 {
		n += 1 + sovUpdates(uint64(m.GroupID))
	}
	if m.UserID != 0 {
		n += 1 + sovUpdates(uint64(m.UserID))
	}
	if m.IsAdmin {
		n += 2
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateGroupAdmins) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupID != 0 {
		n += 1 + sovUpdates(uint64(m.GroupID))
	}
	if m.AdminEnabled {
		n += 2
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateGroupPhoto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupID != 0 {
		n += 1 + sovUpdates(uint64(m.GroupID))
	}
	if m.Photo != nil {
		l = m.Photo.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.PhotoID != 0 {
		n += 1 + sovUpdates(uint64(m.PhotoID))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateReadMessagesContents) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MessageIDs) > 0 {
		l = 0
		for _, e := range m.MessageIDs {
			l += sovUpdates(uint64(e))
		}
		n += 1 + sovUpdates(uint64(l)) + l
	}
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	if m.TeamID != 0 {
		n += 2 + sovUpdates(uint64(m.TeamID))
	}
	return n
}

func (m *UpdateAuthorizationReset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateDraftMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateDraftMessageCleared) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	if m.TeamID != 0 {
		n += 2 + sovUpdates(uint64(m.TeamID))
	}
	return n
}

func (m *UpdateDialogPinned) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.Pinned {
		n += 2
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	if m.TeamID != 0 {
		n += 2 + sovUpdates(uint64(m.TeamID))
	}
	return n
}

func (m *UpdateDialogPinnedReorder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Peer) > 0 {
		for _, e := range m.Peer {
			l = e.Size()
			n += 1 + l + sovUpdates(uint64(l))
		}
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateAccountPrivacy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ChatInvite) > 0 {
		for _, e := range m.ChatInvite {
			l = e.Size()
			n += 1 + l + sovUpdates(uint64(l))
		}
	}
	if len(m.LastSeen) > 0 {
		for _, e := range m.LastSeen {
			l = e.Size()
			n += 1 + l + sovUpdates(uint64(l))
		}
	}
	if len(m.PhoneNumber) > 0 {
		for _, e := range m.PhoneNumber {
			l = e.Size()
			n += 1 + l + sovUpdates(uint64(l))
		}
	}
	if len(m.ProfilePhoto) > 0 {
		for _, e := range m.ProfilePhoto {
			l = e.Size()
			n += 1 + l + sovUpdates(uint64(l))
		}
	}
	if len(m.ForwardedMessage) > 0 {
		for _, e := range m.ForwardedMessage {
			l = e.Size()
			n += 1 + l + sovUpdates(uint64(l))
		}
	}
	if len(m.Call) > 0 {
		for _, e := range m.Call {
			l = e.Size()
			n += 1 + l + sovUpdates(uint64(l))
		}
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateLabelItemsAdded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if len(m.MessageIDs) > 0 {
		l = 0
		for _, e := range m.MessageIDs {
			l += sovUpdates(uint64(e))
		}
		n += 1 + sovUpdates(uint64(l)) + l
	}
	if len(m.LabelIDs) > 0 {
		l = 0
		for _, e := range m.LabelIDs {
			l += sovUpdates(uint64(e))
		}
		n += 1 + sovUpdates(uint64(l)) + l
	}
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovUpdates(uint64(l))
		}
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	if m.TeamID != 0 {
		n += 2 + sovUpdates(uint64(m.TeamID))
	}
	return n
}

func (m *UpdateLabelItemsRemoved) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if len(m.MessageIDs) > 0 {
		l = 0
		for _, e := range m.MessageIDs {
			l += sovUpdates(uint64(e))
		}
		n += 1 + sovUpdates(uint64(l)) + l
	}
	if len(m.LabelIDs) > 0 {
		l = 0
		for _, e := range m.LabelIDs {
			l += sovUpdates(uint64(e))
		}
		n += 1 + sovUpdates(uint64(l)) + l
	}
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovUpdates(uint64(l))
		}
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	if m.TeamID != 0 {
		n += 2 + sovUpdates(uint64(m.TeamID))
	}
	return n
}

func (m *UpdateLabelSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovUpdates(uint64(l))
		}
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateLabelDeleted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LabelIDs) > 0 {
		l = 0
		for _, e := range m.LabelIDs {
			l += sovUpdates(uint64(e))
		}
		n += 1 + sovUpdates(uint64(l)) + l
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateUserBlocked) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovUpdates(uint64(m.UserID))
	}
	if m.Blocked {
		n += 2
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateMessagePoll) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PollID != 0 {
		n += 1 + sovUpdates(uint64(m.PollID))
	}
	if m.Poll != nil {
		l = m.Poll.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.Results != nil {
		l = m.Results.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateBotCallbackQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryID != 0 {
		n += 1 + sovUpdates(uint64(m.QueryID))
	}
	if m.UserID != 0 {
		n += 1 + sovUpdates(uint64(m.UserID))
	}
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.MessageID != 0 {
		n += 1 + sovUpdates(uint64(m.MessageID))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateBotInlineQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryID != 0 {
		n += 1 + sovUpdates(uint64(m.QueryID))
	}
	if m.UserID != 0 {
		n += 1 + sovUpdates(uint64(m.UserID))
	}
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovUpdates(uint64(l))
	}
	l = len(m.Offset)
	if l > 0 {
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.Geo != nil {
		l = m.Geo.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateBotInlineSend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovUpdates(uint64(m.UserID))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovUpdates(uint64(l))
	}
	l = len(m.ResultID)
	if l > 0 {
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.Geo != nil {
		l = m.Geo.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateTeamCreated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Team != nil {
		l = m.Team.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateTeamMemberAdded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TeamID != 0 {
		n += 1 + sovUpdates(uint64(m.TeamID))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.Contact != nil {
		l = m.Contact.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.AdderID != 0 {
		n += 1 + sovUpdates(uint64(m.AdderID))
	}
	if m.Hash != 0 {
		n += 5
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateTeamMemberRemoved) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TeamID != 0 {
		n += 1 + sovUpdates(uint64(m.TeamID))
	}
	if m.UserID != 0 {
		n += 1 + sovUpdates(uint64(m.UserID))
	}
	if m.RemoverID != 0 {
		n += 1 + sovUpdates(uint64(m.RemoverID))
	}
	if m.Hash != 0 {
		n += 5
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateTeamMemberStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TeamID != 0 {
		n += 1 + sovUpdates(uint64(m.TeamID))
	}
	if m.ChangerID != 0 {
		n += 1 + sovUpdates(uint64(m.ChangerID))
	}
	if m.Admin {
		n += 2
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateTeamPhoto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TeamID != 0 {
		n += 1 + sovUpdates(uint64(m.TeamID))
	}
	if m.Photo != nil {
		l = m.Photo.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateTeam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TeamID != 0 {
		n += 1 + sovUpdates(uint64(m.TeamID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateCommunityMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SenderID != 0 {
		n += 1 + sovUpdates(uint64(m.SenderID))
	}
	if m.ReceiverID != 0 {
		n += 1 + sovUpdates(uint64(m.ReceiverID))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.CreatedOn != 0 {
		n += 1 + sovUpdates(uint64(m.CreatedOn))
	}
	if m.GlobalMsgID != 0 {
		n += 1 + sovUpdates(uint64(m.GlobalMsgID))
	}
	if len(m.Entities) > 0 {
		for _, e := range m.Entities {
			l = e.Size()
			n += 1 + l + sovUpdates(uint64(l))
		}
	}
	if m.SenderMsgID != 0 {
		n += 1 + sovUpdates(uint64(m.SenderMsgID))
	}
	if m.TeamID != 0 {
		n += 2 + sovUpdates(uint64(m.TeamID))
	}
	return n
}

func (m *UpdateCommunityReadOutbox) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SenderID != 0 {
		n += 1 + sovUpdates(uint64(m.SenderID))
	}
	if m.ReceiverID != 0 {
		n += 1 + sovUpdates(uint64(m.ReceiverID))
	}
	if m.SenderMsgID != 0 {
		n += 1 + sovUpdates(uint64(m.SenderMsgID))
	}
	if m.TeamID != 0 {
		n += 2 + sovUpdates(uint64(m.TeamID))
	}
	return n
}

func (m *UpdateCommunityTyping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SenderID != 0 {
		n += 1 + sovUpdates(uint64(m.SenderID))
	}
	if m.ReceiverID != 0 {
		n += 1 + sovUpdates(uint64(m.ReceiverID))
	}
	if m.Action != 0 {
		n += 1 + sovUpdates(uint64(m.Action))
	}
	if m.TeamID != 0 {
		n += 2 + sovUpdates(uint64(m.TeamID))
	}
	return n
}

func (m *UpdateReaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MessageID != 0 {
		n += 1 + sovUpdates(uint64(m.MessageID))
	}
	if len(m.Counter) > 0 {
		for _, e := range m.Counter {
			l = e.Size()
			n += 1 + l + sovUpdates(uint64(l))
		}
	}
	if m.TeamID != 0 {
		n += 1 + sovUpdates(uint64(m.TeamID))
	}
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if len(m.YourReactions) > 0 {
		for _, s := range m.YourReactions {
			l = len(s)
			n += 1 + l + sovUpdates(uint64(l))
		}
	}
	l = len(m.Reaction)
	if l > 0 {
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateCalendarEventAdded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Event != nil {
		l = m.Event.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateCalendarEventRemoved) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	if m.EventID != 0 {
		n += 2 + sovUpdates(uint64(m.EventID))
	}
	return n
}

func (m *UpdateCalendarEventEdited) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Event != nil {
		l = m.Event.Size()
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *UpdateRedirect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Redirects) > 0 {
		for _, e := range m.Redirects {
			l = e.Size()
			n += 1 + l + sovUpdates(uint64(l))
		}
	}
	if m.Empty {
		n += 2
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	if m.UpdateID != 0 {
		n += 2 + sovUpdates(uint64(m.UpdateID))
	}
	return n
}

func (m *ClientRedirect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostPort)
	if l > 0 {
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.Permanent {
		n += 2
	}
	if m.Target != 0 {
		n += 1 + sovUpdates(uint64(m.Target))
	}
	if len(m.Alternatives) > 0 {
		for _, s := range m.Alternatives {
			l = len(s)
			n += 1 + l + sovUpdates(uint64(l))
		}
	}
	return n
}

func (m *UpdatePhoneCall) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TeamID != 0 {
		n += 1 + sovUpdates(uint64(m.TeamID))
	}
	if m.PeerID != 0 {
		n += 1 + sovUpdates(uint64(m.PeerID))
	}
	if m.PeerType != 0 {
		n += 1 + sovUpdates(uint64(m.PeerType))
	}
	if m.CallID != 0 {
		n += 1 + sovUpdates(uint64(m.CallID))
	}
	if m.UserID != 0 {
		n += 1 + sovUpdates(uint64(m.UserID))
	}
	if m.AccessHash != 0 {
		n += 9
	}
	if m.Action != 0 {
		n += 1 + sovUpdates(uint64(m.Action))
	}
	l = len(m.ActionData)
	if l > 0 {
		n += 1 + l + sovUpdates(uint64(l))
	}
	if m.UCount != 0 {
		n += 2 + sovUpdates(uint64(m.UCount))
	}
	return n
}

func sovUpdates(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozUpdates(x uint64) (n int) {
	return sovUpdates(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UpdateGetState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGetState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGetState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGetDifference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGetDifference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGetDifference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateDifference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateDifference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateDifference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field More", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.More = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUpdateID", wireType)
			}
			m.MaxUpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxUpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinUpdateID", wireType)
			}
			m.MinUpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinUpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Updates = append(m.Updates, &UpdateEnvelope{})
			if err := m.Updates[len(m.Updates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &User{})
			if err := m.Users[len(m.Users)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &Group{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentUpdateID", wireType)
			}
			m.CurrentUpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentUpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTooLong) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTooLong: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTooLong: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateMessageID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateMessageID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateMessageID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageID", wireType)
			}
			m.MessageID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomID", wireType)
			}
			m.RandomID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RandomID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateNewMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateNewMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateNewMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &UserMessage{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &User{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderRefID", wireType)
			}
			m.SenderRefID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SenderRefID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateMessageEdited) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateMessageEdited: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateMessageEdited: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &UserMessage{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateMessagesDeleted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateMessagesDeleted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateMessagesDeleted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowUpdates
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MessageIDs = append(m.MessageIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowUpdates
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthUpdates
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthUpdates
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.MessageIDs) == 0 {
					m.MessageIDs = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowUpdates
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MessageIDs = append(m.MessageIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageIDs", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateReadHistoryInbox) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateReadHistoryInbox: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateReadHistoryInbox: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxID", wireType)
			}
			m.MaxID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateReadHistoryOutbox) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateReadHistoryOutbox: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateReadHistoryOutbox: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxID", wireType)
			}
			m.MaxID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateMessagePinned) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateMessagePinned: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateMessagePinned: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgID", wireType)
			}
			m.MsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUserTyping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUserTyping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUserTyping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= TypingAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerID", wireType)
			}
			m.PeerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUserStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUserStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUserStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUsername) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUsername: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUsername: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUserPhoto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUserPhoto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUserPhoto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Photo == nil {
				m.Photo = &UserPhoto{}
			}
			if err := m.Photo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoID", wireType)
			}
			m.PhotoID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhotoID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowUpdates
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DeletedPhotoIDs = append(m.DeletedPhotoIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowUpdates
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthUpdates
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthUpdates
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DeletedPhotoIDs) == 0 {
					m.DeletedPhotoIDs = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowUpdates
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DeletedPhotoIDs = append(m.DeletedPhotoIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletedPhotoIDs", wireType)
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateNotifySettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateNotifySettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateNotifySettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifyPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NotifyPeer == nil {
				m.NotifyPeer = &Peer{}
			}
			if err := m.NotifyPeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Settings == nil {
				m.Settings = &PeerNotifySettings{}
			}
			if err := m.Settings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroupParticipantAdd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroupParticipantAdd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroupParticipantAdd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InviterID", wireType)
			}
			m.InviterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InviterID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroupParticipantDeleted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroupParticipantDeleted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroupParticipantDeleted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroupParticipantAdmin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroupParticipantAdmin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroupParticipantAdmin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAdmin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAdmin = bool(v != 0)
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroupAdmins) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroupAdmins: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroupAdmins: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdminEnabled = bool(v != 0)
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroupPhoto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroupPhoto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroupPhoto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Photo == nil {
				m.Photo = &GroupPhoto{}
			}
			if err := m.Photo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoID", wireType)
			}
			m.PhotoID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhotoID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateReadMessagesContents) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateReadMessagesContents: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateReadMessagesContents: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowUpdates
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MessageIDs = append(m.MessageIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowUpdates
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthUpdates
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthUpdates
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.MessageIDs) == 0 {
					m.MessageIDs = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowUpdates
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MessageIDs = append(m.MessageIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageIDs", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateAuthorizationReset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateAuthorizationReset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateAuthorizationReset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateDraftMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateDraftMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateDraftMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &DraftMessage{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateDraftMessageCleared) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateDraftMessageCleared: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateDraftMessageCleared: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateDialogPinned) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateDialogPinned: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateDialogPinned: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pinned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pinned = bool(v != 0)
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateDialogPinnedReorder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateDialogPinnedReorder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateDialogPinnedReorder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peer = append(m.Peer, &Peer{})
			if err := m.Peer[len(m.Peer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateAccountPrivacy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateAccountPrivacy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateAccountPrivacy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatInvite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatInvite = append(m.ChatInvite, &PrivacyRule{})
			if err := m.ChatInvite[len(m.ChatInvite)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSeen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastSeen = append(m.LastSeen, &PrivacyRule{})
			if err := m.LastSeen[len(m.LastSeen)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = append(m.PhoneNumber, &PrivacyRule{})
			if err := m.PhoneNumber[len(m.PhoneNumber)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfilePhoto", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfilePhoto = append(m.ProfilePhoto, &PrivacyRule{})
			if err := m.ProfilePhoto[len(m.ProfilePhoto)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwardedMessage = append(m.ForwardedMessage, &PrivacyRule{})
			if err := m.ForwardedMessage[len(m.ForwardedMessage)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Call", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Call = append(m.Call, &PrivacyRule{})
			if err := m.Call[len(m.Call)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateLabelItemsAdded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateLabelItemsAdded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateLabelItemsAdded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowUpdates
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MessageIDs = append(m.MessageIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowUpdates
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthUpdates
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthUpdates
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.MessageIDs) == 0 {
					m.MessageIDs = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowUpdates
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MessageIDs = append(m.MessageIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageIDs", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowUpdates
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LabelIDs = append(m.LabelIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowUpdates
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthUpdates
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthUpdates
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LabelIDs) == 0 {
					m.LabelIDs = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowUpdates
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LabelIDs = append(m.LabelIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelIDs", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, &Label{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateLabelItemsRemoved) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateLabelItemsRemoved: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateLabelItemsRemoved: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowUpdates
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MessageIDs = append(m.MessageIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowUpdates
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthUpdates
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthUpdates
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.MessageIDs) == 0 {
					m.MessageIDs = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowUpdates
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MessageIDs = append(m.MessageIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageIDs", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowUpdates
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LabelIDs = append(m.LabelIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowUpdates
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthUpdates
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthUpdates
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LabelIDs) == 0 {
					m.LabelIDs = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowUpdates
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LabelIDs = append(m.LabelIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelIDs", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, &Label{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateLabelSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateLabelSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateLabelSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, &Label{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateLabelDeleted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateLabelDeleted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateLabelDeleted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowUpdates
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LabelIDs = append(m.LabelIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowUpdates
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthUpdates
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthUpdates
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LabelIDs) == 0 {
					m.LabelIDs = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowUpdates
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LabelIDs = append(m.LabelIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelIDs", wireType)
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUserBlocked) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUserBlocked: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUserBlocked: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Blocked = bool(v != 0)
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateMessagePoll) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateMessagePoll: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateMessagePoll: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PollID", wireType)
			}
			m.PollID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PollID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poll", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Poll == nil {
				m.Poll = &MediaPoll{}
			}
			if err := m.Poll.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Results == nil {
				m.Results = &PollResults{}
			}
			if err := m.Results.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateBotCallbackQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateBotCallbackQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateBotCallbackQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryID", wireType)
			}
			m.QueryID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueryID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageID", wireType)
			}
			m.MessageID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateBotInlineQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateBotInlineQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateBotInlineQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryID", wireType)
			}
			m.QueryID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueryID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Offset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Geo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Geo == nil {
				m.Geo = &GeoLocation{}
			}
			if err := m.Geo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateBotInlineSend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateBotInlineSend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateBotInlineSend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResultID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Geo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Geo == nil {
				m.Geo = &GeoLocation{}
			}
			if err := m.Geo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTeamCreated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTeamCreated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTeamCreated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Team", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Team == nil {
				m.Team = &Team{}
			}
			if err := m.Team.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTeamMemberAdded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTeamMemberAdded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTeamMemberAdded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &User{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contact", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Contact == nil {
				m.Contact = &ContactUser{}
			}
			if err := m.Contact.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdderID", wireType)
			}
			m.AdderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdderID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			m.Hash = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTeamMemberRemoved) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTeamMemberRemoved: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTeamMemberRemoved: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoverID", wireType)
			}
			m.RemoverID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemoverID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			m.Hash = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTeamMemberStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTeamMemberStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTeamMemberStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangerID", wireType)
			}
			m.ChangerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangerID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Admin = bool(v != 0)
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTeamPhoto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTeamPhoto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTeamPhoto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Photo == nil {
				m.Photo = &TeamPhoto{}
			}
			if err := m.Photo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTeam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTeam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTeam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateCommunityMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateCommunityMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateCommunityMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderID", wireType)
			}
			m.SenderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SenderID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiverID", wireType)
			}
			m.ReceiverID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceiverID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedOn", wireType)
			}
			m.CreatedOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedOn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalMsgID", wireType)
			}
			m.GlobalMsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalMsgID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, &MessageEntity{})
			if err := m.Entities[len(m.Entities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderMsgID", wireType)
			}
			m.SenderMsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SenderMsgID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateCommunityReadOutbox) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateCommunityReadOutbox: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateCommunityReadOutbox: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderID", wireType)
			}
			m.SenderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SenderID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiverID", wireType)
			}
			m.ReceiverID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceiverID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderMsgID", wireType)
			}
			m.SenderMsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SenderMsgID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateCommunityTyping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateCommunityTyping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateCommunityTyping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderID", wireType)
			}
			m.SenderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SenderID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiverID", wireType)
			}
			m.ReceiverID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceiverID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= TypingAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateReaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateReaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateReaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageID", wireType)
			}
			m.MessageID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Counter = append(m.Counter, &ReactionCounter{})
			if err := m.Counter[len(m.Counter)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &User{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YourReactions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.YourReactions = append(m.YourReactions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reaction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reaction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateCalendarEventAdded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateCalendarEventAdded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateCalendarEventAdded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Event == nil {
				m.Event = &CalendarEvent{}
			}
			if err := m.Event.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateCalendarEventRemoved) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateCalendarEventRemoved: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateCalendarEventRemoved: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventID", wireType)
			}
			m.EventID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateCalendarEventEdited) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateCalendarEventEdited: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateCalendarEventEdited: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Event == nil {
				m.Event = &CalendarEvent{}
			}
			if err := m.Event.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateRedirect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateRedirect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateRedirect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redirects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Redirects = append(m.Redirects, &ClientRedirect{})
			if err := m.Redirects[len(m.Redirects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Empty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Empty = bool(v != 0)
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientRedirect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientRedirect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientRedirect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permanent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Permanent = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			m.Target = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Target |= RedirectTarget(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alternatives", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alternatives = append(m.Alternatives, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdatePhoneCall) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdatePhoneCall: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdatePhoneCall: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerID", wireType)
			}
			m.PeerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallID", wireType)
			}
			m.CallID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CallID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= PhoneCallAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthUpdates
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionData = append(m.ActionData[:0], dAtA[iNdEx:postIndex]...)
			if m.ActionData == nil {
				m.ActionData = []byte{}
			}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipUpdates(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowUpdates
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUpdates
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthUpdates
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupUpdates
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthUpdates
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthUpdates        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowUpdates          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupUpdates = fmt.Errorf("proto: unexpected end of group")
)

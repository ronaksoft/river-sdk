// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: chat.messages.medias.proto

package msg

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// DocumentAttributeType
type DocumentAttributeType int32

const (
	AttributeTypeNone     DocumentAttributeType = 0
	AttributeTypeAudio    DocumentAttributeType = 1
	AttributeTypeVideo    DocumentAttributeType = 2
	AttributeTypePhoto    DocumentAttributeType = 3
	AttributeTypeFile     DocumentAttributeType = 4
	AttributeTypeAnimated DocumentAttributeType = 5
	AttributeReserved1    DocumentAttributeType = 6
	AttributeReserved2    DocumentAttributeType = 7
	AttributeReserved3    DocumentAttributeType = 8
	AttributeReserved4    DocumentAttributeType = 9
)

var DocumentAttributeType_name = map[int32]string{
	0: "AttributeTypeNone",
	1: "AttributeTypeAudio",
	2: "AttributeTypeVideo",
	3: "AttributeTypePhoto",
	4: "AttributeTypeFile",
	5: "AttributeTypeAnimated",
	6: "AttributeReserved1",
	7: "AttributeReserved2",
	8: "AttributeReserved3",
	9: "AttributeReserved4",
}

var DocumentAttributeType_value = map[string]int32{
	"AttributeTypeNone":     0,
	"AttributeTypeAudio":    1,
	"AttributeTypeVideo":    2,
	"AttributeTypePhoto":    3,
	"AttributeTypeFile":     4,
	"AttributeTypeAnimated": 5,
	"AttributeReserved1":    6,
	"AttributeReserved2":    7,
	"AttributeReserved3":    8,
	"AttributeReserved4":    9,
}

func (x DocumentAttributeType) Enum() *DocumentAttributeType {
	p := new(DocumentAttributeType)
	*p = x
	return p
}

func (x DocumentAttributeType) String() string {
	return proto.EnumName(DocumentAttributeType_name, int32(x))
}

func (x *DocumentAttributeType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DocumentAttributeType_value, data, "DocumentAttributeType")
	if err != nil {
		return err
	}
	*x = DocumentAttributeType(value)
	return nil
}

func (DocumentAttributeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{0}
}

// Document Type
type DocumentType int32

const (
	DocumentTypeUnknown   DocumentType = 0
	DocumentTypePhoto     DocumentType = 1
	DocumentTypeVoice     DocumentType = 2
	DocumentTypeVideo     DocumentType = 3
	DocumentTypeWebPage   DocumentType = 4
	DocumentTypeReserved1 DocumentType = 5
	DocumentTypeReserved2 DocumentType = 6
	DocumentTypeReserved3 DocumentType = 7
	DocumentTypeReserved4 DocumentType = 8
)

var DocumentType_name = map[int32]string{
	0: "DocumentTypeUnknown",
	1: "DocumentTypePhoto",
	2: "DocumentTypeVoice",
	3: "DocumentTypeVideo",
	4: "DocumentTypeWebPage",
	5: "DocumentTypeReserved1",
	6: "DocumentTypeReserved2",
	7: "DocumentTypeReserved3",
	8: "DocumentTypeReserved4",
}

var DocumentType_value = map[string]int32{
	"DocumentTypeUnknown":   0,
	"DocumentTypePhoto":     1,
	"DocumentTypeVoice":     2,
	"DocumentTypeVideo":     3,
	"DocumentTypeWebPage":   4,
	"DocumentTypeReserved1": 5,
	"DocumentTypeReserved2": 6,
	"DocumentTypeReserved3": 7,
	"DocumentTypeReserved4": 8,
}

func (x DocumentType) Enum() *DocumentType {
	p := new(DocumentType)
	*p = x
	return p
}

func (x DocumentType) String() string {
	return proto.EnumName(DocumentType_name, int32(x))
}

func (x *DocumentType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DocumentType_value, data, "DocumentType")
	if err != nil {
		return err
	}
	*x = DocumentType(value)
	return nil
}

func (DocumentType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{1}
}

// DocumentAttributeAudio
type DocumentAttributeAudio struct {
	Voice     bool   `protobuf:"varint,1,req,name=Voice" json:"Voice"`
	Duration  uint32 `protobuf:"varint,2,req,name=Duration" json:"Duration"`
	Title     string `protobuf:"bytes,3,req,name=Title" json:"Title"`
	Performer string `protobuf:"bytes,4,req,name=Performer" json:"Performer"`
	Album     string `protobuf:"bytes,5,req,name=Album" json:"Album"`
	Waveform  []byte `protobuf:"bytes,6,opt,name=Waveform" json:"Waveform"`
}

func (m *DocumentAttributeAudio) Reset()         { *m = DocumentAttributeAudio{} }
func (m *DocumentAttributeAudio) String() string { return proto.CompactTextString(m) }
func (*DocumentAttributeAudio) ProtoMessage()    {}
func (*DocumentAttributeAudio) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{0}
}
func (m *DocumentAttributeAudio) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DocumentAttributeAudio) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DocumentAttributeAudio.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DocumentAttributeAudio) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DocumentAttributeAudio.Merge(m, src)
}
func (m *DocumentAttributeAudio) XXX_Size() int {
	return m.Size()
}
func (m *DocumentAttributeAudio) XXX_DiscardUnknown() {
	xxx_messageInfo_DocumentAttributeAudio.DiscardUnknown(m)
}

var xxx_messageInfo_DocumentAttributeAudio proto.InternalMessageInfo

func (m *DocumentAttributeAudio) GetVoice() bool {
	if m != nil {
		return m.Voice
	}
	return false
}

func (m *DocumentAttributeAudio) GetDuration() uint32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *DocumentAttributeAudio) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *DocumentAttributeAudio) GetPerformer() string {
	if m != nil {
		return m.Performer
	}
	return ""
}

func (m *DocumentAttributeAudio) GetAlbum() string {
	if m != nil {
		return m.Album
	}
	return ""
}

func (m *DocumentAttributeAudio) GetWaveform() []byte {
	if m != nil {
		return m.Waveform
	}
	return nil
}

// DocumentAttributeVideo
type DocumentAttributeVideo struct {
	Width    uint32 `protobuf:"varint,1,req,name=Width" json:"Width"`
	Height   uint32 `protobuf:"varint,2,req,name=Height" json:"Height"`
	Duration uint32 `protobuf:"varint,3,req,name=Duration" json:"Duration"`
	Round    bool   `protobuf:"varint,4,req,name=Round" json:"Round"`
}

func (m *DocumentAttributeVideo) Reset()         { *m = DocumentAttributeVideo{} }
func (m *DocumentAttributeVideo) String() string { return proto.CompactTextString(m) }
func (*DocumentAttributeVideo) ProtoMessage()    {}
func (*DocumentAttributeVideo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{1}
}
func (m *DocumentAttributeVideo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DocumentAttributeVideo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DocumentAttributeVideo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DocumentAttributeVideo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DocumentAttributeVideo.Merge(m, src)
}
func (m *DocumentAttributeVideo) XXX_Size() int {
	return m.Size()
}
func (m *DocumentAttributeVideo) XXX_DiscardUnknown() {
	xxx_messageInfo_DocumentAttributeVideo.DiscardUnknown(m)
}

var xxx_messageInfo_DocumentAttributeVideo proto.InternalMessageInfo

func (m *DocumentAttributeVideo) GetWidth() uint32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *DocumentAttributeVideo) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *DocumentAttributeVideo) GetDuration() uint32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *DocumentAttributeVideo) GetRound() bool {
	if m != nil {
		return m.Round
	}
	return false
}

// DocumentAttributePhoto
type DocumentAttributePhoto struct {
	Width  uint32 `protobuf:"varint,1,req,name=Width" json:"Width"`
	Height uint32 `protobuf:"varint,2,req,name=Height" json:"Height"`
}

func (m *DocumentAttributePhoto) Reset()         { *m = DocumentAttributePhoto{} }
func (m *DocumentAttributePhoto) String() string { return proto.CompactTextString(m) }
func (*DocumentAttributePhoto) ProtoMessage()    {}
func (*DocumentAttributePhoto) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{2}
}
func (m *DocumentAttributePhoto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DocumentAttributePhoto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DocumentAttributePhoto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DocumentAttributePhoto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DocumentAttributePhoto.Merge(m, src)
}
func (m *DocumentAttributePhoto) XXX_Size() int {
	return m.Size()
}
func (m *DocumentAttributePhoto) XXX_DiscardUnknown() {
	xxx_messageInfo_DocumentAttributePhoto.DiscardUnknown(m)
}

var xxx_messageInfo_DocumentAttributePhoto proto.InternalMessageInfo

func (m *DocumentAttributePhoto) GetWidth() uint32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *DocumentAttributePhoto) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

// DocumentAttributeFile
type DocumentAttributeFile struct {
	Filename string `protobuf:"bytes,1,req,name=Filename" json:"Filename"`
}

func (m *DocumentAttributeFile) Reset()         { *m = DocumentAttributeFile{} }
func (m *DocumentAttributeFile) String() string { return proto.CompactTextString(m) }
func (*DocumentAttributeFile) ProtoMessage()    {}
func (*DocumentAttributeFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{3}
}
func (m *DocumentAttributeFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DocumentAttributeFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DocumentAttributeFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DocumentAttributeFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DocumentAttributeFile.Merge(m, src)
}
func (m *DocumentAttributeFile) XXX_Size() int {
	return m.Size()
}
func (m *DocumentAttributeFile) XXX_DiscardUnknown() {
	xxx_messageInfo_DocumentAttributeFile.DiscardUnknown(m)
}

var xxx_messageInfo_DocumentAttributeFile proto.InternalMessageInfo

func (m *DocumentAttributeFile) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

// DocumentAttributeAnimated
type DocumentAttributeAnimated struct {
}

func (m *DocumentAttributeAnimated) Reset()         { *m = DocumentAttributeAnimated{} }
func (m *DocumentAttributeAnimated) String() string { return proto.CompactTextString(m) }
func (*DocumentAttributeAnimated) ProtoMessage()    {}
func (*DocumentAttributeAnimated) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{4}
}
func (m *DocumentAttributeAnimated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DocumentAttributeAnimated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DocumentAttributeAnimated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DocumentAttributeAnimated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DocumentAttributeAnimated.Merge(m, src)
}
func (m *DocumentAttributeAnimated) XXX_Size() int {
	return m.Size()
}
func (m *DocumentAttributeAnimated) XXX_DiscardUnknown() {
	xxx_messageInfo_DocumentAttributeAnimated.DiscardUnknown(m)
}

var xxx_messageInfo_DocumentAttributeAnimated proto.InternalMessageInfo

// DocumentAttribute
type DocumentAttribute struct {
	Type DocumentAttributeType `protobuf:"varint,1,req,name=Type,enum=msg.DocumentAttributeType" json:"Type"`
	Data []byte                `protobuf:"bytes,2,opt,name=Data" json:"Data"`
}

func (m *DocumentAttribute) Reset()         { *m = DocumentAttribute{} }
func (m *DocumentAttribute) String() string { return proto.CompactTextString(m) }
func (*DocumentAttribute) ProtoMessage()    {}
func (*DocumentAttribute) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{5}
}
func (m *DocumentAttribute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DocumentAttribute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DocumentAttribute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DocumentAttribute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DocumentAttribute.Merge(m, src)
}
func (m *DocumentAttribute) XXX_Size() int {
	return m.Size()
}
func (m *DocumentAttribute) XXX_DiscardUnknown() {
	xxx_messageInfo_DocumentAttribute.DiscardUnknown(m)
}

var xxx_messageInfo_DocumentAttribute proto.InternalMessageInfo

func (m *DocumentAttribute) GetType() DocumentAttributeType {
	if m != nil {
		return m.Type
	}
	return AttributeTypeNone
}

func (m *DocumentAttribute) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// Document
type Document struct {
	ID          int64                `protobuf:"varint,1,req,name=ID" json:"ID"`
	AccessHash  uint64               `protobuf:"fixed64,2,req,name=AccessHash" json:"AccessHash"`
	Date        int64                `protobuf:"varint,3,req,name=Date" json:"Date"`
	MimeType    string               `protobuf:"bytes,4,req,name=MimeType" json:"MimeType"`
	FileSize    int32                `protobuf:"varint,5,req,name=FileSize" json:"FileSize"`
	Version     int32                `protobuf:"varint,6,req,name=Version" json:"Version"`
	ClusterID   int32                `protobuf:"varint,7,req,name=ClusterID" json:"ClusterID"`
	Attributes  []*DocumentAttribute `protobuf:"bytes,8,rep,name=Attributes" json:"Attributes,omitempty"`
	Thumbnail   *FileLocation        `protobuf:"bytes,9,opt,name=Thumbnail" json:"Thumbnail,omitempty"`
	MD5Checksum string               `protobuf:"bytes,10,opt,name=MD5Checksum" json:"MD5Checksum"`
}

func (m *Document) Reset()         { *m = Document{} }
func (m *Document) String() string { return proto.CompactTextString(m) }
func (*Document) ProtoMessage()    {}
func (*Document) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{6}
}
func (m *Document) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Document) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Document.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Document) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Document.Merge(m, src)
}
func (m *Document) XXX_Size() int {
	return m.Size()
}
func (m *Document) XXX_DiscardUnknown() {
	xxx_messageInfo_Document.DiscardUnknown(m)
}

var xxx_messageInfo_Document proto.InternalMessageInfo

func (m *Document) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Document) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *Document) GetDate() int64 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *Document) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *Document) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *Document) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Document) GetClusterID() int32 {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

func (m *Document) GetAttributes() []*DocumentAttribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *Document) GetThumbnail() *FileLocation {
	if m != nil {
		return m.Thumbnail
	}
	return nil
}

func (m *Document) GetMD5Checksum() string {
	if m != nil {
		return m.MD5Checksum
	}
	return ""
}

// InputMediaInvoice
type InputMediaInvoice struct {
}

func (m *InputMediaInvoice) Reset()         { *m = InputMediaInvoice{} }
func (m *InputMediaInvoice) String() string { return proto.CompactTextString(m) }
func (*InputMediaInvoice) ProtoMessage()    {}
func (*InputMediaInvoice) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{7}
}
func (m *InputMediaInvoice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputMediaInvoice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputMediaInvoice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputMediaInvoice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputMediaInvoice.Merge(m, src)
}
func (m *InputMediaInvoice) XXX_Size() int {
	return m.Size()
}
func (m *InputMediaInvoice) XXX_DiscardUnknown() {
	xxx_messageInfo_InputMediaInvoice.DiscardUnknown(m)
}

var xxx_messageInfo_InputMediaInvoice proto.InternalMessageInfo

// MediaInvoice
type MediaInvoice struct {
}

func (m *MediaInvoice) Reset()         { *m = MediaInvoice{} }
func (m *MediaInvoice) String() string { return proto.CompactTextString(m) }
func (*MediaInvoice) ProtoMessage()    {}
func (*MediaInvoice) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{8}
}
func (m *MediaInvoice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MediaInvoice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MediaInvoice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MediaInvoice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MediaInvoice.Merge(m, src)
}
func (m *MediaInvoice) XXX_Size() int {
	return m.Size()
}
func (m *MediaInvoice) XXX_DiscardUnknown() {
	xxx_messageInfo_MediaInvoice.DiscardUnknown(m)
}

var xxx_messageInfo_MediaInvoice proto.InternalMessageInfo

// InputMediaWebDocument
type InputMediaWebDocument struct {
	Url        string               `protobuf:"bytes,1,req,name=Url" json:"Url"`
	DocSize    int32                `protobuf:"varint,2,req,name=DocSize" json:"DocSize"`
	MimeType   string               `protobuf:"bytes,3,req,name=MimeType" json:"MimeType"`
	Attributes []*DocumentAttribute `protobuf:"bytes,4,rep,name=Attributes" json:"Attributes,omitempty"`
}

func (m *InputMediaWebDocument) Reset()         { *m = InputMediaWebDocument{} }
func (m *InputMediaWebDocument) String() string { return proto.CompactTextString(m) }
func (*InputMediaWebDocument) ProtoMessage()    {}
func (*InputMediaWebDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{9}
}
func (m *InputMediaWebDocument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputMediaWebDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputMediaWebDocument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputMediaWebDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputMediaWebDocument.Merge(m, src)
}
func (m *InputMediaWebDocument) XXX_Size() int {
	return m.Size()
}
func (m *InputMediaWebDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_InputMediaWebDocument.DiscardUnknown(m)
}

var xxx_messageInfo_InputMediaWebDocument proto.InternalMessageInfo

func (m *InputMediaWebDocument) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *InputMediaWebDocument) GetDocSize() int32 {
	if m != nil {
		return m.DocSize
	}
	return 0
}

func (m *InputMediaWebDocument) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *InputMediaWebDocument) GetAttributes() []*DocumentAttribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

// MediaWebDocument
type MediaWebDocument struct {
	Url        string               `protobuf:"bytes,1,req,name=Url" json:"Url"`
	DocSize    int32                `protobuf:"varint,2,req,name=DocSize" json:"DocSize"`
	MimeType   string               `protobuf:"bytes,3,req,name=MimeType" json:"MimeType"`
	Attributes []*DocumentAttribute `protobuf:"bytes,4,rep,name=Attributes" json:"Attributes,omitempty"`
	AccessHash uint64               `protobuf:"fixed64,5,req,name=AccessHash" json:"AccessHash"`
}

func (m *MediaWebDocument) Reset()         { *m = MediaWebDocument{} }
func (m *MediaWebDocument) String() string { return proto.CompactTextString(m) }
func (*MediaWebDocument) ProtoMessage()    {}
func (*MediaWebDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{10}
}
func (m *MediaWebDocument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MediaWebDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MediaWebDocument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MediaWebDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MediaWebDocument.Merge(m, src)
}
func (m *MediaWebDocument) XXX_Size() int {
	return m.Size()
}
func (m *MediaWebDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_MediaWebDocument.DiscardUnknown(m)
}

var xxx_messageInfo_MediaWebDocument proto.InternalMessageInfo

func (m *MediaWebDocument) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *MediaWebDocument) GetDocSize() int32 {
	if m != nil {
		return m.DocSize
	}
	return 0
}

func (m *MediaWebDocument) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *MediaWebDocument) GetAttributes() []*DocumentAttribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *MediaWebDocument) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// MediaWebPage
type MediaWebPage struct {
}

func (m *MediaWebPage) Reset()         { *m = MediaWebPage{} }
func (m *MediaWebPage) String() string { return proto.CompactTextString(m) }
func (*MediaWebPage) ProtoMessage()    {}
func (*MediaWebPage) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{11}
}
func (m *MediaWebPage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MediaWebPage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MediaWebPage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MediaWebPage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MediaWebPage.Merge(m, src)
}
func (m *MediaWebPage) XXX_Size() int {
	return m.Size()
}
func (m *MediaWebPage) XXX_DiscardUnknown() {
	xxx_messageInfo_MediaWebPage.DiscardUnknown(m)
}

var xxx_messageInfo_MediaWebPage proto.InternalMessageInfo

// InputMediaContact
type InputMediaContact struct {
	Phone     string `protobuf:"bytes,1,req,name=Phone" json:"Phone"`
	FirstName string `protobuf:"bytes,2,req,name=FirstName" json:"FirstName"`
	LastName  string `protobuf:"bytes,3,req,name=LastName" json:"LastName"`
	VCard     string `protobuf:"bytes,4,opt,name=VCard" json:"VCard"`
}

func (m *InputMediaContact) Reset()         { *m = InputMediaContact{} }
func (m *InputMediaContact) String() string { return proto.CompactTextString(m) }
func (*InputMediaContact) ProtoMessage()    {}
func (*InputMediaContact) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{12}
}
func (m *InputMediaContact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputMediaContact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputMediaContact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputMediaContact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputMediaContact.Merge(m, src)
}
func (m *InputMediaContact) XXX_Size() int {
	return m.Size()
}
func (m *InputMediaContact) XXX_DiscardUnknown() {
	xxx_messageInfo_InputMediaContact.DiscardUnknown(m)
}

var xxx_messageInfo_InputMediaContact proto.InternalMessageInfo

func (m *InputMediaContact) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *InputMediaContact) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *InputMediaContact) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *InputMediaContact) GetVCard() string {
	if m != nil {
		return m.VCard
	}
	return ""
}

// MediaContact
type MediaContact struct {
	Phone     string `protobuf:"bytes,1,req,name=Phone" json:"Phone"`
	FirstName string `protobuf:"bytes,2,req,name=FirstName" json:"FirstName"`
	LastName  string `protobuf:"bytes,3,req,name=LastName" json:"LastName"`
	VCard     string `protobuf:"bytes,4,opt,name=VCard" json:"VCard"`
}

func (m *MediaContact) Reset()         { *m = MediaContact{} }
func (m *MediaContact) String() string { return proto.CompactTextString(m) }
func (*MediaContact) ProtoMessage()    {}
func (*MediaContact) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{13}
}
func (m *MediaContact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MediaContact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MediaContact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MediaContact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MediaContact.Merge(m, src)
}
func (m *MediaContact) XXX_Size() int {
	return m.Size()
}
func (m *MediaContact) XXX_DiscardUnknown() {
	xxx_messageInfo_MediaContact.DiscardUnknown(m)
}

var xxx_messageInfo_MediaContact proto.InternalMessageInfo

func (m *MediaContact) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *MediaContact) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *MediaContact) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *MediaContact) GetVCard() string {
	if m != nil {
		return m.VCard
	}
	return ""
}

// InputMediaUploadedDocument
type InputMediaUploadedDocument struct {
	File       *InputFile           `protobuf:"bytes,1,req,name=File" json:"File,omitempty"`
	Thumbnail  *InputFile           `protobuf:"bytes,2,opt,name=Thumbnail" json:"Thumbnail,omitempty"`
	MimeType   string               `protobuf:"bytes,3,req,name=MimeType" json:"MimeType"`
	Caption    string               `protobuf:"bytes,4,req,name=Caption" json:"Caption"`
	Stickers   []*InputDocument     `protobuf:"bytes,5,rep,name=Stickers" json:"Stickers,omitempty"`
	Attributes []*DocumentAttribute `protobuf:"bytes,6,rep,name=Attributes" json:"Attributes,omitempty"`
	Entities   []*MessageEntity     `protobuf:"bytes,7,rep,name=Entities" json:"Entities,omitempty"`
}

func (m *InputMediaUploadedDocument) Reset()         { *m = InputMediaUploadedDocument{} }
func (m *InputMediaUploadedDocument) String() string { return proto.CompactTextString(m) }
func (*InputMediaUploadedDocument) ProtoMessage()    {}
func (*InputMediaUploadedDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{14}
}
func (m *InputMediaUploadedDocument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputMediaUploadedDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputMediaUploadedDocument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputMediaUploadedDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputMediaUploadedDocument.Merge(m, src)
}
func (m *InputMediaUploadedDocument) XXX_Size() int {
	return m.Size()
}
func (m *InputMediaUploadedDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_InputMediaUploadedDocument.DiscardUnknown(m)
}

var xxx_messageInfo_InputMediaUploadedDocument proto.InternalMessageInfo

func (m *InputMediaUploadedDocument) GetFile() *InputFile {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *InputMediaUploadedDocument) GetThumbnail() *InputFile {
	if m != nil {
		return m.Thumbnail
	}
	return nil
}

func (m *InputMediaUploadedDocument) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *InputMediaUploadedDocument) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InputMediaUploadedDocument) GetStickers() []*InputDocument {
	if m != nil {
		return m.Stickers
	}
	return nil
}

func (m *InputMediaUploadedDocument) GetAttributes() []*DocumentAttribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *InputMediaUploadedDocument) GetEntities() []*MessageEntity {
	if m != nil {
		return m.Entities
	}
	return nil
}

// InputMediaDocument
type InputMediaDocument struct {
	Caption    string               `protobuf:"bytes,1,req,name=Caption" json:"Caption"`
	Document   *InputDocument       `protobuf:"bytes,2,req,name=Document" json:"Document,omitempty"`
	Entities   []*MessageEntity     `protobuf:"bytes,3,rep,name=Entities" json:"Entities,omitempty"`
	Thumbnail  *InputFile           `protobuf:"bytes,4,opt,name=Thumbnail" json:"Thumbnail,omitempty"`
	Attributes []*DocumentAttribute `protobuf:"bytes,5,rep,name=Attributes" json:"Attributes,omitempty"`
}

func (m *InputMediaDocument) Reset()         { *m = InputMediaDocument{} }
func (m *InputMediaDocument) String() string { return proto.CompactTextString(m) }
func (*InputMediaDocument) ProtoMessage()    {}
func (*InputMediaDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{15}
}
func (m *InputMediaDocument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputMediaDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputMediaDocument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputMediaDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputMediaDocument.Merge(m, src)
}
func (m *InputMediaDocument) XXX_Size() int {
	return m.Size()
}
func (m *InputMediaDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_InputMediaDocument.DiscardUnknown(m)
}

var xxx_messageInfo_InputMediaDocument proto.InternalMessageInfo

func (m *InputMediaDocument) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InputMediaDocument) GetDocument() *InputDocument {
	if m != nil {
		return m.Document
	}
	return nil
}

func (m *InputMediaDocument) GetEntities() []*MessageEntity {
	if m != nil {
		return m.Entities
	}
	return nil
}

func (m *InputMediaDocument) GetThumbnail() *InputFile {
	if m != nil {
		return m.Thumbnail
	}
	return nil
}

func (m *InputMediaDocument) GetAttributes() []*DocumentAttribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

// InputMediaUploadedSealedDocument
type InputMediaUploadedSealedDocument struct {
	SealedFile        *InputFile           `protobuf:"bytes,1,req,name=SealedFile" json:"SealedFile,omitempty"`
	SealedThumbnail   *InputFile           `protobuf:"bytes,2,opt,name=SealedThumbnail" json:"SealedThumbnail,omitempty"`
	EncryptedMimeType string               `protobuf:"bytes,3,req,name=EncryptedMimeType" json:"EncryptedMimeType"`
	EncryptedCaption  string               `protobuf:"bytes,4,req,name=EncryptedCaption" json:"EncryptedCaption"`
	Attributes        []*DocumentAttribute `protobuf:"bytes,6,rep,name=Attributes" json:"Attributes,omitempty"`
	Entities          []*MessageEntity     `protobuf:"bytes,7,rep,name=Entities" json:"Entities,omitempty"`
}

func (m *InputMediaUploadedSealedDocument) Reset()         { *m = InputMediaUploadedSealedDocument{} }
func (m *InputMediaUploadedSealedDocument) String() string { return proto.CompactTextString(m) }
func (*InputMediaUploadedSealedDocument) ProtoMessage()    {}
func (*InputMediaUploadedSealedDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{16}
}
func (m *InputMediaUploadedSealedDocument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputMediaUploadedSealedDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputMediaUploadedSealedDocument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputMediaUploadedSealedDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputMediaUploadedSealedDocument.Merge(m, src)
}
func (m *InputMediaUploadedSealedDocument) XXX_Size() int {
	return m.Size()
}
func (m *InputMediaUploadedSealedDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_InputMediaUploadedSealedDocument.DiscardUnknown(m)
}

var xxx_messageInfo_InputMediaUploadedSealedDocument proto.InternalMessageInfo

func (m *InputMediaUploadedSealedDocument) GetSealedFile() *InputFile {
	if m != nil {
		return m.SealedFile
	}
	return nil
}

func (m *InputMediaUploadedSealedDocument) GetSealedThumbnail() *InputFile {
	if m != nil {
		return m.SealedThumbnail
	}
	return nil
}

func (m *InputMediaUploadedSealedDocument) GetEncryptedMimeType() string {
	if m != nil {
		return m.EncryptedMimeType
	}
	return ""
}

func (m *InputMediaUploadedSealedDocument) GetEncryptedCaption() string {
	if m != nil {
		return m.EncryptedCaption
	}
	return ""
}

func (m *InputMediaUploadedSealedDocument) GetAttributes() []*DocumentAttribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *InputMediaUploadedSealedDocument) GetEntities() []*MessageEntity {
	if m != nil {
		return m.Entities
	}
	return nil
}

// MediaSealedDocument
type MediaSealedDocument struct {
	EncryptedMediaDocument []byte `protobuf:"bytes,1,req,name=EncryptedMediaDocument" json:"EncryptedMediaDocument"`
}

func (m *MediaSealedDocument) Reset()         { *m = MediaSealedDocument{} }
func (m *MediaSealedDocument) String() string { return proto.CompactTextString(m) }
func (*MediaSealedDocument) ProtoMessage()    {}
func (*MediaSealedDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{17}
}
func (m *MediaSealedDocument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MediaSealedDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MediaSealedDocument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MediaSealedDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MediaSealedDocument.Merge(m, src)
}
func (m *MediaSealedDocument) XXX_Size() int {
	return m.Size()
}
func (m *MediaSealedDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_MediaSealedDocument.DiscardUnknown(m)
}

var xxx_messageInfo_MediaSealedDocument proto.InternalMessageInfo

func (m *MediaSealedDocument) GetEncryptedMediaDocument() []byte {
	if m != nil {
		return m.EncryptedMediaDocument
	}
	return nil
}

// InputMediaMessageDocument
type InputMediaMessageDocument struct {
	Peer      *InputPeer       `protobuf:"bytes,1,req,name=Peer" json:"Peer,omitempty"`
	MessageID int64            `protobuf:"varint,2,req,name=MessageID" json:"MessageID"`
	Caption   string           `protobuf:"bytes,3,req,name=Caption" json:"Caption"`
	Entities  []*MessageEntity `protobuf:"bytes,4,rep,name=Entities" json:"Entities,omitempty"`
}

func (m *InputMediaMessageDocument) Reset()         { *m = InputMediaMessageDocument{} }
func (m *InputMediaMessageDocument) String() string { return proto.CompactTextString(m) }
func (*InputMediaMessageDocument) ProtoMessage()    {}
func (*InputMediaMessageDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{18}
}
func (m *InputMediaMessageDocument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputMediaMessageDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputMediaMessageDocument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputMediaMessageDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputMediaMessageDocument.Merge(m, src)
}
func (m *InputMediaMessageDocument) XXX_Size() int {
	return m.Size()
}
func (m *InputMediaMessageDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_InputMediaMessageDocument.DiscardUnknown(m)
}

var xxx_messageInfo_InputMediaMessageDocument proto.InternalMessageInfo

func (m *InputMediaMessageDocument) GetPeer() *InputPeer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *InputMediaMessageDocument) GetMessageID() int64 {
	if m != nil {
		return m.MessageID
	}
	return 0
}

func (m *InputMediaMessageDocument) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InputMediaMessageDocument) GetEntities() []*MessageEntity {
	if m != nil {
		return m.Entities
	}
	return nil
}

// MediaDocument
type MediaDocument struct {
	Caption      string           `protobuf:"bytes,1,opt,name=Caption" json:"Caption"`
	TTLinSeconds int32            `protobuf:"varint,2,opt,name=TTLinSeconds" json:"TTLinSeconds"`
	Doc          *Document        `protobuf:"bytes,3,req,name=Doc" json:"Doc,omitempty"`
	Entities     []*MessageEntity `protobuf:"bytes,4,rep,name=Entities" json:"Entities,omitempty"`
}

func (m *MediaDocument) Reset()         { *m = MediaDocument{} }
func (m *MediaDocument) String() string { return proto.CompactTextString(m) }
func (*MediaDocument) ProtoMessage()    {}
func (*MediaDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{19}
}
func (m *MediaDocument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MediaDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MediaDocument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MediaDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MediaDocument.Merge(m, src)
}
func (m *MediaDocument) XXX_Size() int {
	return m.Size()
}
func (m *MediaDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_MediaDocument.DiscardUnknown(m)
}

var xxx_messageInfo_MediaDocument proto.InternalMessageInfo

func (m *MediaDocument) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *MediaDocument) GetTTLinSeconds() int32 {
	if m != nil {
		return m.TTLinSeconds
	}
	return 0
}

func (m *MediaDocument) GetDoc() *Document {
	if m != nil {
		return m.Doc
	}
	return nil
}

func (m *MediaDocument) GetEntities() []*MessageEntity {
	if m != nil {
		return m.Entities
	}
	return nil
}

// InputMediaGeoLocation
type InputMediaGeoLocation struct {
	Lat      float32          `protobuf:"fixed32,1,req,name=Lat" json:"Lat"`
	Long     float32          `protobuf:"fixed32,2,req,name=Long" json:"Long"`
	Caption  string           `protobuf:"bytes,3,opt,name=Caption" json:"Caption"`
	Entities []*MessageEntity `protobuf:"bytes,4,rep,name=Entities" json:"Entities,omitempty"`
}

func (m *InputMediaGeoLocation) Reset()         { *m = InputMediaGeoLocation{} }
func (m *InputMediaGeoLocation) String() string { return proto.CompactTextString(m) }
func (*InputMediaGeoLocation) ProtoMessage()    {}
func (*InputMediaGeoLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{20}
}
func (m *InputMediaGeoLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputMediaGeoLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputMediaGeoLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputMediaGeoLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputMediaGeoLocation.Merge(m, src)
}
func (m *InputMediaGeoLocation) XXX_Size() int {
	return m.Size()
}
func (m *InputMediaGeoLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_InputMediaGeoLocation.DiscardUnknown(m)
}

var xxx_messageInfo_InputMediaGeoLocation proto.InternalMessageInfo

func (m *InputMediaGeoLocation) GetLat() float32 {
	if m != nil {
		return m.Lat
	}
	return 0
}

func (m *InputMediaGeoLocation) GetLong() float32 {
	if m != nil {
		return m.Long
	}
	return 0
}

func (m *InputMediaGeoLocation) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InputMediaGeoLocation) GetEntities() []*MessageEntity {
	if m != nil {
		return m.Entities
	}
	return nil
}

// MediaGeoLocation
type MediaGeoLocation struct {
	Lat      float32          `protobuf:"fixed32,1,req,name=Lat" json:"Lat"`
	Long     float32          `protobuf:"fixed32,2,req,name=Long" json:"Long"`
	Caption  string           `protobuf:"bytes,3,opt,name=Caption" json:"Caption"`
	Entities []*MessageEntity `protobuf:"bytes,4,rep,name=Entities" json:"Entities,omitempty"`
}

func (m *MediaGeoLocation) Reset()         { *m = MediaGeoLocation{} }
func (m *MediaGeoLocation) String() string { return proto.CompactTextString(m) }
func (*MediaGeoLocation) ProtoMessage()    {}
func (*MediaGeoLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{21}
}
func (m *MediaGeoLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MediaGeoLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MediaGeoLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MediaGeoLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MediaGeoLocation.Merge(m, src)
}
func (m *MediaGeoLocation) XXX_Size() int {
	return m.Size()
}
func (m *MediaGeoLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_MediaGeoLocation.DiscardUnknown(m)
}

var xxx_messageInfo_MediaGeoLocation proto.InternalMessageInfo

func (m *MediaGeoLocation) GetLat() float32 {
	if m != nil {
		return m.Lat
	}
	return 0
}

func (m *MediaGeoLocation) GetLong() float32 {
	if m != nil {
		return m.Long
	}
	return 0
}

func (m *MediaGeoLocation) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *MediaGeoLocation) GetEntities() []*MessageEntity {
	if m != nil {
		return m.Entities
	}
	return nil
}

// InputMediaPoll
type InputMediaPoll struct {
	Poll *MediaPoll `protobuf:"bytes,1,req,name=Poll" json:"Poll,omitempty"`
}

func (m *InputMediaPoll) Reset()         { *m = InputMediaPoll{} }
func (m *InputMediaPoll) String() string { return proto.CompactTextString(m) }
func (*InputMediaPoll) ProtoMessage()    {}
func (*InputMediaPoll) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{22}
}
func (m *InputMediaPoll) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputMediaPoll) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputMediaPoll.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputMediaPoll) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputMediaPoll.Merge(m, src)
}
func (m *InputMediaPoll) XXX_Size() int {
	return m.Size()
}
func (m *InputMediaPoll) XXX_DiscardUnknown() {
	xxx_messageInfo_InputMediaPoll.DiscardUnknown(m)
}

var xxx_messageInfo_InputMediaPoll proto.InternalMessageInfo

func (m *InputMediaPoll) GetPoll() *MediaPoll {
	if m != nil {
		return m.Poll
	}
	return nil
}

// MediaPoll
type MediaPoll struct {
	ID           int64         `protobuf:"varint,1,req,name=ID" json:"ID"`
	Closed       bool          `protobuf:"varint,2,opt,name=Closed" json:"Closed"`
	PublicVoters bool          `protobuf:"varint,3,opt,name=PublicVoters" json:"PublicVoters"`
	MultiChoice  bool          `protobuf:"varint,4,opt,name=MultiChoice" json:"MultiChoice"`
	Quiz         bool          `protobuf:"varint,5,opt,name=Quiz" json:"Quiz"`
	Question     string        `protobuf:"bytes,6,req,name=Question" json:"Question"`
	Answers      []*PollAnswer `protobuf:"bytes,7,rep,name=Answers" json:"Answers,omitempty"`
}

func (m *MediaPoll) Reset()         { *m = MediaPoll{} }
func (m *MediaPoll) String() string { return proto.CompactTextString(m) }
func (*MediaPoll) ProtoMessage()    {}
func (*MediaPoll) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{23}
}
func (m *MediaPoll) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MediaPoll) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MediaPoll.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MediaPoll) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MediaPoll.Merge(m, src)
}
func (m *MediaPoll) XXX_Size() int {
	return m.Size()
}
func (m *MediaPoll) XXX_DiscardUnknown() {
	xxx_messageInfo_MediaPoll.DiscardUnknown(m)
}

var xxx_messageInfo_MediaPoll proto.InternalMessageInfo

func (m *MediaPoll) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *MediaPoll) GetClosed() bool {
	if m != nil {
		return m.Closed
	}
	return false
}

func (m *MediaPoll) GetPublicVoters() bool {
	if m != nil {
		return m.PublicVoters
	}
	return false
}

func (m *MediaPoll) GetMultiChoice() bool {
	if m != nil {
		return m.MultiChoice
	}
	return false
}

func (m *MediaPoll) GetQuiz() bool {
	if m != nil {
		return m.Quiz
	}
	return false
}

func (m *MediaPoll) GetQuestion() string {
	if m != nil {
		return m.Question
	}
	return ""
}

func (m *MediaPoll) GetAnswers() []*PollAnswer {
	if m != nil {
		return m.Answers
	}
	return nil
}

// PollAnswer
type PollAnswer struct {
	Text   string `protobuf:"bytes,1,req,name=Text" json:"Text"`
	Option []byte `protobuf:"bytes,2,req,name=Option" json:"Option"`
}

func (m *PollAnswer) Reset()         { *m = PollAnswer{} }
func (m *PollAnswer) String() string { return proto.CompactTextString(m) }
func (*PollAnswer) ProtoMessage()    {}
func (*PollAnswer) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{24}
}
func (m *PollAnswer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PollAnswer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PollAnswer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PollAnswer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PollAnswer.Merge(m, src)
}
func (m *PollAnswer) XXX_Size() int {
	return m.Size()
}
func (m *PollAnswer) XXX_DiscardUnknown() {
	xxx_messageInfo_PollAnswer.DiscardUnknown(m)
}

var xxx_messageInfo_PollAnswer proto.InternalMessageInfo

func (m *PollAnswer) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *PollAnswer) GetOption() []byte {
	if m != nil {
		return m.Option
	}
	return nil
}

// PollResults
type PollResults struct {
	Results     []*PollAnswerVoters `protobuf:"bytes,1,rep,name=Results" json:"Results,omitempty"`
	TotalVoters int64               `protobuf:"varint,2,req,name=TotalVoters" json:"TotalVoters"`
}

func (m *PollResults) Reset()         { *m = PollResults{} }
func (m *PollResults) String() string { return proto.CompactTextString(m) }
func (*PollResults) ProtoMessage()    {}
func (*PollResults) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{25}
}
func (m *PollResults) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PollResults) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PollResults.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PollResults) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PollResults.Merge(m, src)
}
func (m *PollResults) XXX_Size() int {
	return m.Size()
}
func (m *PollResults) XXX_DiscardUnknown() {
	xxx_messageInfo_PollResults.DiscardUnknown(m)
}

var xxx_messageInfo_PollResults proto.InternalMessageInfo

func (m *PollResults) GetResults() []*PollAnswerVoters {
	if m != nil {
		return m.Results
	}
	return nil
}

func (m *PollResults) GetTotalVoters() int64 {
	if m != nil {
		return m.TotalVoters
	}
	return 0
}

// PollAnswerVoters
type PollAnswerVoters struct {
	Chosen  bool   `protobuf:"varint,1,req,name=Chosen" json:"Chosen"`
	Correct bool   `protobuf:"varint,2,req,name=Correct" json:"Correct"`
	Option  []byte `protobuf:"bytes,3,req,name=Option" json:"Option"`
	Voters  int64  `protobuf:"varint,4,req,name=Voters" json:"Voters"`
}

func (m *PollAnswerVoters) Reset()         { *m = PollAnswerVoters{} }
func (m *PollAnswerVoters) String() string { return proto.CompactTextString(m) }
func (*PollAnswerVoters) ProtoMessage()    {}
func (*PollAnswerVoters) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{26}
}
func (m *PollAnswerVoters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PollAnswerVoters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PollAnswerVoters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PollAnswerVoters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PollAnswerVoters.Merge(m, src)
}
func (m *PollAnswerVoters) XXX_Size() int {
	return m.Size()
}
func (m *PollAnswerVoters) XXX_DiscardUnknown() {
	xxx_messageInfo_PollAnswerVoters.DiscardUnknown(m)
}

var xxx_messageInfo_PollAnswerVoters proto.InternalMessageInfo

func (m *PollAnswerVoters) GetChosen() bool {
	if m != nil {
		return m.Chosen
	}
	return false
}

func (m *PollAnswerVoters) GetCorrect() bool {
	if m != nil {
		return m.Correct
	}
	return false
}

func (m *PollAnswerVoters) GetOption() []byte {
	if m != nil {
		return m.Option
	}
	return nil
}

func (m *PollAnswerVoters) GetVoters() int64 {
	if m != nil {
		return m.Voters
	}
	return 0
}

// InputMediaSealed
type InputMediaSealed struct {
	MediaType      InputMediaType   `protobuf:"varint,1,req,name=MediaType,enum=msg.InputMediaType" json:"MediaType"`
	EncryptedMedia []byte           `protobuf:"bytes,2,opt,name=EncryptedMedia" json:"EncryptedMedia"`
	EncryptedBody  string           `protobuf:"bytes,3,opt,name=EncryptedBody" json:"EncryptedBody"`
	Entities       []*MessageEntity `protobuf:"bytes,4,rep,name=Entities" json:"Entities,omitempty"`
}

func (m *InputMediaSealed) Reset()         { *m = InputMediaSealed{} }
func (m *InputMediaSealed) String() string { return proto.CompactTextString(m) }
func (*InputMediaSealed) ProtoMessage()    {}
func (*InputMediaSealed) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{27}
}
func (m *InputMediaSealed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputMediaSealed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputMediaSealed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputMediaSealed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputMediaSealed.Merge(m, src)
}
func (m *InputMediaSealed) XXX_Size() int {
	return m.Size()
}
func (m *InputMediaSealed) XXX_DiscardUnknown() {
	xxx_messageInfo_InputMediaSealed.DiscardUnknown(m)
}

var xxx_messageInfo_InputMediaSealed proto.InternalMessageInfo

func (m *InputMediaSealed) GetMediaType() InputMediaType {
	if m != nil {
		return m.MediaType
	}
	return InputMediaTypeEmpty
}

func (m *InputMediaSealed) GetEncryptedMedia() []byte {
	if m != nil {
		return m.EncryptedMedia
	}
	return nil
}

func (m *InputMediaSealed) GetEncryptedBody() string {
	if m != nil {
		return m.EncryptedBody
	}
	return ""
}

func (m *InputMediaSealed) GetEntities() []*MessageEntity {
	if m != nil {
		return m.Entities
	}
	return nil
}

// MediaSealed
type MediaSealed struct {
	MediaType MediaType        `protobuf:"varint,1,req,name=MediaType,enum=msg.MediaType" json:"MediaType"`
	Media     []byte           `protobuf:"bytes,2,opt,name=Media" json:"Media"`
	Body      string           `protobuf:"bytes,3,opt,name=Body" json:"Body"`
	Entities  []*MessageEntity `protobuf:"bytes,4,rep,name=Entities" json:"Entities,omitempty"`
}

func (m *MediaSealed) Reset()         { *m = MediaSealed{} }
func (m *MediaSealed) String() string { return proto.CompactTextString(m) }
func (*MediaSealed) ProtoMessage()    {}
func (*MediaSealed) Descriptor() ([]byte, []int) {
	return fileDescriptor_e1db1afc72e87ac5, []int{28}
}
func (m *MediaSealed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MediaSealed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MediaSealed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MediaSealed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MediaSealed.Merge(m, src)
}
func (m *MediaSealed) XXX_Size() int {
	return m.Size()
}
func (m *MediaSealed) XXX_DiscardUnknown() {
	xxx_messageInfo_MediaSealed.DiscardUnknown(m)
}

var xxx_messageInfo_MediaSealed proto.InternalMessageInfo

func (m *MediaSealed) GetMediaType() MediaType {
	if m != nil {
		return m.MediaType
	}
	return MediaTypeEmpty
}

func (m *MediaSealed) GetMedia() []byte {
	if m != nil {
		return m.Media
	}
	return nil
}

func (m *MediaSealed) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

func (m *MediaSealed) GetEntities() []*MessageEntity {
	if m != nil {
		return m.Entities
	}
	return nil
}

func init() {
	proto.RegisterEnum("msg.DocumentAttributeType", DocumentAttributeType_name, DocumentAttributeType_value)
	proto.RegisterEnum("msg.DocumentType", DocumentType_name, DocumentType_value)
	proto.RegisterType((*DocumentAttributeAudio)(nil), "msg.DocumentAttributeAudio")
	proto.RegisterType((*DocumentAttributeVideo)(nil), "msg.DocumentAttributeVideo")
	proto.RegisterType((*DocumentAttributePhoto)(nil), "msg.DocumentAttributePhoto")
	proto.RegisterType((*DocumentAttributeFile)(nil), "msg.DocumentAttributeFile")
	proto.RegisterType((*DocumentAttributeAnimated)(nil), "msg.DocumentAttributeAnimated")
	proto.RegisterType((*DocumentAttribute)(nil), "msg.DocumentAttribute")
	proto.RegisterType((*Document)(nil), "msg.Document")
	proto.RegisterType((*InputMediaInvoice)(nil), "msg.InputMediaInvoice")
	proto.RegisterType((*MediaInvoice)(nil), "msg.MediaInvoice")
	proto.RegisterType((*InputMediaWebDocument)(nil), "msg.InputMediaWebDocument")
	proto.RegisterType((*MediaWebDocument)(nil), "msg.MediaWebDocument")
	proto.RegisterType((*MediaWebPage)(nil), "msg.MediaWebPage")
	proto.RegisterType((*InputMediaContact)(nil), "msg.InputMediaContact")
	proto.RegisterType((*MediaContact)(nil), "msg.MediaContact")
	proto.RegisterType((*InputMediaUploadedDocument)(nil), "msg.InputMediaUploadedDocument")
	proto.RegisterType((*InputMediaDocument)(nil), "msg.InputMediaDocument")
	proto.RegisterType((*InputMediaUploadedSealedDocument)(nil), "msg.InputMediaUploadedSealedDocument")
	proto.RegisterType((*MediaSealedDocument)(nil), "msg.MediaSealedDocument")
	proto.RegisterType((*InputMediaMessageDocument)(nil), "msg.InputMediaMessageDocument")
	proto.RegisterType((*MediaDocument)(nil), "msg.MediaDocument")
	proto.RegisterType((*InputMediaGeoLocation)(nil), "msg.InputMediaGeoLocation")
	proto.RegisterType((*MediaGeoLocation)(nil), "msg.MediaGeoLocation")
	proto.RegisterType((*InputMediaPoll)(nil), "msg.InputMediaPoll")
	proto.RegisterType((*MediaPoll)(nil), "msg.MediaPoll")
	proto.RegisterType((*PollAnswer)(nil), "msg.PollAnswer")
	proto.RegisterType((*PollResults)(nil), "msg.PollResults")
	proto.RegisterType((*PollAnswerVoters)(nil), "msg.PollAnswerVoters")
	proto.RegisterType((*InputMediaSealed)(nil), "msg.InputMediaSealed")
	proto.RegisterType((*MediaSealed)(nil), "msg.MediaSealed")
}

func init() { proto.RegisterFile("chat.messages.medias.proto", fileDescriptor_e1db1afc72e87ac5) }

var fileDescriptor_e1db1afc72e87ac5 = []byte{
	// 1535 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xcd, 0x6e, 0xdb, 0xc6,
	0x16, 0x36, 0x49, 0xfd, 0xf9, 0xf8, 0x27, 0x34, 0x7d, 0xed, 0xcb, 0xf8, 0x06, 0x8a, 0xc0, 0x45,
	0xe0, 0x1b, 0xe4, 0x2a, 0xb9, 0x8a, 0xfb, 0x07, 0x74, 0x63, 0x4b, 0x49, 0x63, 0xc0, 0x4e, 0x15,
	0x5a, 0xb1, 0xd7, 0x14, 0x35, 0x91, 0x88, 0x50, 0x1c, 0x81, 0x1c, 0x26, 0x75, 0x9e, 0xa0, 0x8b,
	0x2e, 0x52, 0xa0, 0x9b, 0x3e, 0x41, 0xd1, 0x6e, 0xfb, 0x12, 0x59, 0x74, 0x91, 0x45, 0x0b, 0x14,
	0x5d, 0x14, 0x6d, 0xf2, 0x04, 0xdd, 0x15, 0x05, 0x0a, 0x14, 0x73, 0xf8, 0x37, 0x14, 0xa5, 0xd8,
	0x49, 0x81, 0x22, 0x2b, 0x9b, 0xdf, 0x39, 0x33, 0x73, 0xce, 0x77, 0xbe, 0x39, 0x33, 0x23, 0xd8,
	0xb2, 0x47, 0x16, 0x6b, 0x8e, 0x49, 0x10, 0x58, 0x43, 0x12, 0x34, 0xc7, 0x64, 0xe0, 0x58, 0x41,
	0x73, 0xe2, 0x53, 0x46, 0x35, 0x65, 0x1c, 0x0c, 0xb7, 0x54, 0x9b, 0xfa, 0xa4, 0xc9, 0x4e, 0x27,
	0x24, 0x86, 0xb7, 0xfe, 0x37, 0x74, 0xd8, 0x28, 0xec, 0x37, 0x6d, 0x3a, 0xbe, 0x3e, 0xa4, 0x43,
	0x7a, 0x1d, 0xe1, 0x7e, 0xf8, 0x00, 0xbf, 0xf0, 0x03, 0xff, 0x8b, 0xdc, 0x8d, 0xef, 0x25, 0xd8,
	0xec, 0x50, 0x3b, 0x1c, 0x13, 0x8f, 0xed, 0x32, 0xe6, 0x3b, 0xfd, 0x90, 0x91, 0xdd, 0x70, 0xe0,
	0x50, 0x6d, 0x0b, 0xca, 0xc7, 0xd4, 0xb1, 0x89, 0x2e, 0x35, 0xe4, 0xed, 0xda, 0x5e, 0xe9, 0xd9,
	0xcf, 0x97, 0x17, 0xcc, 0x08, 0xd2, 0x1a, 0x50, 0xeb, 0x84, 0xbe, 0xc5, 0x1c, 0xea, 0xe9, 0x72,
	0x43, 0xde, 0x5e, 0x89, 0xcd, 0x29, 0xca, 0x47, 0xf7, 0x1c, 0xe6, 0x12, 0x5d, 0x69, 0xc8, 0xdb,
	0x8b, 0xc9, 0x68, 0x84, 0x34, 0x03, 0x16, 0xbb, 0xc4, 0x7f, 0x40, 0xfd, 0x31, 0xf1, 0xf5, 0x92,
	0x60, 0xcf, 0x60, 0x3e, 0x7e, 0xd7, 0xed, 0x87, 0x63, 0xbd, 0x2c, 0x8e, 0x47, 0x88, 0xaf, 0x7e,
	0x62, 0x3d, 0x22, 0xdc, 0x53, 0xaf, 0x34, 0xa4, 0xed, 0xe5, 0x64, 0xf5, 0x04, 0x35, 0x9e, 0xce,
	0x4a, 0xeb, 0xd8, 0x19, 0x10, 0x4c, 0xeb, 0xc4, 0x19, 0xb0, 0x11, 0xa6, 0x95, 0xc4, 0x1d, 0x41,
	0xda, 0x25, 0xa8, 0xdc, 0x21, 0xce, 0x70, 0xc4, 0x72, 0x49, 0xc5, 0x58, 0x2e, 0x69, 0x65, 0x5e,
	0xd2, 0x26, 0x0d, 0xbd, 0x01, 0x26, 0x95, 0x52, 0x86, 0x90, 0x61, 0xce, 0x88, 0xa8, 0x3b, 0xe2,
	0x95, 0x7c, 0xe3, 0x88, 0x8c, 0x0f, 0x60, 0xa3, 0x30, 0xe7, 0x6d, 0xc7, 0xc5, 0xfa, 0xf0, 0xbf,
	0x9e, 0x35, 0x8e, 0xca, 0x97, 0x10, 0x98, 0xa2, 0xc6, 0x7f, 0xe0, 0x62, 0xb1, 0xee, 0x9e, 0x33,
	0xb6, 0x18, 0x19, 0x18, 0x36, 0xac, 0x15, 0x8c, 0xda, 0x0e, 0x94, 0x7a, 0xa7, 0x93, 0x68, 0xbe,
	0xd5, 0xd6, 0x56, 0x73, 0x1c, 0x0c, 0x9b, 0x05, 0x2f, 0xee, 0x11, 0xaf, 0x85, 0xde, 0x9a, 0x0e,
	0xa5, 0x8e, 0xc5, 0x2c, 0x5d, 0x16, 0xea, 0x84, 0x88, 0xf1, 0xa7, 0x0c, 0xb5, 0x64, 0xbc, 0xb6,
	0x09, 0xf2, 0x7e, 0x07, 0xa7, 0x56, 0xf6, 0x2a, 0xdc, 0xe9, 0x86, 0x64, 0xca, 0xfb, 0x1d, 0xed,
	0x0a, 0xc0, 0xae, 0x6d, 0x93, 0x20, 0xb8, 0x63, 0x05, 0x23, 0xe4, 0xa0, 0x92, 0xda, 0x05, 0x4b,
	0xbc, 0x4c, 0xa4, 0x36, 0x45, 0x58, 0x06, 0xa9, 0x38, 0x74, 0xc6, 0x18, 0x58, 0x4e, 0x6b, 0x29,
	0x9a, 0x90, 0x75, 0xe4, 0x3c, 0x21, 0xa8, 0xb6, 0xb2, 0x48, 0x16, 0x47, 0xb5, 0x3a, 0x54, 0x8f,
	0x89, 0x1f, 0xf0, 0xc2, 0x57, 0x04, 0x87, 0x04, 0xe4, 0x82, 0x6e, 0xbb, 0x61, 0xc0, 0x88, 0xbf,
	0xdf, 0xd1, 0xab, 0x82, 0x47, 0x06, 0x6b, 0xef, 0x02, 0xa4, 0x2c, 0x05, 0x7a, 0xad, 0xa1, 0x6c,
	0x2f, 0xb5, 0x36, 0x67, 0x93, 0x68, 0x0a, 0x9e, 0xda, 0x75, 0x58, 0xec, 0x8d, 0xc2, 0x71, 0xdf,
	0xb3, 0x1c, 0x57, 0x5f, 0x6c, 0x48, 0xdb, 0x4b, 0xad, 0x35, 0x1c, 0xc6, 0xa3, 0x3b, 0xa0, 0x36,
	0x2a, 0xcf, 0xcc, 0x7c, 0xb4, 0x2b, 0xb0, 0x74, 0xd8, 0x79, 0xa7, 0x3d, 0x22, 0xf6, 0xc3, 0x20,
	0x1c, 0xeb, 0xd0, 0x90, 0xd2, 0x9c, 0x45, 0x83, 0xb1, 0x0e, 0x6b, 0xfb, 0xde, 0x24, 0x64, 0x87,
	0xbc, 0xab, 0xec, 0x7b, 0x8f, 0xf8, 0xc6, 0x36, 0x56, 0x61, 0x39, 0xf7, 0xfd, 0xb5, 0x04, 0x1b,
	0x99, 0xd7, 0x09, 0xe9, 0x0b, 0x15, 0x53, 0xee, 0xfb, 0x6e, 0x4e, 0x5d, 0x1c, 0xe0, 0x5c, 0x75,
	0xa8, 0x8d, 0x64, 0xca, 0x22, 0x57, 0x31, 0x98, 0xab, 0x87, 0x32, 0xb3, 0x1e, 0x79, 0xa6, 0x4a,
	0xe7, 0x65, 0xca, 0xf8, 0x4e, 0x02, 0xf5, 0xed, 0x0f, 0x73, 0x4a, 0xd2, 0xe5, 0x79, 0x92, 0x4e,
	0x4b, 0x71, 0x42, 0xfa, 0x5d, 0x6b, 0x48, 0x8c, 0xcf, 0x25, 0xb1, 0x60, 0x6d, 0xea, 0x31, 0xcb,
	0x66, 0xbc, 0x79, 0x74, 0x47, 0xd4, 0xcb, 0x6f, 0xf3, 0x08, 0xe2, 0xb2, 0xbc, 0xed, 0xf8, 0x01,
	0xbb, 0xcb, 0xdb, 0x80, 0x2c, 0xf6, 0xd9, 0x14, 0xe6, 0x79, 0x1e, 0x58, 0xb1, 0x4b, 0x2e, 0xcf,
	0x04, 0xc5, 0x73, 0xa0, 0x6d, 0xf9, 0xbc, 0xa9, 0x65, 0x4a, 0x8a, 0x20, 0xe3, 0x33, 0x29, 0x0e,
	0xf2, 0xed, 0x08, 0xe7, 0x99, 0x0c, 0x5b, 0x19, 0x45, 0xf7, 0x27, 0x2e, 0xb5, 0x06, 0x64, 0x90,
	0x6a, 0xc1, 0x80, 0x12, 0xdf, 0x34, 0x18, 0xdb, 0x52, 0x6b, 0x15, 0x6b, 0x85, 0xee, 0x1c, 0x35,
	0xd1, 0xa6, 0x5d, 0x13, 0xb7, 0x9b, 0x8c, 0xdb, 0x6d, 0xda, 0x51, 0xd8, 0x6b, 0x67, 0xab, 0xa4,
	0x0e, 0xd5, 0xb6, 0x35, 0xc1, 0x33, 0x43, 0xec, 0x3e, 0x09, 0xa8, 0x35, 0xa1, 0x76, 0xc4, 0x1c,
	0xfb, 0x21, 0xf1, 0x03, 0xbd, 0x8c, 0x1a, 0xd2, 0xb2, 0xe5, 0x92, 0xc8, 0xcd, 0xd4, 0x67, 0x4a,
	0x75, 0x95, 0x73, 0xab, 0xae, 0x09, 0xb5, 0x5b, 0x1e, 0x73, 0x98, 0x43, 0x02, 0xbd, 0x2a, 0xac,
	0x73, 0x18, 0x5d, 0x2e, 0xd0, 0x76, 0x6a, 0xa6, 0x3e, 0xc6, 0x1f, 0x12, 0x68, 0x19, 0x95, 0x29,
	0x85, 0x42, 0x3a, 0xd2, 0x9c, 0x74, 0x12, 0x5f, 0x2c, 0xf1, 0x9c, 0x74, 0xd2, 0xf9, 0xc4, 0xb0,
	0x94, 0xb3, 0xc3, 0xca, 0x97, 0xa7, 0x74, 0x56, 0x79, 0xf2, 0x64, 0x95, 0xcf, 0xdd, 0x49, 0x7e,
	0x92, 0xa1, 0x51, 0xd4, 0xd1, 0x11, 0xb1, 0x5c, 0x41, 0x4d, 0x4d, 0x80, 0x08, 0x79, 0x85, 0xa6,
	0x04, 0x0f, 0xed, 0x7d, 0xb8, 0x10, 0x7d, 0x9d, 0xa5, 0xaf, 0x69, 0x37, 0xad, 0x05, 0x6b, 0xb7,
	0x3c, 0xdb, 0x3f, 0x9d, 0x30, 0x32, 0x98, 0x29, 0xb7, 0xa2, 0x59, 0xbb, 0x01, 0x6a, 0x0a, 0xce,
	0x12, 0x60, 0xc1, 0xfa, 0x8f, 0x29, 0xeb, 0x08, 0xd6, 0x91, 0xd6, 0x29, 0x3a, 0x3f, 0x84, 0xcd,
	0x2c, 0x0b, 0x51, 0x73, 0x48, 0x6d, 0x72, 0x75, 0x98, 0xe3, 0x63, 0x7c, 0x2b, 0xc1, 0xc5, 0xac,
	0x62, 0xf1, 0xd2, 0xe2, 0xc6, 0xef, 0x12, 0xe2, 0x17, 0x8b, 0xc4, 0x51, 0x13, 0x6d, 0xbc, 0x3b,
	0xc5, 0xc3, 0xf6, 0x3b, 0x28, 0xdd, 0xe4, 0x1a, 0x91, 0xc1, 0xa2, 0xfa, 0x95, 0x39, 0xea, 0x4f,
	0xa9, 0x28, 0x9d, 0x83, 0x8a, 0x6f, 0x24, 0x58, 0x79, 0xc5, 0xfe, 0x92, 0x8a, 0x2b, 0x6c, 0xc3,
	0x72, 0xaf, 0x77, 0xe0, 0x78, 0x47, 0xc4, 0xa6, 0xde, 0x20, 0x40, 0x05, 0x25, 0x67, 0x57, 0xce,
	0xa2, 0x5d, 0x06, 0xa5, 0x43, 0x6d, 0x8c, 0x73, 0xa9, 0xb5, 0x92, 0xab, 0xa3, 0xc9, 0x2d, 0xaf,
	0x1d, 0xec, 0x97, 0xb9, 0xab, 0xc0, 0x47, 0x84, 0x26, 0x97, 0x0f, 0x7e, 0xc6, 0x1e, 0x58, 0x51,
	0x9d, 0xe4, 0xe4, 0x8c, 0x3d, 0xb0, 0x18, 0xbf, 0x94, 0x1d, 0x50, 0x6f, 0x88, 0x6c, 0x26, 0x06,
	0x44, 0xf2, 0x44, 0x4a, 0x7f, 0x9f, 0xc8, 0x2f, 0x92, 0xa3, 0xff, 0xed, 0x0a, 0x6b, 0x07, 0x56,
	0x33, 0xc6, 0xba, 0xd4, 0x75, 0x51, 0x89, 0xd4, 0x75, 0x73, 0x4a, 0x4c, 0xad, 0x26, 0xda, 0x8c,
	0xdf, 0x25, 0x2e, 0xc5, 0x64, 0xc4, 0xbf, 0x84, 0x9b, 0x71, 0x14, 0x0e, 0xbf, 0x17, 0x5f, 0x82,
	0x4a, 0xdb, 0xa5, 0x01, 0x19, 0xa0, 0x02, 0x92, 0xa7, 0x46, 0x8c, 0x71, 0x95, 0x74, 0xc3, 0xbe,
	0xeb, 0xd8, 0xc7, 0x94, 0xf1, 0x83, 0x45, 0x11, 0x7c, 0x72, 0x16, 0xbc, 0x2c, 0x86, 0x2e, 0x73,
	0xda, 0x23, 0x7c, 0xea, 0x95, 0x04, 0x47, 0xd1, 0xc0, 0x39, 0xbb, 0x17, 0x3a, 0x4f, 0xf4, 0xb2,
	0xe0, 0x80, 0x08, 0x3f, 0x02, 0xef, 0x85, 0x24, 0x60, 0xc9, 0xe5, 0x38, 0x3d, 0x02, 0x13, 0x54,
	0xfb, 0x2f, 0x54, 0x77, 0xbd, 0xe0, 0x31, 0x0f, 0x24, 0xea, 0x0f, 0x17, 0x30, 0x6d, 0x9e, 0x5d,
	0x84, 0x9b, 0x89, 0xdd, 0xe8, 0x00, 0x64, 0x30, 0x5f, 0xb4, 0x47, 0x3e, 0x61, 0xb9, 0x93, 0x06,
	0x11, 0x9e, 0xfe, 0xc7, 0x93, 0xf4, 0xf5, 0x99, 0x34, 0x87, 0x18, 0x33, 0x1e, 0xc0, 0x12, 0xd2,
	0x49, 0x82, 0xd0, 0x65, 0xfc, 0x06, 0x5d, 0x8d, 0xff, 0xd5, 0x25, 0x5c, 0x7f, 0x63, 0x6a, 0xfd,
	0x88, 0x0b, 0x33, 0xf1, 0xe2, 0xa4, 0xf4, 0x28, 0xb3, 0xdc, 0x98, 0x3d, 0xb1, 0x19, 0x88, 0x06,
	0x7e, 0xfb, 0x51, 0xa7, 0x67, 0xc1, 0xca, 0x8c, 0x68, 0x40, 0xbc, 0xdc, 0xbb, 0x39, 0xc6, 0x50,
	0x61, 0xd4, 0xf7, 0x89, 0x1d, 0x1d, 0x8f, 0xb5, 0x54, 0x61, 0x11, 0x28, 0x24, 0xa6, 0x14, 0x13,
	0xe3, 0xd6, 0x38, 0xa6, 0x92, 0x10, 0x53, 0x8c, 0x19, 0x3f, 0x48, 0xa0, 0x66, 0x72, 0x8b, 0xda,
	0xab, 0xf6, 0x5e, 0xac, 0x25, 0xe1, 0xe9, 0xb6, 0x9e, 0xf5, 0xbf, 0xd4, 0x94, 0xf5, 0xba, 0x18,
	0xd0, 0xae, 0xc1, 0x6a, 0xbe, 0xd7, 0xe6, 0x9e, 0x70, 0x53, 0x36, 0xed, 0x2a, 0xac, 0xa4, 0xc8,
	0x1e, 0x1d, 0x9c, 0xe6, 0xf6, 0x4f, 0xde, 0xf4, 0xda, 0xbb, 0xe8, 0x2b, 0x09, 0x96, 0xc4, 0x94,
	0x5a, 0xc5, 0x94, 0x84, 0x8d, 0x34, 0x3b, 0x9b, 0x2d, 0x28, 0x17, 0x93, 0x88, 0x20, 0x2e, 0xb3,
	0x42, 0xc8, 0xa5, 0x37, 0x89, 0xf4, 0xea, 0xa7, 0xf2, 0x8c, 0x07, 0x39, 0xae, 0xbf, 0x01, 0x6b,
	0x39, 0xe0, 0x2e, 0xf5, 0x88, 0xba, 0xa0, 0x6d, 0x82, 0x96, 0x83, 0xf1, 0x97, 0x17, 0x55, 0x2a,
	0xe0, 0xf8, 0xd3, 0x85, 0x2a, 0x17, 0x70, 0xfc, 0x01, 0x41, 0x55, 0x0a, 0xd3, 0xf3, 0x7b, 0x84,
	0x5a, 0xd2, 0x2e, 0xc2, 0x46, 0x7e, 0xfa, 0xf8, 0x81, 0xaf, 0x96, 0x73, 0x33, 0x99, 0x24, 0x20,
	0xfe, 0x23, 0x32, 0xf8, 0xbf, 0x5a, 0x99, 0x89, 0xb7, 0xd4, 0xea, 0x4c, 0xfc, 0xa6, 0x5a, 0x9b,
	0x89, 0xef, 0xa8, 0x8b, 0x57, 0x7f, 0x93, 0x60, 0x39, 0xa1, 0x02, 0x19, 0xf8, 0x37, 0xac, 0x8b,
	0xdf, 0xf7, 0xbd, 0x87, 0x1e, 0x7d, 0xec, 0xa9, 0x0b, 0x3c, 0x76, 0xd1, 0x10, 0xa5, 0x24, 0x4d,
	0xc3, 0xf8, 0xbb, 0x93, 0x2a, 0x17, 0x60, 0x24, 0x46, 0x99, 0x9e, 0x3d, 0x7e, 0x33, 0x45, 0x14,
	0x88, 0x86, 0x2c, 0xd5, 0xf2, 0x3c, 0x53, 0x4b, 0xad, 0xcc, 0x33, 0xdd, 0x54, 0xab, 0xf3, 0x4c,
	0x3b, 0x6a, 0x6d, 0xef, 0xd2, 0xf3, 0x5f, 0xeb, 0x0b, 0xcf, 0x5e, 0xd4, 0xa5, 0xe7, 0x2f, 0xea,
	0xd2, 0x2f, 0x2f, 0xea, 0xd2, 0xd3, 0x97, 0xf5, 0x85, 0xe7, 0x2f, 0xeb, 0x0b, 0x3f, 0xbe, 0xac,
	0x2f, 0xfc, 0x15, 0x00, 0x00, 0xff, 0xff, 0xd0, 0xf1, 0x2d, 0x90, 0xcd, 0x13, 0x00, 0x00,
}

func (m *DocumentAttributeAudio) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DocumentAttributeAudio) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DocumentAttributeAudio) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Waveform != nil {
		i -= len(m.Waveform)
		copy(dAtA[i:], m.Waveform)
		i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.Waveform)))
		i--
		dAtA[i] = 0x32
	}
	i -= len(m.Album)
	copy(dAtA[i:], m.Album)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.Album)))
	i--
	dAtA[i] = 0x2a
	i -= len(m.Performer)
	copy(dAtA[i:], m.Performer)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.Performer)))
	i--
	dAtA[i] = 0x22
	i -= len(m.Title)
	copy(dAtA[i:], m.Title)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.Title)))
	i--
	dAtA[i] = 0x1a
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(m.Duration))
	i--
	dAtA[i] = 0x10
	i--
	if m.Voice {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *DocumentAttributeVideo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DocumentAttributeVideo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DocumentAttributeVideo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.Round {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x20
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(m.Duration))
	i--
	dAtA[i] = 0x18
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(m.Height))
	i--
	dAtA[i] = 0x10
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(m.Width))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *DocumentAttributePhoto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DocumentAttributePhoto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DocumentAttributePhoto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(m.Height))
	i--
	dAtA[i] = 0x10
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(m.Width))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *DocumentAttributeFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DocumentAttributeFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DocumentAttributeFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Filename)
	copy(dAtA[i:], m.Filename)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.Filename)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DocumentAttributeAnimated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DocumentAttributeAnimated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DocumentAttributeAnimated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *DocumentAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DocumentAttribute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DocumentAttribute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *Document) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Document) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Document) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.MD5Checksum)
	copy(dAtA[i:], m.MD5Checksum)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.MD5Checksum)))
	i--
	dAtA[i] = 0x52
	if m.Thumbnail != nil {
		{
			size, err := m.Thumbnail.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(m.ClusterID))
	i--
	dAtA[i] = 0x38
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(m.Version))
	i--
	dAtA[i] = 0x30
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(m.FileSize))
	i--
	dAtA[i] = 0x28
	i -= len(m.MimeType)
	copy(dAtA[i:], m.MimeType)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.MimeType)))
	i--
	dAtA[i] = 0x22
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(m.Date))
	i--
	dAtA[i] = 0x18
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i--
	dAtA[i] = 0x11
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(m.ID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *InputMediaInvoice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMediaInvoice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InputMediaInvoice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MediaInvoice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MediaInvoice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MediaInvoice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *InputMediaWebDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMediaWebDocument) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InputMediaWebDocument) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	i -= len(m.MimeType)
	copy(dAtA[i:], m.MimeType)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.MimeType)))
	i--
	dAtA[i] = 0x1a
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(m.DocSize))
	i--
	dAtA[i] = 0x10
	i -= len(m.Url)
	copy(dAtA[i:], m.Url)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.Url)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MediaWebDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MediaWebDocument) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MediaWebDocument) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i--
	dAtA[i] = 0x29
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	i -= len(m.MimeType)
	copy(dAtA[i:], m.MimeType)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.MimeType)))
	i--
	dAtA[i] = 0x1a
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(m.DocSize))
	i--
	dAtA[i] = 0x10
	i -= len(m.Url)
	copy(dAtA[i:], m.Url)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.Url)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MediaWebPage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MediaWebPage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MediaWebPage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *InputMediaContact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMediaContact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InputMediaContact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.VCard)
	copy(dAtA[i:], m.VCard)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.VCard)))
	i--
	dAtA[i] = 0x22
	i -= len(m.LastName)
	copy(dAtA[i:], m.LastName)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.LastName)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.FirstName)
	copy(dAtA[i:], m.FirstName)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.FirstName)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Phone)
	copy(dAtA[i:], m.Phone)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.Phone)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MediaContact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MediaContact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MediaContact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.VCard)
	copy(dAtA[i:], m.VCard)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.VCard)))
	i--
	dAtA[i] = 0x22
	i -= len(m.LastName)
	copy(dAtA[i:], m.LastName)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.LastName)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.FirstName)
	copy(dAtA[i:], m.FirstName)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.FirstName)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Phone)
	copy(dAtA[i:], m.Phone)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.Phone)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *InputMediaUploadedDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMediaUploadedDocument) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InputMediaUploadedDocument) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entities) > 0 {
		for iNdEx := len(m.Entities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Stickers) > 0 {
		for iNdEx := len(m.Stickers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Stickers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	i -= len(m.Caption)
	copy(dAtA[i:], m.Caption)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.Caption)))
	i--
	dAtA[i] = 0x22
	i -= len(m.MimeType)
	copy(dAtA[i:], m.MimeType)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.MimeType)))
	i--
	dAtA[i] = 0x1a
	if m.Thumbnail != nil {
		{
			size, err := m.Thumbnail.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.File == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("File")
	} else {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InputMediaDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMediaDocument) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InputMediaDocument) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Thumbnail != nil {
		{
			size, err := m.Thumbnail.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Entities) > 0 {
		for iNdEx := len(m.Entities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Document == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("Document")
	} else {
		{
			size, err := m.Document.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	i -= len(m.Caption)
	copy(dAtA[i:], m.Caption)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.Caption)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *InputMediaUploadedSealedDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMediaUploadedSealedDocument) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InputMediaUploadedSealedDocument) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entities) > 0 {
		for iNdEx := len(m.Entities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	i -= len(m.EncryptedCaption)
	copy(dAtA[i:], m.EncryptedCaption)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.EncryptedCaption)))
	i--
	dAtA[i] = 0x22
	i -= len(m.EncryptedMimeType)
	copy(dAtA[i:], m.EncryptedMimeType)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.EncryptedMimeType)))
	i--
	dAtA[i] = 0x1a
	if m.SealedThumbnail != nil {
		{
			size, err := m.SealedThumbnail.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SealedFile == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("SealedFile")
	} else {
		{
			size, err := m.SealedFile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MediaSealedDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MediaSealedDocument) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MediaSealedDocument) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EncryptedMediaDocument != nil {
		i -= len(m.EncryptedMediaDocument)
		copy(dAtA[i:], m.EncryptedMediaDocument)
		i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.EncryptedMediaDocument)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InputMediaMessageDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMediaMessageDocument) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InputMediaMessageDocument) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entities) > 0 {
		for iNdEx := len(m.Entities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	i -= len(m.Caption)
	copy(dAtA[i:], m.Caption)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.Caption)))
	i--
	dAtA[i] = 0x1a
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(m.MessageID))
	i--
	dAtA[i] = 0x10
	if m.Peer == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("Peer")
	} else {
		{
			size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MediaDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MediaDocument) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MediaDocument) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entities) > 0 {
		for iNdEx := len(m.Entities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Doc == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("Doc")
	} else {
		{
			size, err := m.Doc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(m.TTLinSeconds))
	i--
	dAtA[i] = 0x10
	i -= len(m.Caption)
	copy(dAtA[i:], m.Caption)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.Caption)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *InputMediaGeoLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMediaGeoLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InputMediaGeoLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entities) > 0 {
		for iNdEx := len(m.Entities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	i -= len(m.Caption)
	copy(dAtA[i:], m.Caption)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.Caption)))
	i--
	dAtA[i] = 0x1a
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Long))))
	i--
	dAtA[i] = 0x15
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Lat))))
	i--
	dAtA[i] = 0xd
	return len(dAtA) - i, nil
}

func (m *MediaGeoLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MediaGeoLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MediaGeoLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entities) > 0 {
		for iNdEx := len(m.Entities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	i -= len(m.Caption)
	copy(dAtA[i:], m.Caption)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.Caption)))
	i--
	dAtA[i] = 0x1a
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Long))))
	i--
	dAtA[i] = 0x15
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Lat))))
	i--
	dAtA[i] = 0xd
	return len(dAtA) - i, nil
}

func (m *InputMediaPoll) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMediaPoll) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InputMediaPoll) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Poll == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("Poll")
	} else {
		{
			size, err := m.Poll.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MediaPoll) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MediaPoll) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MediaPoll) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Answers) > 0 {
		for iNdEx := len(m.Answers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Answers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	i -= len(m.Question)
	copy(dAtA[i:], m.Question)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.Question)))
	i--
	dAtA[i] = 0x32
	i--
	if m.Quiz {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x28
	i--
	if m.MultiChoice {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x20
	i--
	if m.PublicVoters {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	i--
	if m.Closed {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(m.ID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *PollAnswer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PollAnswer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PollAnswer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Option != nil {
		i -= len(m.Option)
		copy(dAtA[i:], m.Option)
		i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.Option)))
		i--
		dAtA[i] = 0x12
	}
	i -= len(m.Text)
	copy(dAtA[i:], m.Text)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.Text)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PollResults) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PollResults) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PollResults) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(m.TotalVoters))
	i--
	dAtA[i] = 0x10
	if len(m.Results) > 0 {
		for iNdEx := len(m.Results) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Results[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PollAnswerVoters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PollAnswerVoters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PollAnswerVoters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(m.Voters))
	i--
	dAtA[i] = 0x20
	if m.Option != nil {
		i -= len(m.Option)
		copy(dAtA[i:], m.Option)
		i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.Option)))
		i--
		dAtA[i] = 0x1a
	}
	i--
	if m.Correct {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	i--
	if m.Chosen {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *InputMediaSealed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMediaSealed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InputMediaSealed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entities) > 0 {
		for iNdEx := len(m.Entities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	i -= len(m.EncryptedBody)
	copy(dAtA[i:], m.EncryptedBody)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.EncryptedBody)))
	i--
	dAtA[i] = 0x1a
	if m.EncryptedMedia != nil {
		i -= len(m.EncryptedMedia)
		copy(dAtA[i:], m.EncryptedMedia)
		i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.EncryptedMedia)))
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(m.MediaType))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *MediaSealed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MediaSealed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MediaSealed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entities) > 0 {
		for iNdEx := len(m.Entities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatMessagesMedias(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	i -= len(m.Body)
	copy(dAtA[i:], m.Body)
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.Body)))
	i--
	dAtA[i] = 0x1a
	if m.Media != nil {
		i -= len(m.Media)
		copy(dAtA[i:], m.Media)
		i = encodeVarintChatMessagesMedias(dAtA, i, uint64(len(m.Media)))
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintChatMessagesMedias(dAtA, i, uint64(m.MediaType))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func encodeVarintChatMessagesMedias(dAtA []byte, offset int, v uint64) int {
	offset -= sovChatMessagesMedias(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DocumentAttributeAudio) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	n += 1 + sovChatMessagesMedias(uint64(m.Duration))
	l = len(m.Title)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	l = len(m.Performer)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	l = len(m.Album)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	if m.Waveform != nil {
		l = len(m.Waveform)
		n += 1 + l + sovChatMessagesMedias(uint64(l))
	}
	return n
}

func (m *DocumentAttributeVideo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatMessagesMedias(uint64(m.Width))
	n += 1 + sovChatMessagesMedias(uint64(m.Height))
	n += 1 + sovChatMessagesMedias(uint64(m.Duration))
	n += 2
	return n
}

func (m *DocumentAttributePhoto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatMessagesMedias(uint64(m.Width))
	n += 1 + sovChatMessagesMedias(uint64(m.Height))
	return n
}

func (m *DocumentAttributeFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Filename)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	return n
}

func (m *DocumentAttributeAnimated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DocumentAttribute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatMessagesMedias(uint64(m.Type))
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovChatMessagesMedias(uint64(l))
	}
	return n
}

func (m *Document) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatMessagesMedias(uint64(m.ID))
	n += 9
	n += 1 + sovChatMessagesMedias(uint64(m.Date))
	l = len(m.MimeType)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	n += 1 + sovChatMessagesMedias(uint64(m.FileSize))
	n += 1 + sovChatMessagesMedias(uint64(m.Version))
	n += 1 + sovChatMessagesMedias(uint64(m.ClusterID))
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovChatMessagesMedias(uint64(l))
		}
	}
	if m.Thumbnail != nil {
		l = m.Thumbnail.Size()
		n += 1 + l + sovChatMessagesMedias(uint64(l))
	}
	l = len(m.MD5Checksum)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	return n
}

func (m *InputMediaInvoice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MediaInvoice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *InputMediaWebDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	n += 1 + sovChatMessagesMedias(uint64(m.DocSize))
	l = len(m.MimeType)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovChatMessagesMedias(uint64(l))
		}
	}
	return n
}

func (m *MediaWebDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	n += 1 + sovChatMessagesMedias(uint64(m.DocSize))
	l = len(m.MimeType)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovChatMessagesMedias(uint64(l))
		}
	}
	n += 9
	return n
}

func (m *MediaWebPage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *InputMediaContact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Phone)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	l = len(m.FirstName)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	l = len(m.LastName)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	l = len(m.VCard)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	return n
}

func (m *MediaContact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Phone)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	l = len(m.FirstName)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	l = len(m.LastName)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	l = len(m.VCard)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	return n
}

func (m *InputMediaUploadedDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovChatMessagesMedias(uint64(l))
	}
	if m.Thumbnail != nil {
		l = m.Thumbnail.Size()
		n += 1 + l + sovChatMessagesMedias(uint64(l))
	}
	l = len(m.MimeType)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	l = len(m.Caption)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	if len(m.Stickers) > 0 {
		for _, e := range m.Stickers {
			l = e.Size()
			n += 1 + l + sovChatMessagesMedias(uint64(l))
		}
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovChatMessagesMedias(uint64(l))
		}
	}
	if len(m.Entities) > 0 {
		for _, e := range m.Entities {
			l = e.Size()
			n += 1 + l + sovChatMessagesMedias(uint64(l))
		}
	}
	return n
}

func (m *InputMediaDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Caption)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	if m.Document != nil {
		l = m.Document.Size()
		n += 1 + l + sovChatMessagesMedias(uint64(l))
	}
	if len(m.Entities) > 0 {
		for _, e := range m.Entities {
			l = e.Size()
			n += 1 + l + sovChatMessagesMedias(uint64(l))
		}
	}
	if m.Thumbnail != nil {
		l = m.Thumbnail.Size()
		n += 1 + l + sovChatMessagesMedias(uint64(l))
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovChatMessagesMedias(uint64(l))
		}
	}
	return n
}

func (m *InputMediaUploadedSealedDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SealedFile != nil {
		l = m.SealedFile.Size()
		n += 1 + l + sovChatMessagesMedias(uint64(l))
	}
	if m.SealedThumbnail != nil {
		l = m.SealedThumbnail.Size()
		n += 1 + l + sovChatMessagesMedias(uint64(l))
	}
	l = len(m.EncryptedMimeType)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	l = len(m.EncryptedCaption)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovChatMessagesMedias(uint64(l))
		}
	}
	if len(m.Entities) > 0 {
		for _, e := range m.Entities {
			l = e.Size()
			n += 1 + l + sovChatMessagesMedias(uint64(l))
		}
	}
	return n
}

func (m *MediaSealedDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EncryptedMediaDocument != nil {
		l = len(m.EncryptedMediaDocument)
		n += 1 + l + sovChatMessagesMedias(uint64(l))
	}
	return n
}

func (m *InputMediaMessageDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovChatMessagesMedias(uint64(l))
	}
	n += 1 + sovChatMessagesMedias(uint64(m.MessageID))
	l = len(m.Caption)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	if len(m.Entities) > 0 {
		for _, e := range m.Entities {
			l = e.Size()
			n += 1 + l + sovChatMessagesMedias(uint64(l))
		}
	}
	return n
}

func (m *MediaDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Caption)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	n += 1 + sovChatMessagesMedias(uint64(m.TTLinSeconds))
	if m.Doc != nil {
		l = m.Doc.Size()
		n += 1 + l + sovChatMessagesMedias(uint64(l))
	}
	if len(m.Entities) > 0 {
		for _, e := range m.Entities {
			l = e.Size()
			n += 1 + l + sovChatMessagesMedias(uint64(l))
		}
	}
	return n
}

func (m *InputMediaGeoLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	n += 5
	l = len(m.Caption)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	if len(m.Entities) > 0 {
		for _, e := range m.Entities {
			l = e.Size()
			n += 1 + l + sovChatMessagesMedias(uint64(l))
		}
	}
	return n
}

func (m *MediaGeoLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	n += 5
	l = len(m.Caption)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	if len(m.Entities) > 0 {
		for _, e := range m.Entities {
			l = e.Size()
			n += 1 + l + sovChatMessagesMedias(uint64(l))
		}
	}
	return n
}

func (m *InputMediaPoll) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Poll != nil {
		l = m.Poll.Size()
		n += 1 + l + sovChatMessagesMedias(uint64(l))
	}
	return n
}

func (m *MediaPoll) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatMessagesMedias(uint64(m.ID))
	n += 2
	n += 2
	n += 2
	n += 2
	l = len(m.Question)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	if len(m.Answers) > 0 {
		for _, e := range m.Answers {
			l = e.Size()
			n += 1 + l + sovChatMessagesMedias(uint64(l))
		}
	}
	return n
}

func (m *PollAnswer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	if m.Option != nil {
		l = len(m.Option)
		n += 1 + l + sovChatMessagesMedias(uint64(l))
	}
	return n
}

func (m *PollResults) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovChatMessagesMedias(uint64(l))
		}
	}
	n += 1 + sovChatMessagesMedias(uint64(m.TotalVoters))
	return n
}

func (m *PollAnswerVoters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	n += 2
	if m.Option != nil {
		l = len(m.Option)
		n += 1 + l + sovChatMessagesMedias(uint64(l))
	}
	n += 1 + sovChatMessagesMedias(uint64(m.Voters))
	return n
}

func (m *InputMediaSealed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatMessagesMedias(uint64(m.MediaType))
	if m.EncryptedMedia != nil {
		l = len(m.EncryptedMedia)
		n += 1 + l + sovChatMessagesMedias(uint64(l))
	}
	l = len(m.EncryptedBody)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	if len(m.Entities) > 0 {
		for _, e := range m.Entities {
			l = e.Size()
			n += 1 + l + sovChatMessagesMedias(uint64(l))
		}
	}
	return n
}

func (m *MediaSealed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatMessagesMedias(uint64(m.MediaType))
	if m.Media != nil {
		l = len(m.Media)
		n += 1 + l + sovChatMessagesMedias(uint64(l))
	}
	l = len(m.Body)
	n += 1 + l + sovChatMessagesMedias(uint64(l))
	if len(m.Entities) > 0 {
		for _, e := range m.Entities {
			l = e.Size()
			n += 1 + l + sovChatMessagesMedias(uint64(l))
		}
	}
	return n
}

func sovChatMessagesMedias(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozChatMessagesMedias(x uint64) (n int) {
	return sovChatMessagesMedias(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DocumentAttributeAudio) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocumentAttributeAudio: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocumentAttributeAudio: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voice", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Voice = bool(v != 0)
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Performer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Performer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Album", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Album = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Waveform", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Waveform = append(m.Waveform[:0], dAtA[iNdEx:postIndex]...)
			if m.Waveform == nil {
				m.Waveform = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Voice")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Duration")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Title")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Performer")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Album")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentAttributeVideo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocumentAttributeVideo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocumentAttributeVideo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Round = bool(v != 0)
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Width")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Height")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Duration")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Round")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentAttributePhoto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocumentAttributePhoto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocumentAttributePhoto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Width")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Height")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentAttributeFile) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocumentAttributeFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocumentAttributeFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Filename")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentAttributeAnimated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocumentAttributeAnimated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocumentAttributeAnimated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentAttribute) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocumentAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocumentAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= DocumentAttributeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Type")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Document) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Document: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Document: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000040)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &DocumentAttribute{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumbnail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Thumbnail == nil {
				m.Thumbnail = &FileLocation{}
			}
			if err := m.Thumbnail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MD5Checksum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MD5Checksum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Date")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MimeType")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FileSize")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Version")
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ClusterID")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMediaInvoice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMediaInvoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMediaInvoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MediaInvoice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MediaInvoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MediaInvoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMediaWebDocument) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMediaWebDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMediaWebDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocSize", wireType)
			}
			m.DocSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DocSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &DocumentAttribute{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Url")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("DocSize")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MimeType")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MediaWebDocument) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MediaWebDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MediaWebDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocSize", wireType)
			}
			m.DocSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DocSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &DocumentAttribute{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Url")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("DocSize")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MimeType")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MediaWebPage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MediaWebPage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MediaWebPage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMediaContact) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMediaContact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMediaContact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VCard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VCard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Phone")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FirstName")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("LastName")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MediaContact) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MediaContact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MediaContact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VCard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VCard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Phone")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FirstName")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("LastName")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMediaUploadedDocument) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMediaUploadedDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMediaUploadedDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &InputFile{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumbnail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Thumbnail == nil {
				m.Thumbnail = &InputFile{}
			}
			if err := m.Thumbnail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stickers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stickers = append(m.Stickers, &InputDocument{})
			if err := m.Stickers[len(m.Stickers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &DocumentAttribute{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, &MessageEntity{})
			if err := m.Entities[len(m.Entities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("File")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MimeType")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Caption")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMediaDocument) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMediaDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMediaDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Document", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Document == nil {
				m.Document = &InputDocument{}
			}
			if err := m.Document.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, &MessageEntity{})
			if err := m.Entities[len(m.Entities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumbnail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Thumbnail == nil {
				m.Thumbnail = &InputFile{}
			}
			if err := m.Thumbnail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &DocumentAttribute{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Caption")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Document")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMediaUploadedSealedDocument) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMediaUploadedSealedDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMediaUploadedSealedDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SealedFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SealedFile == nil {
				m.SealedFile = &InputFile{}
			}
			if err := m.SealedFile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SealedThumbnail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SealedThumbnail == nil {
				m.SealedThumbnail = &InputFile{}
			}
			if err := m.SealedThumbnail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedMimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedMimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedCaption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedCaption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &DocumentAttribute{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, &MessageEntity{})
			if err := m.Entities[len(m.Entities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("SealedFile")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("EncryptedMimeType")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("EncryptedCaption")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MediaSealedDocument) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MediaSealedDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MediaSealedDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedMediaDocument", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedMediaDocument = append(m.EncryptedMediaDocument[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedMediaDocument == nil {
				m.EncryptedMediaDocument = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("EncryptedMediaDocument")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMediaMessageDocument) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMediaMessageDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMediaMessageDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &InputPeer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageID", wireType)
			}
			m.MessageID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, &MessageEntity{})
			if err := m.Entities[len(m.Entities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Peer")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MessageID")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Caption")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MediaDocument) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MediaDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MediaDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTLinSeconds", wireType)
			}
			m.TTLinSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTLinSeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Doc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Doc == nil {
				m.Doc = &Document{}
			}
			if err := m.Doc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, &MessageEntity{})
			if err := m.Entities[len(m.Entities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Doc")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMediaGeoLocation) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMediaGeoLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMediaGeoLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lat", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Lat = float32(math.Float32frombits(v))
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Long", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Long = float32(math.Float32frombits(v))
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, &MessageEntity{})
			if err := m.Entities[len(m.Entities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Lat")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Long")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MediaGeoLocation) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MediaGeoLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MediaGeoLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lat", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Lat = float32(math.Float32frombits(v))
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Long", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Long = float32(math.Float32frombits(v))
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, &MessageEntity{})
			if err := m.Entities[len(m.Entities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Lat")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Long")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMediaPoll) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMediaPoll: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMediaPoll: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poll", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Poll == nil {
				m.Poll = &MediaPoll{}
			}
			if err := m.Poll.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Poll")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MediaPoll) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MediaPoll: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MediaPoll: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Closed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Closed = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicVoters", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PublicVoters = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiChoice", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MultiChoice = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quiz", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Quiz = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Question", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Question = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Answers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Answers = append(m.Answers, &PollAnswer{})
			if err := m.Answers[len(m.Answers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Question")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PollAnswer) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PollAnswer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PollAnswer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Option = append(m.Option[:0], dAtA[iNdEx:postIndex]...)
			if m.Option == nil {
				m.Option = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Text")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Option")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PollResults) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PollResults: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PollResults: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &PollAnswerVoters{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalVoters", wireType)
			}
			m.TotalVoters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalVoters |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("TotalVoters")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PollAnswerVoters) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PollAnswerVoters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PollAnswerVoters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chosen", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Chosen = bool(v != 0)
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Correct", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Correct = bool(v != 0)
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Option = append(m.Option[:0], dAtA[iNdEx:postIndex]...)
			if m.Option == nil {
				m.Option = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voters", wireType)
			}
			m.Voters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Voters |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Chosen")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Correct")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Option")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Voters")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMediaSealed) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMediaSealed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMediaSealed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaType", wireType)
			}
			m.MediaType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MediaType |= InputMediaType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedMedia", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedMedia = append(m.EncryptedMedia[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedMedia == nil {
				m.EncryptedMedia = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedBody", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedBody = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, &MessageEntity{})
			if err := m.Entities[len(m.Entities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MediaType")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MediaSealed) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MediaSealed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MediaSealed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaType", wireType)
			}
			m.MediaType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MediaType |= MediaType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Media = append(m.Media[:0], dAtA[iNdEx:postIndex]...)
			if m.Media == nil {
				m.Media = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, &MessageEntity{})
			if err := m.Entities[len(m.Entities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessagesMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessagesMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MediaType")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipChatMessagesMedias(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowChatMessagesMedias
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChatMessagesMedias
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthChatMessagesMedias
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupChatMessagesMedias
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthChatMessagesMedias
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthChatMessagesMedias        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowChatMessagesMedias          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupChatMessagesMedias = fmt.Errorf("proto: unexpected end of group")
)

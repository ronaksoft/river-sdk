// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: chat.core.types.proto

package msg

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TypingAction
type TypingAction int32

const (
	TypingActionTyping         TypingAction = 0
	TypingActionRecordingVoice TypingAction = 1
	TypingActionRecordingVideo TypingAction = 2
	TypingActionUploading      TypingAction = 3
	TypingActionCancel         TypingAction = 4
)

var TypingAction_name = map[int32]string{
	0: "TypingActionTyping",
	1: "TypingActionRecordingVoice",
	2: "TypingActionRecordingVideo",
	3: "TypingActionUploading",
	4: "TypingActionCancel",
}

var TypingAction_value = map[string]int32{
	"TypingActionTyping":         0,
	"TypingActionRecordingVoice": 1,
	"TypingActionRecordingVideo": 2,
	"TypingActionUploading":      3,
	"TypingActionCancel":         4,
}

func (x TypingAction) Enum() *TypingAction {
	p := new(TypingAction)
	*p = x
	return p
}

func (x TypingAction) String() string {
	return proto.EnumName(TypingAction_name, int32(x))
}

func (x *TypingAction) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TypingAction_value, data, "TypingAction")
	if err != nil {
		return err
	}
	*x = TypingAction(value)
	return nil
}

func (TypingAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{0}
}

// PeerType
type PeerType int32

const (
	PeerSelf       PeerType = 0
	PeerUser       PeerType = 1
	PeerGroup      PeerType = 2
	PeerSuperGroup PeerType = 3
	PeerChannel    PeerType = 4
)

var PeerType_name = map[int32]string{
	0: "PeerSelf",
	1: "PeerUser",
	2: "PeerGroup",
	3: "PeerSuperGroup",
	4: "PeerChannel",
}

var PeerType_value = map[string]int32{
	"PeerSelf":       0,
	"PeerUser":       1,
	"PeerGroup":      2,
	"PeerSuperGroup": 3,
	"PeerChannel":    4,
}

func (x PeerType) Enum() *PeerType {
	p := new(PeerType)
	*p = x
	return p
}

func (x PeerType) String() string {
	return proto.EnumName(PeerType_name, int32(x))
}

func (x *PeerType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PeerType_value, data, "PeerType")
	if err != nil {
		return err
	}
	*x = PeerType(value)
	return nil
}

func (PeerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{1}
}

// UserStatus
type UserStatus int32

const (
	UserStatusOffline   UserStatus = 0
	UserStatusOnline    UserStatus = 1
	UserStatusRecently  UserStatus = 2
	UserStatusLastWeek  UserStatus = 3
	UserStatusLastMonth UserStatus = 4
)

var UserStatus_name = map[int32]string{
	0: "UserStatusOffline",
	1: "UserStatusOnline",
	2: "UserStatusRecently",
	3: "UserStatusLastWeek",
	4: "UserStatusLastMonth",
}

var UserStatus_value = map[string]int32{
	"UserStatusOffline":   0,
	"UserStatusOnline":    1,
	"UserStatusRecently":  2,
	"UserStatusLastWeek":  3,
	"UserStatusLastMonth": 4,
}

func (x UserStatus) Enum() *UserStatus {
	p := new(UserStatus)
	*p = x
	return p
}

func (x UserStatus) String() string {
	return proto.EnumName(UserStatus_name, int32(x))
}

func (x *UserStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(UserStatus_value, data, "UserStatus")
	if err != nil {
		return err
	}
	*x = UserStatus(value)
	return nil
}

func (UserStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{2}
}

// MediaType
type MediaType int32

const (
	MediaTypeEmpty       MediaType = 0
	MediaTypePoll        MediaType = 1
	MediaTypeDocument    MediaType = 2
	MediaTypeContact     MediaType = 3
	MediaTypeGeoLocation MediaType = 4
	MediaTypeInvoice     MediaType = 5
	MediaTypeWebDocument MediaType = 6
	MediaTypeReserved2   MediaType = 7
	MediaTypeReserved3   MediaType = 8
	MediaTypeReserved4   MediaType = 9
	MediaTypeReserved5   MediaType = 10
)

var MediaType_name = map[int32]string{
	0:  "MediaTypeEmpty",
	1:  "MediaTypePoll",
	2:  "MediaTypeDocument",
	3:  "MediaTypeContact",
	4:  "MediaTypeGeoLocation",
	5:  "MediaTypeInvoice",
	6:  "MediaTypeWebDocument",
	7:  "MediaTypeReserved2",
	8:  "MediaTypeReserved3",
	9:  "MediaTypeReserved4",
	10: "MediaTypeReserved5",
}

var MediaType_value = map[string]int32{
	"MediaTypeEmpty":       0,
	"MediaTypePoll":        1,
	"MediaTypeDocument":    2,
	"MediaTypeContact":     3,
	"MediaTypeGeoLocation": 4,
	"MediaTypeInvoice":     5,
	"MediaTypeWebDocument": 6,
	"MediaTypeReserved2":   7,
	"MediaTypeReserved3":   8,
	"MediaTypeReserved4":   9,
	"MediaTypeReserved5":   10,
}

func (x MediaType) Enum() *MediaType {
	p := new(MediaType)
	*p = x
	return p
}

func (x MediaType) String() string {
	return proto.EnumName(MediaType_name, int32(x))
}

func (x *MediaType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MediaType_value, data, "MediaType")
	if err != nil {
		return err
	}
	*x = MediaType(value)
	return nil
}

func (MediaType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{3}
}

type InputMediaType int32

const (
	InputMediaTypeEmpty            InputMediaType = 0
	InputMediaTypeInvoice          InputMediaType = 1
	InputMediaTypePoll             InputMediaType = 2
	InputMediaTypeContact          InputMediaType = 3
	InputMediaTypeUploadedDocument InputMediaType = 4
	InputMediaTypeDocument         InputMediaType = 5
	InputMediaTypeGeoLocation      InputMediaType = 6
	InputMediaTypeWebDocument      InputMediaType = 7
	InputMediaTypeReserved2        InputMediaType = 8
	InputMediaTypeReserved3        InputMediaType = 9
	InputMediaTypeReserved4        InputMediaType = 10
	InputMediaTypeReserved5        InputMediaType = 11
	InputMediaTypeReserved6        InputMediaType = 12
	InputMediaTypeReserved7        InputMediaType = 13
	InputMediaTypeReserved8        InputMediaType = 14
)

var InputMediaType_name = map[int32]string{
	0:  "InputMediaTypeEmpty",
	1:  "InputMediaTypeInvoice",
	2:  "InputMediaTypePoll",
	3:  "InputMediaTypeContact",
	4:  "InputMediaTypeUploadedDocument",
	5:  "InputMediaTypeDocument",
	6:  "InputMediaTypeGeoLocation",
	7:  "InputMediaTypeWebDocument",
	8:  "InputMediaTypeReserved2",
	9:  "InputMediaTypeReserved3",
	10: "InputMediaTypeReserved4",
	11: "InputMediaTypeReserved5",
	12: "InputMediaTypeReserved6",
	13: "InputMediaTypeReserved7",
	14: "InputMediaTypeReserved8",
}

var InputMediaType_value = map[string]int32{
	"InputMediaTypeEmpty":            0,
	"InputMediaTypeInvoice":          1,
	"InputMediaTypePoll":             2,
	"InputMediaTypeContact":          3,
	"InputMediaTypeUploadedDocument": 4,
	"InputMediaTypeDocument":         5,
	"InputMediaTypeGeoLocation":      6,
	"InputMediaTypeWebDocument":      7,
	"InputMediaTypeReserved2":        8,
	"InputMediaTypeReserved3":        9,
	"InputMediaTypeReserved4":        10,
	"InputMediaTypeReserved5":        11,
	"InputMediaTypeReserved6":        12,
	"InputMediaTypeReserved7":        13,
	"InputMediaTypeReserved8":        14,
}

func (x InputMediaType) Enum() *InputMediaType {
	p := new(InputMediaType)
	*p = x
	return p
}

func (x InputMediaType) String() string {
	return proto.EnumName(InputMediaType_name, int32(x))
}

func (x *InputMediaType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(InputMediaType_value, data, "InputMediaType")
	if err != nil {
		return err
	}
	*x = InputMediaType(value)
	return nil
}

func (InputMediaType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{4}
}

// MessageEntityType
type MessageEntityType int32

const (
	MessageEntityTypeBold       MessageEntityType = 0
	MessageEntityTypeItalic     MessageEntityType = 1
	MessageEntityTypeMention    MessageEntityType = 2
	MessageEntityTypeUrl        MessageEntityType = 3
	MessageEntityTypeEmail      MessageEntityType = 4
	MessageEntityTypeHashTag    MessageEntityType = 5
	MessageEntityTypeCode       MessageEntityType = 6
	MessageEntityTypeBotCommand MessageEntityType = 7
	MessageEntityTypeReserved3  MessageEntityType = 8
	MessageEntityTypeReserved4  MessageEntityType = 9
	MessageEntityTypeReserved5  MessageEntityType = 10
	MessageEntityTypeReserved6  MessageEntityType = 11
	MessageEntityTypeReserved7  MessageEntityType = 12
	MessageEntityTypeReserved8  MessageEntityType = 13
)

var MessageEntityType_name = map[int32]string{
	0:  "MessageEntityTypeBold",
	1:  "MessageEntityTypeItalic",
	2:  "MessageEntityTypeMention",
	3:  "MessageEntityTypeUrl",
	4:  "MessageEntityTypeEmail",
	5:  "MessageEntityTypeHashTag",
	6:  "MessageEntityTypeCode",
	7:  "MessageEntityTypeBotCommand",
	8:  "MessageEntityTypeReserved3",
	9:  "MessageEntityTypeReserved4",
	10: "MessageEntityTypeReserved5",
	11: "MessageEntityTypeReserved6",
	12: "MessageEntityTypeReserved7",
	13: "MessageEntityTypeReserved8",
}

var MessageEntityType_value = map[string]int32{
	"MessageEntityTypeBold":       0,
	"MessageEntityTypeItalic":     1,
	"MessageEntityTypeMention":    2,
	"MessageEntityTypeUrl":        3,
	"MessageEntityTypeEmail":      4,
	"MessageEntityTypeHashTag":    5,
	"MessageEntityTypeCode":       6,
	"MessageEntityTypeBotCommand": 7,
	"MessageEntityTypeReserved3":  8,
	"MessageEntityTypeReserved4":  9,
	"MessageEntityTypeReserved5":  10,
	"MessageEntityTypeReserved6":  11,
	"MessageEntityTypeReserved7":  12,
	"MessageEntityTypeReserved8":  13,
}

func (x MessageEntityType) Enum() *MessageEntityType {
	p := new(MessageEntityType)
	*p = x
	return p
}

func (x MessageEntityType) String() string {
	return proto.EnumName(MessageEntityType_name, int32(x))
}

func (x *MessageEntityType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MessageEntityType_value, data, "MessageEntityType")
	if err != nil {
		return err
	}
	*x = MessageEntityType(value)
	return nil
}

func (MessageEntityType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{5}
}

// GroupFlags
type GroupFlags int32

const (
	GroupFlagsEmpty          GroupFlags = 0
	GroupFlagsCreator        GroupFlags = 1
	GroupFlagsNonParticipant GroupFlags = 2
	GroupFlagsAdmin          GroupFlags = 3
	GroupFlagsAdminsEnabled  GroupFlags = 4
	GroupFlagsDeactivated    GroupFlags = 5
)

var GroupFlags_name = map[int32]string{
	0: "GroupFlagsEmpty",
	1: "GroupFlagsCreator",
	2: "GroupFlagsNonParticipant",
	3: "GroupFlagsAdmin",
	4: "GroupFlagsAdminsEnabled",
	5: "GroupFlagsDeactivated",
}

var GroupFlags_value = map[string]int32{
	"GroupFlagsEmpty":          0,
	"GroupFlagsCreator":        1,
	"GroupFlagsNonParticipant": 2,
	"GroupFlagsAdmin":          3,
	"GroupFlagsAdminsEnabled":  4,
	"GroupFlagsDeactivated":    5,
}

func (x GroupFlags) Enum() *GroupFlags {
	p := new(GroupFlags)
	*p = x
	return p
}

func (x GroupFlags) String() string {
	return proto.EnumName(GroupFlags_name, int32(x))
}

func (x *GroupFlags) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GroupFlags_value, data, "GroupFlags")
	if err != nil {
		return err
	}
	*x = GroupFlags(value)
	return nil
}

func (GroupFlags) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{6}
}

// ParticipantType
type ParticipantType int32

const (
	ParticipantTypeMember  ParticipantType = 0
	ParticipantTypeAdmin   ParticipantType = 1
	ParticipantTypeCreator ParticipantType = 2
)

var ParticipantType_name = map[int32]string{
	0: "ParticipantTypeMember",
	1: "ParticipantTypeAdmin",
	2: "ParticipantTypeCreator",
}

var ParticipantType_value = map[string]int32{
	"ParticipantTypeMember":  0,
	"ParticipantTypeAdmin":   1,
	"ParticipantTypeCreator": 2,
}

func (x ParticipantType) Enum() *ParticipantType {
	p := new(ParticipantType)
	*p = x
	return p
}

func (x ParticipantType) String() string {
	return proto.EnumName(ParticipantType_name, int32(x))
}

func (x *ParticipantType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ParticipantType_value, data, "ParticipantType")
	if err != nil {
		return err
	}
	*x = ParticipantType(value)
	return nil
}

func (ParticipantType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{7}
}

// NotificationType
type PushTokenProvider int32

const (
	PushTokenFirebase PushTokenProvider = 0
	PushTokenApn      PushTokenProvider = 1
	PushTokenPushKit  PushTokenProvider = 2
)

var PushTokenProvider_name = map[int32]string{
	0: "PushTokenFirebase",
	1: "PushTokenApn",
	2: "PushTokenPushKit",
}

var PushTokenProvider_value = map[string]int32{
	"PushTokenFirebase": 0,
	"PushTokenApn":      1,
	"PushTokenPushKit":  2,
}

func (x PushTokenProvider) Enum() *PushTokenProvider {
	p := new(PushTokenProvider)
	*p = x
	return p
}

func (x PushTokenProvider) String() string {
	return proto.EnumName(PushTokenProvider_name, int32(x))
}

func (x *PushTokenProvider) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PushTokenProvider_value, data, "PushTokenProvider")
	if err != nil {
		return err
	}
	*x = PushTokenProvider(value)
	return nil
}

func (PushTokenProvider) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{8}
}

// AccountPrivacyKey
type PrivacyKey int32

const (
	PrivacyKeyNone             PrivacyKey = 0
	PrivacyKeyChatInvite       PrivacyKey = 1
	PrivacyKeyLastSeen         PrivacyKey = 2
	PrivacyKeyPhoneNumber      PrivacyKey = 3
	PrivacyKeyProfilePhoto     PrivacyKey = 4
	PrivacyKeyForwardedMessage PrivacyKey = 5
	PrivacyKeyCall             PrivacyKey = 6
	PrivacyKeyReserved1        PrivacyKey = 7
	PrivacyKeyReserved2        PrivacyKey = 8
	PrivacyKeyReserved3        PrivacyKey = 9
	PrivacyKeyReserved4        PrivacyKey = 10
	PrivacyKeyReserved5        PrivacyKey = 11
	PrivacyKeyReserved6        PrivacyKey = 12
)

var PrivacyKey_name = map[int32]string{
	0:  "PrivacyKeyNone",
	1:  "PrivacyKeyChatInvite",
	2:  "PrivacyKeyLastSeen",
	3:  "PrivacyKeyPhoneNumber",
	4:  "PrivacyKeyProfilePhoto",
	5:  "PrivacyKeyForwardedMessage",
	6:  "PrivacyKeyCall",
	7:  "PrivacyKeyReserved1",
	8:  "PrivacyKeyReserved2",
	9:  "PrivacyKeyReserved3",
	10: "PrivacyKeyReserved4",
	11: "PrivacyKeyReserved5",
	12: "PrivacyKeyReserved6",
}

var PrivacyKey_value = map[string]int32{
	"PrivacyKeyNone":             0,
	"PrivacyKeyChatInvite":       1,
	"PrivacyKeyLastSeen":         2,
	"PrivacyKeyPhoneNumber":      3,
	"PrivacyKeyProfilePhoto":     4,
	"PrivacyKeyForwardedMessage": 5,
	"PrivacyKeyCall":             6,
	"PrivacyKeyReserved1":        7,
	"PrivacyKeyReserved2":        8,
	"PrivacyKeyReserved3":        9,
	"PrivacyKeyReserved4":        10,
	"PrivacyKeyReserved5":        11,
	"PrivacyKeyReserved6":        12,
}

func (x PrivacyKey) Enum() *PrivacyKey {
	p := new(PrivacyKey)
	*p = x
	return p
}

func (x PrivacyKey) String() string {
	return proto.EnumName(PrivacyKey_name, int32(x))
}

func (x *PrivacyKey) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PrivacyKey_value, data, "PrivacyKey")
	if err != nil {
		return err
	}
	*x = PrivacyKey(value)
	return nil
}

func (PrivacyKey) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{9}
}

// AccountPrivacyValue
type PrivacyType int32

const (
	PrivacyTypeAllowAll      PrivacyType = 0
	PrivacyTypeAllowContacts PrivacyType = 1
	PrivacyTypeDisallowAll   PrivacyType = 2
	//    Order is very important, exceptions are started from 101
	PrivacyTypeAllowUsers    PrivacyType = 101
	PrivacyTypeDisallowUsers PrivacyType = 102
)

var PrivacyType_name = map[int32]string{
	0:   "PrivacyTypeAllowAll",
	1:   "PrivacyTypeAllowContacts",
	2:   "PrivacyTypeDisallowAll",
	101: "PrivacyTypeAllowUsers",
	102: "PrivacyTypeDisallowUsers",
}

var PrivacyType_value = map[string]int32{
	"PrivacyTypeAllowAll":      0,
	"PrivacyTypeAllowContacts": 1,
	"PrivacyTypeDisallowAll":   2,
	"PrivacyTypeAllowUsers":    101,
	"PrivacyTypeDisallowUsers": 102,
}

func (x PrivacyType) Enum() *PrivacyType {
	p := new(PrivacyType)
	*p = x
	return p
}

func (x PrivacyType) String() string {
	return proto.EnumName(PrivacyType_name, int32(x))
}

func (x *PrivacyType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PrivacyType_value, data, "PrivacyType")
	if err != nil {
		return err
	}
	*x = PrivacyType(value)
	return nil
}

func (PrivacyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{10}
}

// MessageEnvelope
// This type of message will be used to contain another ProtoBuffer Message inside
type MessageEnvelope struct {
	Constructor int64  `protobuf:"varint,1,req,name=Constructor" json:"Constructor"`
	RequestID   uint64 `protobuf:"fixed64,2,req,name=RequestID" json:"RequestID"`
	Message     []byte `protobuf:"bytes,4,req,name=Message" json:"Message"`
}

func (m *MessageEnvelope) Reset()         { *m = MessageEnvelope{} }
func (m *MessageEnvelope) String() string { return proto.CompactTextString(m) }
func (*MessageEnvelope) ProtoMessage()    {}
func (*MessageEnvelope) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{0}
}
func (m *MessageEnvelope) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageEnvelope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageEnvelope.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageEnvelope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageEnvelope.Merge(m, src)
}
func (m *MessageEnvelope) XXX_Size() int {
	return m.Size()
}
func (m *MessageEnvelope) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageEnvelope.DiscardUnknown(m)
}

var xxx_messageInfo_MessageEnvelope proto.InternalMessageInfo

func (m *MessageEnvelope) GetConstructor() int64 {
	if m != nil {
		return m.Constructor
	}
	return 0
}

func (m *MessageEnvelope) GetRequestID() uint64 {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *MessageEnvelope) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

// MessageContainer
// This type of message will be used to send multi messages inside a single container message
type MessageContainer struct {
	Length    int32              `protobuf:"varint,1,req,name=Length" json:"Length"`
	Envelopes []*MessageEnvelope `protobuf:"bytes,2,rep,name=Envelopes" json:"Envelopes,omitempty"`
}

func (m *MessageContainer) Reset()         { *m = MessageContainer{} }
func (m *MessageContainer) String() string { return proto.CompactTextString(m) }
func (*MessageContainer) ProtoMessage()    {}
func (*MessageContainer) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{1}
}
func (m *MessageContainer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageContainer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageContainer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageContainer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageContainer.Merge(m, src)
}
func (m *MessageContainer) XXX_Size() int {
	return m.Size()
}
func (m *MessageContainer) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageContainer.DiscardUnknown(m)
}

var xxx_messageInfo_MessageContainer proto.InternalMessageInfo

func (m *MessageContainer) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *MessageContainer) GetEnvelopes() []*MessageEnvelope {
	if m != nil {
		return m.Envelopes
	}
	return nil
}

// UpdateEnvelope
type UpdateEnvelope struct {
	Constructor int64  `protobuf:"varint,1,req,name=Constructor" json:"Constructor"`
	Update      []byte `protobuf:"bytes,2,req,name=Update" json:"Update"`
	UCount      int32  `protobuf:"varint,3,req,name=UCount" json:"UCount"`
	UpdateID    int64  `protobuf:"varint,4,req,name=UpdateID" json:"UpdateID"`
	Timestamp   int64  `protobuf:"varint,5,req,name=Timestamp" json:"Timestamp"`
}

func (m *UpdateEnvelope) Reset()         { *m = UpdateEnvelope{} }
func (m *UpdateEnvelope) String() string { return proto.CompactTextString(m) }
func (*UpdateEnvelope) ProtoMessage()    {}
func (*UpdateEnvelope) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{2}
}
func (m *UpdateEnvelope) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateEnvelope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateEnvelope.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateEnvelope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateEnvelope.Merge(m, src)
}
func (m *UpdateEnvelope) XXX_Size() int {
	return m.Size()
}
func (m *UpdateEnvelope) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateEnvelope.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateEnvelope proto.InternalMessageInfo

func (m *UpdateEnvelope) GetConstructor() int64 {
	if m != nil {
		return m.Constructor
	}
	return 0
}

func (m *UpdateEnvelope) GetUpdate() []byte {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *UpdateEnvelope) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateEnvelope) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateEnvelope) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

// UpdateContainer
// It is very similar to MessageContainer but holding a list of Updates
type UpdateContainer struct {
	Length      int32             `protobuf:"varint,1,req,name=Length" json:"Length"`
	Updates     []*UpdateEnvelope `protobuf:"bytes,2,rep,name=Updates" json:"Updates,omitempty"`
	MinUpdateID int64             `protobuf:"varint,3,req,name=MinUpdateID" json:"MinUpdateID"`
	MaxUpdateID int64             `protobuf:"varint,4,req,name=MaxUpdateID" json:"MaxUpdateID"`
	Users       []*User           `protobuf:"bytes,5,rep,name=Users" json:"Users,omitempty"`
	Groups      []*Group          `protobuf:"bytes,6,rep,name=Groups" json:"Groups,omitempty"`
}

func (m *UpdateContainer) Reset()         { *m = UpdateContainer{} }
func (m *UpdateContainer) String() string { return proto.CompactTextString(m) }
func (*UpdateContainer) ProtoMessage()    {}
func (*UpdateContainer) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{3}
}
func (m *UpdateContainer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateContainer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateContainer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateContainer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateContainer.Merge(m, src)
}
func (m *UpdateContainer) XXX_Size() int {
	return m.Size()
}
func (m *UpdateContainer) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateContainer.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateContainer proto.InternalMessageInfo

func (m *UpdateContainer) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *UpdateContainer) GetUpdates() []*UpdateEnvelope {
	if m != nil {
		return m.Updates
	}
	return nil
}

func (m *UpdateContainer) GetMinUpdateID() int64 {
	if m != nil {
		return m.MinUpdateID
	}
	return 0
}

func (m *UpdateContainer) GetMaxUpdateID() int64 {
	if m != nil {
		return m.MaxUpdateID
	}
	return 0
}

func (m *UpdateContainer) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *UpdateContainer) GetGroups() []*Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

// ProtoMessage
// If AuthID == 0 then Payload is a MessageEnvelop otherwise Payload is a ProtoEncryptedPayload
type ProtoMessage struct {
	AuthID     int64  `protobuf:"varint,1,opt,name=AuthID" json:"AuthID"`
	MessageKey []byte `protobuf:"bytes,2,opt,name=MessageKey" json:"MessageKey"`
	Payload    []byte `protobuf:"bytes,3,req,name=Payload" json:"Payload"`
}

func (m *ProtoMessage) Reset()         { *m = ProtoMessage{} }
func (m *ProtoMessage) String() string { return proto.CompactTextString(m) }
func (*ProtoMessage) ProtoMessage()    {}
func (*ProtoMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{4}
}
func (m *ProtoMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtoMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtoMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtoMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtoMessage.Merge(m, src)
}
func (m *ProtoMessage) XXX_Size() int {
	return m.Size()
}
func (m *ProtoMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtoMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ProtoMessage proto.InternalMessageInfo

func (m *ProtoMessage) GetAuthID() int64 {
	if m != nil {
		return m.AuthID
	}
	return 0
}

func (m *ProtoMessage) GetMessageKey() []byte {
	if m != nil {
		return m.MessageKey
	}
	return nil
}

func (m *ProtoMessage) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

// ProtoMessageEncryptedPayload
type ProtoEncryptedPayload struct {
	ServerSalt int64            `protobuf:"varint,1,req,name=ServerSalt" json:"ServerSalt"`
	MessageID  uint64           `protobuf:"varint,2,req,name=MessageID" json:"MessageID"`
	SessionID  int64            `protobuf:"varint,3,req,name=SessionID" json:"SessionID"`
	Envelope   *MessageEnvelope `protobuf:"bytes,4,req,name=Envelope" json:"Envelope,omitempty"`
}

func (m *ProtoEncryptedPayload) Reset()         { *m = ProtoEncryptedPayload{} }
func (m *ProtoEncryptedPayload) String() string { return proto.CompactTextString(m) }
func (*ProtoEncryptedPayload) ProtoMessage()    {}
func (*ProtoEncryptedPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{5}
}
func (m *ProtoEncryptedPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtoEncryptedPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtoEncryptedPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtoEncryptedPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtoEncryptedPayload.Merge(m, src)
}
func (m *ProtoEncryptedPayload) XXX_Size() int {
	return m.Size()
}
func (m *ProtoEncryptedPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtoEncryptedPayload.DiscardUnknown(m)
}

var xxx_messageInfo_ProtoEncryptedPayload proto.InternalMessageInfo

func (m *ProtoEncryptedPayload) GetServerSalt() int64 {
	if m != nil {
		return m.ServerSalt
	}
	return 0
}

func (m *ProtoEncryptedPayload) GetMessageID() uint64 {
	if m != nil {
		return m.MessageID
	}
	return 0
}

func (m *ProtoEncryptedPayload) GetSessionID() int64 {
	if m != nil {
		return m.SessionID
	}
	return 0
}

func (m *ProtoEncryptedPayload) GetEnvelope() *MessageEnvelope {
	if m != nil {
		return m.Envelope
	}
	return nil
}

// Error
type Error struct {
	Code  string `protobuf:"bytes,1,req,name=Code" json:"Code"`
	Items string `protobuf:"bytes,2,req,name=Items" json:"Items"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{6}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(m, src)
}
func (m *Error) XXX_Size() int {
	return m.Size()
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

func (m *Error) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *Error) GetItems() string {
	if m != nil {
		return m.Items
	}
	return ""
}

// Ack
type Ack struct {
	MessageIDs []uint64 `protobuf:"varint,1,rep,name=MessageIDs" json:"MessageIDs,omitempty"`
}

func (m *Ack) Reset()         { *m = Ack{} }
func (m *Ack) String() string { return proto.CompactTextString(m) }
func (*Ack) ProtoMessage()    {}
func (*Ack) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{7}
}
func (m *Ack) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ack) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ack.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ack) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ack.Merge(m, src)
}
func (m *Ack) XXX_Size() int {
	return m.Size()
}
func (m *Ack) XXX_DiscardUnknown() {
	xxx_messageInfo_Ack.DiscardUnknown(m)
}

var xxx_messageInfo_Ack proto.InternalMessageInfo

func (m *Ack) GetMessageIDs() []uint64 {
	if m != nil {
		return m.MessageIDs
	}
	return nil
}

// Bool
type Bool struct {
	Result bool `protobuf:"varint,1,req,name=Result" json:"Result"`
}

func (m *Bool) Reset()         { *m = Bool{} }
func (m *Bool) String() string { return proto.CompactTextString(m) }
func (*Bool) ProtoMessage()    {}
func (*Bool) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{8}
}
func (m *Bool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Bool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Bool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Bool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Bool.Merge(m, src)
}
func (m *Bool) XXX_Size() int {
	return m.Size()
}
func (m *Bool) XXX_DiscardUnknown() {
	xxx_messageInfo_Bool.DiscardUnknown(m)
}

var xxx_messageInfo_Bool proto.InternalMessageInfo

func (m *Bool) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

// Dialog
type Dialog struct {
	PeerID          int64               `protobuf:"varint,1,req,name=PeerID" json:"PeerID"`
	PeerType        int32               `protobuf:"varint,2,req,name=PeerType" json:"PeerType"`
	TopMessageID    int64               `protobuf:"varint,3,req,name=TopMessageID" json:"TopMessageID"`
	ReadInboxMaxID  int64               `protobuf:"varint,4,req,name=ReadInboxMaxID" json:"ReadInboxMaxID"`
	ReadOutboxMaxID int64               `protobuf:"varint,5,req,name=ReadOutboxMaxID" json:"ReadOutboxMaxID"`
	UnreadCount     int32               `protobuf:"varint,6,req,name=UnreadCount" json:"UnreadCount"`
	AccessHash      uint64              `protobuf:"fixed64,7,req,name=AccessHash" json:"AccessHash"`
	NotifySettings  *PeerNotifySettings `protobuf:"bytes,8,opt,name=NotifySettings" json:"NotifySettings,omitempty"`
	MentionedCount  int32               `protobuf:"varint,9,opt,name=MentionedCount" json:"MentionedCount"`
	Pinned          bool                `protobuf:"varint,10,req,name=Pinned" json:"Pinned"`
	Draft           *DraftMessage       `protobuf:"bytes,11,opt,name=Draft" json:"Draft,omitempty"`
}

func (m *Dialog) Reset()         { *m = Dialog{} }
func (m *Dialog) String() string { return proto.CompactTextString(m) }
func (*Dialog) ProtoMessage()    {}
func (*Dialog) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{9}
}
func (m *Dialog) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dialog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dialog.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Dialog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dialog.Merge(m, src)
}
func (m *Dialog) XXX_Size() int {
	return m.Size()
}
func (m *Dialog) XXX_DiscardUnknown() {
	xxx_messageInfo_Dialog.DiscardUnknown(m)
}

var xxx_messageInfo_Dialog proto.InternalMessageInfo

func (m *Dialog) GetPeerID() int64 {
	if m != nil {
		return m.PeerID
	}
	return 0
}

func (m *Dialog) GetPeerType() int32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *Dialog) GetTopMessageID() int64 {
	if m != nil {
		return m.TopMessageID
	}
	return 0
}

func (m *Dialog) GetReadInboxMaxID() int64 {
	if m != nil {
		return m.ReadInboxMaxID
	}
	return 0
}

func (m *Dialog) GetReadOutboxMaxID() int64 {
	if m != nil {
		return m.ReadOutboxMaxID
	}
	return 0
}

func (m *Dialog) GetUnreadCount() int32 {
	if m != nil {
		return m.UnreadCount
	}
	return 0
}

func (m *Dialog) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *Dialog) GetNotifySettings() *PeerNotifySettings {
	if m != nil {
		return m.NotifySettings
	}
	return nil
}

func (m *Dialog) GetMentionedCount() int32 {
	if m != nil {
		return m.MentionedCount
	}
	return 0
}

func (m *Dialog) GetPinned() bool {
	if m != nil {
		return m.Pinned
	}
	return false
}

func (m *Dialog) GetDraft() *DraftMessage {
	if m != nil {
		return m.Draft
	}
	return nil
}

// Peer
type Peer struct {
	ID         int64  `protobuf:"varint,1,req,name=ID" json:"ID"`
	Type       int32  `protobuf:"varint,2,req,name=Type" json:"Type"`
	AccessHash uint64 `protobuf:"fixed64,3,req,name=AccessHash" json:"AccessHash"`
}

func (m *Peer) Reset()         { *m = Peer{} }
func (m *Peer) String() string { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()    {}
func (*Peer) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{10}
}
func (m *Peer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Peer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Peer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Peer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Peer.Merge(m, src)
}
func (m *Peer) XXX_Size() int {
	return m.Size()
}
func (m *Peer) XXX_DiscardUnknown() {
	xxx_messageInfo_Peer.DiscardUnknown(m)
}

var xxx_messageInfo_Peer proto.InternalMessageInfo

func (m *Peer) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Peer) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Peer) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// InputPeer
type InputPeer struct {
	ID         int64    `protobuf:"varint,1,req,name=ID" json:"ID"`
	Type       PeerType `protobuf:"varint,2,req,name=Type,enum=msg.PeerType" json:"Type"`
	AccessHash uint64   `protobuf:"fixed64,3,req,name=AccessHash" json:"AccessHash"`
}

func (m *InputPeer) Reset()         { *m = InputPeer{} }
func (m *InputPeer) String() string { return proto.CompactTextString(m) }
func (*InputPeer) ProtoMessage()    {}
func (*InputPeer) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{11}
}
func (m *InputPeer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputPeer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputPeer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputPeer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputPeer.Merge(m, src)
}
func (m *InputPeer) XXX_Size() int {
	return m.Size()
}
func (m *InputPeer) XXX_DiscardUnknown() {
	xxx_messageInfo_InputPeer.DiscardUnknown(m)
}

var xxx_messageInfo_InputPeer proto.InternalMessageInfo

func (m *InputPeer) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *InputPeer) GetType() PeerType {
	if m != nil {
		return m.Type
	}
	return PeerSelf
}

func (m *InputPeer) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// InputUser
type InputUser struct {
	UserID     int64  `protobuf:"varint,1,req,name=UserID" json:"UserID"`
	AccessHash uint64 `protobuf:"fixed64,2,req,name=AccessHash" json:"AccessHash"`
}

func (m *InputUser) Reset()         { *m = InputUser{} }
func (m *InputUser) String() string { return proto.CompactTextString(m) }
func (*InputUser) ProtoMessage()    {}
func (*InputUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{12}
}
func (m *InputUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputUser.Merge(m, src)
}
func (m *InputUser) XXX_Size() int {
	return m.Size()
}
func (m *InputUser) XXX_DiscardUnknown() {
	xxx_messageInfo_InputUser.DiscardUnknown(m)
}

var xxx_messageInfo_InputUser proto.InternalMessageInfo

func (m *InputUser) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *InputUser) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// InputPassword
type InputPassword struct {
	SrpID int64  `protobuf:"varint,1,req,name=SrpID" json:"SrpID"`
	A     []byte `protobuf:"bytes,2,req,name=A" json:"A"`
	M1    []byte `protobuf:"bytes,3,req,name=M1" json:"M1"`
}

func (m *InputPassword) Reset()         { *m = InputPassword{} }
func (m *InputPassword) String() string { return proto.CompactTextString(m) }
func (*InputPassword) ProtoMessage()    {}
func (*InputPassword) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{13}
}
func (m *InputPassword) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputPassword) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputPassword.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputPassword) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputPassword.Merge(m, src)
}
func (m *InputPassword) XXX_Size() int {
	return m.Size()
}
func (m *InputPassword) XXX_DiscardUnknown() {
	xxx_messageInfo_InputPassword.DiscardUnknown(m)
}

var xxx_messageInfo_InputPassword proto.InternalMessageInfo

func (m *InputPassword) GetSrpID() int64 {
	if m != nil {
		return m.SrpID
	}
	return 0
}

func (m *InputPassword) GetA() []byte {
	if m != nil {
		return m.A
	}
	return nil
}

func (m *InputPassword) GetM1() []byte {
	if m != nil {
		return m.M1
	}
	return nil
}

// InputFileLocation
type InputFileLocation struct {
	ClusterID  int32  `protobuf:"varint,1,req,name=ClusterID" json:"ClusterID"`
	FileID     int64  `protobuf:"varint,2,req,name=FileID" json:"FileID"`
	AccessHash uint64 `protobuf:"fixed64,3,req,name=AccessHash" json:"AccessHash"`
	Version    int32  `protobuf:"varint,4,opt,name=Version" json:"Version"`
}

func (m *InputFileLocation) Reset()         { *m = InputFileLocation{} }
func (m *InputFileLocation) String() string { return proto.CompactTextString(m) }
func (*InputFileLocation) ProtoMessage()    {}
func (*InputFileLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{14}
}
func (m *InputFileLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputFileLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputFileLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputFileLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputFileLocation.Merge(m, src)
}
func (m *InputFileLocation) XXX_Size() int {
	return m.Size()
}
func (m *InputFileLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_InputFileLocation.DiscardUnknown(m)
}

var xxx_messageInfo_InputFileLocation proto.InternalMessageInfo

func (m *InputFileLocation) GetClusterID() int32 {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

func (m *InputFileLocation) GetFileID() int64 {
	if m != nil {
		return m.FileID
	}
	return 0
}

func (m *InputFileLocation) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *InputFileLocation) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

// FileLocation
type FileLocation struct {
	ClusterID  int32  `protobuf:"varint,1,req,name=ClusterID" json:"ClusterID"`
	FileID     int64  `protobuf:"varint,2,req,name=FileID" json:"FileID"`
	AccessHash uint64 `protobuf:"fixed64,3,req,name=AccessHash" json:"AccessHash"`
}

func (m *FileLocation) Reset()         { *m = FileLocation{} }
func (m *FileLocation) String() string { return proto.CompactTextString(m) }
func (*FileLocation) ProtoMessage()    {}
func (*FileLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{15}
}
func (m *FileLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileLocation.Merge(m, src)
}
func (m *FileLocation) XXX_Size() int {
	return m.Size()
}
func (m *FileLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_FileLocation.DiscardUnknown(m)
}

var xxx_messageInfo_FileLocation proto.InternalMessageInfo

func (m *FileLocation) GetClusterID() int32 {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

func (m *FileLocation) GetFileID() int64 {
	if m != nil {
		return m.FileID
	}
	return 0
}

func (m *FileLocation) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// UserPhoto
type UserPhoto struct {
	PhotoBig   *FileLocation `protobuf:"bytes,1,req,name=PhotoBig" json:"PhotoBig,omitempty"`
	PhotoSmall *FileLocation `protobuf:"bytes,2,req,name=PhotoSmall" json:"PhotoSmall,omitempty"`
	PhotoID    int64         `protobuf:"varint,3,req,name=PhotoID" json:"PhotoID"`
}

func (m *UserPhoto) Reset()         { *m = UserPhoto{} }
func (m *UserPhoto) String() string { return proto.CompactTextString(m) }
func (*UserPhoto) ProtoMessage()    {}
func (*UserPhoto) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{16}
}
func (m *UserPhoto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserPhoto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserPhoto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserPhoto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserPhoto.Merge(m, src)
}
func (m *UserPhoto) XXX_Size() int {
	return m.Size()
}
func (m *UserPhoto) XXX_DiscardUnknown() {
	xxx_messageInfo_UserPhoto.DiscardUnknown(m)
}

var xxx_messageInfo_UserPhoto proto.InternalMessageInfo

func (m *UserPhoto) GetPhotoBig() *FileLocation {
	if m != nil {
		return m.PhotoBig
	}
	return nil
}

func (m *UserPhoto) GetPhotoSmall() *FileLocation {
	if m != nil {
		return m.PhotoSmall
	}
	return nil
}

func (m *UserPhoto) GetPhotoID() int64 {
	if m != nil {
		return m.PhotoID
	}
	return 0
}

// User
type User struct {
	ID           int64        `protobuf:"varint,1,req,name=ID" json:"ID"`
	FirstName    string       `protobuf:"bytes,2,req,name=FirstName" json:"FirstName"`
	LastName     string       `protobuf:"bytes,3,req,name=LastName" json:"LastName"`
	Username     string       `protobuf:"bytes,4,opt,name=Username" json:"Username"`
	Status       UserStatus   `protobuf:"varint,5,req,name=Status,enum=msg.UserStatus" json:"Status"`
	Restricted   bool         `protobuf:"varint,6,req,name=Restricted" json:"Restricted"`
	AccessHash   uint64       `protobuf:"fixed64,7,req,name=AccessHash" json:"AccessHash"`
	Photo        *UserPhoto   `protobuf:"bytes,8,opt,name=Photo" json:"Photo,omitempty"`
	Bio          string       `protobuf:"bytes,9,opt,name=Bio" json:"Bio"`
	Phone        string       `protobuf:"bytes,10,opt,name=Phone" json:"Phone"`
	LastSeen     int64        `protobuf:"varint,11,opt,name=LastSeen" json:"LastSeen"`
	PhotoGallery []*UserPhoto `protobuf:"bytes,12,rep,name=PhotoGallery" json:"PhotoGallery,omitempty"`
	IsBot        bool         `protobuf:"varint,13,opt,name=IsBot" json:"IsBot"`
	Deleted      bool         `protobuf:"varint,14,opt,name=Deleted" json:"Deleted"`
	Blocked      bool         `protobuf:"varint,15,opt,name=Blocked" json:"Blocked"`
	BotInfo      *BotInfo     `protobuf:"bytes,16,opt,name=BotInfo" json:"BotInfo,omitempty"`
	Official     bool         `protobuf:"varint,17,opt,name=Official" json:"Official"`
}

func (m *User) Reset()         { *m = User{} }
func (m *User) String() string { return proto.CompactTextString(m) }
func (*User) ProtoMessage()    {}
func (*User) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{17}
}
func (m *User) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *User) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_User.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *User) XXX_Merge(src proto.Message) {
	xxx_messageInfo_User.Merge(m, src)
}
func (m *User) XXX_Size() int {
	return m.Size()
}
func (m *User) XXX_DiscardUnknown() {
	xxx_messageInfo_User.DiscardUnknown(m)
}

var xxx_messageInfo_User proto.InternalMessageInfo

func (m *User) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *User) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *User) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *User) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *User) GetStatus() UserStatus {
	if m != nil {
		return m.Status
	}
	return UserStatusOffline
}

func (m *User) GetRestricted() bool {
	if m != nil {
		return m.Restricted
	}
	return false
}

func (m *User) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *User) GetPhoto() *UserPhoto {
	if m != nil {
		return m.Photo
	}
	return nil
}

func (m *User) GetBio() string {
	if m != nil {
		return m.Bio
	}
	return ""
}

func (m *User) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *User) GetLastSeen() int64 {
	if m != nil {
		return m.LastSeen
	}
	return 0
}

func (m *User) GetPhotoGallery() []*UserPhoto {
	if m != nil {
		return m.PhotoGallery
	}
	return nil
}

func (m *User) GetIsBot() bool {
	if m != nil {
		return m.IsBot
	}
	return false
}

func (m *User) GetDeleted() bool {
	if m != nil {
		return m.Deleted
	}
	return false
}

func (m *User) GetBlocked() bool {
	if m != nil {
		return m.Blocked
	}
	return false
}

func (m *User) GetBotInfo() *BotInfo {
	if m != nil {
		return m.BotInfo
	}
	return nil
}

func (m *User) GetOfficial() bool {
	if m != nil {
		return m.Official
	}
	return false
}

// Bot
type Bot struct {
	ID       int64  `protobuf:"varint,1,req,name=ID" json:"ID"`
	Name     string `protobuf:"bytes,2,req,name=Name" json:"Name"`
	Username string `protobuf:"bytes,3,req,name=Username" json:"Username"`
	Bio      string `protobuf:"bytes,4,opt,name=Bio" json:"Bio"`
}

func (m *Bot) Reset()         { *m = Bot{} }
func (m *Bot) String() string { return proto.CompactTextString(m) }
func (*Bot) ProtoMessage()    {}
func (*Bot) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{18}
}
func (m *Bot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Bot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Bot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Bot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Bot.Merge(m, src)
}
func (m *Bot) XXX_Size() int {
	return m.Size()
}
func (m *Bot) XXX_DiscardUnknown() {
	xxx_messageInfo_Bot.DiscardUnknown(m)
}

var xxx_messageInfo_Bot proto.InternalMessageInfo

func (m *Bot) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Bot) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Bot) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Bot) GetBio() string {
	if m != nil {
		return m.Bio
	}
	return ""
}

// BotCommands
type BotCommands struct {
	Command     string `protobuf:"bytes,1,req,name=Command" json:"Command"`
	Description string `protobuf:"bytes,2,opt,name=Description" json:"Description"`
}

func (m *BotCommands) Reset()         { *m = BotCommands{} }
func (m *BotCommands) String() string { return proto.CompactTextString(m) }
func (*BotCommands) ProtoMessage()    {}
func (*BotCommands) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{19}
}
func (m *BotCommands) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BotCommands) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BotCommands.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BotCommands) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BotCommands.Merge(m, src)
}
func (m *BotCommands) XXX_Size() int {
	return m.Size()
}
func (m *BotCommands) XXX_DiscardUnknown() {
	xxx_messageInfo_BotCommands.DiscardUnknown(m)
}

var xxx_messageInfo_BotCommands proto.InternalMessageInfo

func (m *BotCommands) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *BotCommands) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// BotInfo
type BotInfo struct {
	Bot               *Bot           `protobuf:"bytes,1,req,name=Bot" json:"Bot,omitempty"`
	UserID            int64          `protobuf:"varint,2,req,name=UserID" json:"UserID"`
	Description       string         `protobuf:"bytes,3,opt,name=Description" json:"Description"`
	BotCommands       []*BotCommands `protobuf:"bytes,4,rep,name=BotCommands" json:"BotCommands,omitempty"`
	InlineGeo         bool           `protobuf:"varint,5,opt,name=InlineGeo" json:"InlineGeo"`
	InlinePlaceHolder string         `protobuf:"bytes,6,opt,name=InlinePlaceHolder" json:"InlinePlaceHolder"`
}

func (m *BotInfo) Reset()         { *m = BotInfo{} }
func (m *BotInfo) String() string { return proto.CompactTextString(m) }
func (*BotInfo) ProtoMessage()    {}
func (*BotInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{20}
}
func (m *BotInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BotInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BotInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BotInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BotInfo.Merge(m, src)
}
func (m *BotInfo) XXX_Size() int {
	return m.Size()
}
func (m *BotInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BotInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BotInfo proto.InternalMessageInfo

func (m *BotInfo) GetBot() *Bot {
	if m != nil {
		return m.Bot
	}
	return nil
}

func (m *BotInfo) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *BotInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *BotInfo) GetBotCommands() []*BotCommands {
	if m != nil {
		return m.BotCommands
	}
	return nil
}

func (m *BotInfo) GetInlineGeo() bool {
	if m != nil {
		return m.InlineGeo
	}
	return false
}

func (m *BotInfo) GetInlinePlaceHolder() string {
	if m != nil {
		return m.InlinePlaceHolder
	}
	return ""
}

// ContactUser
type ContactUser struct {
	ID         int64      `protobuf:"varint,1,req,name=ID" json:"ID"`
	FirstName  string     `protobuf:"bytes,2,req,name=FirstName" json:"FirstName"`
	LastName   string     `protobuf:"bytes,3,req,name=LastName" json:"LastName"`
	AccessHash uint64     `protobuf:"fixed64,4,req,name=AccessHash" json:"AccessHash"`
	Phone      string     `protobuf:"bytes,5,req,name=Phone" json:"Phone"`
	Username   string     `protobuf:"bytes,6,req,name=Username" json:"Username"`
	ClientID   int64      `protobuf:"varint,7,req,name=ClientID" json:"ClientID"`
	Photo      *UserPhoto `protobuf:"bytes,8,opt,name=Photo" json:"Photo,omitempty"`
}

func (m *ContactUser) Reset()         { *m = ContactUser{} }
func (m *ContactUser) String() string { return proto.CompactTextString(m) }
func (*ContactUser) ProtoMessage()    {}
func (*ContactUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{21}
}
func (m *ContactUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContactUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContactUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContactUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContactUser.Merge(m, src)
}
func (m *ContactUser) XXX_Size() int {
	return m.Size()
}
func (m *ContactUser) XXX_DiscardUnknown() {
	xxx_messageInfo_ContactUser.DiscardUnknown(m)
}

var xxx_messageInfo_ContactUser proto.InternalMessageInfo

func (m *ContactUser) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ContactUser) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *ContactUser) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *ContactUser) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *ContactUser) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *ContactUser) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *ContactUser) GetClientID() int64 {
	if m != nil {
		return m.ClientID
	}
	return 0
}

func (m *ContactUser) GetPhoto() *UserPhoto {
	if m != nil {
		return m.Photo
	}
	return nil
}

// UserMessage
type UserMessage struct {
	ID                  int64            `protobuf:"varint,1,req,name=ID" json:"ID"`
	PeerID              int64            `protobuf:"varint,2,req,name=PeerID" json:"PeerID"`
	PeerType            int32            `protobuf:"varint,3,req,name=PeerType" json:"PeerType"`
	CreatedOn           int64            `protobuf:"varint,4,req,name=CreatedOn" json:"CreatedOn"`
	EditedOn            int64            `protobuf:"varint,5,req,name=EditedOn" json:"EditedOn"`
	FwdSenderID         int64            `protobuf:"varint,6,req,name=FwdSenderID" json:"FwdSenderID"`
	FwdChannelID        int64            `protobuf:"varint,7,req,name=FwdChannelID" json:"FwdChannelID"`
	FwdChannelMessageID int64            `protobuf:"varint,8,req,name=FwdChannelMessageID" json:"FwdChannelMessageID"`
	Flags               int32            `protobuf:"varint,9,req,name=Flags" json:"Flags"`
	MessageType         int64            `protobuf:"varint,10,req,name=MessageType" json:"MessageType"`
	Body                string           `protobuf:"bytes,11,req,name=Body" json:"Body"`
	SenderID            int64            `protobuf:"varint,12,req,name=SenderID" json:"SenderID"`
	ContentRead         bool             `protobuf:"varint,13,req,name=ContentRead" json:"ContentRead"`
	Inbox               bool             `protobuf:"varint,14,req,name=Inbox" json:"Inbox"`
	ReplyTo             int64            `protobuf:"varint,15,req,name=ReplyTo" json:"ReplyTo"`
	MessageAction       int32            `protobuf:"varint,16,opt,name=MessageAction" json:"MessageAction"`
	MessageActionData   []byte           `protobuf:"bytes,17,opt,name=MessageActionData" json:"MessageActionData"`
	Entities            []*MessageEntity `protobuf:"bytes,18,rep,name=Entities" json:"Entities,omitempty"`
	MediaType           MediaType        `protobuf:"varint,19,opt,name=MediaType,enum=msg.MediaType" json:"MediaType"`
	Media               []byte           `protobuf:"bytes,20,opt,name=Media" json:"Media"`
	ReplyMarkup         int64            `protobuf:"varint,21,opt,name=ReplyMarkup" json:"ReplyMarkup"`
	ReplyMarkupData     []byte           `protobuf:"bytes,22,opt,name=ReplyMarkupData" json:"ReplyMarkupData"`
	LabelIDs            []int32          `protobuf:"varint,23,rep,name=LabelIDs" json:"LabelIDs,omitempty"`
	ViaBotID            int64            `protobuf:"varint,24,opt,name=ViaBotID" json:"ViaBotID"`
}

func (m *UserMessage) Reset()         { *m = UserMessage{} }
func (m *UserMessage) String() string { return proto.CompactTextString(m) }
func (*UserMessage) ProtoMessage()    {}
func (*UserMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{22}
}
func (m *UserMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserMessage.Merge(m, src)
}
func (m *UserMessage) XXX_Size() int {
	return m.Size()
}
func (m *UserMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_UserMessage.DiscardUnknown(m)
}

var xxx_messageInfo_UserMessage proto.InternalMessageInfo

func (m *UserMessage) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UserMessage) GetPeerID() int64 {
	if m != nil {
		return m.PeerID
	}
	return 0
}

func (m *UserMessage) GetPeerType() int32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *UserMessage) GetCreatedOn() int64 {
	if m != nil {
		return m.CreatedOn
	}
	return 0
}

func (m *UserMessage) GetEditedOn() int64 {
	if m != nil {
		return m.EditedOn
	}
	return 0
}

func (m *UserMessage) GetFwdSenderID() int64 {
	if m != nil {
		return m.FwdSenderID
	}
	return 0
}

func (m *UserMessage) GetFwdChannelID() int64 {
	if m != nil {
		return m.FwdChannelID
	}
	return 0
}

func (m *UserMessage) GetFwdChannelMessageID() int64 {
	if m != nil {
		return m.FwdChannelMessageID
	}
	return 0
}

func (m *UserMessage) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *UserMessage) GetMessageType() int64 {
	if m != nil {
		return m.MessageType
	}
	return 0
}

func (m *UserMessage) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

func (m *UserMessage) GetSenderID() int64 {
	if m != nil {
		return m.SenderID
	}
	return 0
}

func (m *UserMessage) GetContentRead() bool {
	if m != nil {
		return m.ContentRead
	}
	return false
}

func (m *UserMessage) GetInbox() bool {
	if m != nil {
		return m.Inbox
	}
	return false
}

func (m *UserMessage) GetReplyTo() int64 {
	if m != nil {
		return m.ReplyTo
	}
	return 0
}

func (m *UserMessage) GetMessageAction() int32 {
	if m != nil {
		return m.MessageAction
	}
	return 0
}

func (m *UserMessage) GetMessageActionData() []byte {
	if m != nil {
		return m.MessageActionData
	}
	return nil
}

func (m *UserMessage) GetEntities() []*MessageEntity {
	if m != nil {
		return m.Entities
	}
	return nil
}

func (m *UserMessage) GetMediaType() MediaType {
	if m != nil {
		return m.MediaType
	}
	return MediaTypeEmpty
}

func (m *UserMessage) GetMedia() []byte {
	if m != nil {
		return m.Media
	}
	return nil
}

func (m *UserMessage) GetReplyMarkup() int64 {
	if m != nil {
		return m.ReplyMarkup
	}
	return 0
}

func (m *UserMessage) GetReplyMarkupData() []byte {
	if m != nil {
		return m.ReplyMarkupData
	}
	return nil
}

func (m *UserMessage) GetLabelIDs() []int32 {
	if m != nil {
		return m.LabelIDs
	}
	return nil
}

func (m *UserMessage) GetViaBotID() int64 {
	if m != nil {
		return m.ViaBotID
	}
	return 0
}

// DraftMessage
type DraftMessage struct {
	PeerID   int64            `protobuf:"varint,2,req,name=PeerID" json:"PeerID"`
	PeerType int32            `protobuf:"varint,3,req,name=PeerType" json:"PeerType"`
	Date     int64            `protobuf:"varint,4,req,name=Date" json:"Date"`
	Body     string           `protobuf:"bytes,5,req,name=Body" json:"Body"`
	Entities []*MessageEntity `protobuf:"bytes,6,rep,name=Entities" json:"Entities,omitempty"`
	ReplyTo  int64            `protobuf:"varint,7,req,name=ReplyTo" json:"ReplyTo"`
	EditedID int64            `protobuf:"varint,8,opt,name=EditedID" json:"EditedID"`
}

func (m *DraftMessage) Reset()         { *m = DraftMessage{} }
func (m *DraftMessage) String() string { return proto.CompactTextString(m) }
func (*DraftMessage) ProtoMessage()    {}
func (*DraftMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{23}
}
func (m *DraftMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DraftMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DraftMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DraftMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DraftMessage.Merge(m, src)
}
func (m *DraftMessage) XXX_Size() int {
	return m.Size()
}
func (m *DraftMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_DraftMessage.DiscardUnknown(m)
}

var xxx_messageInfo_DraftMessage proto.InternalMessageInfo

func (m *DraftMessage) GetPeerID() int64 {
	if m != nil {
		return m.PeerID
	}
	return 0
}

func (m *DraftMessage) GetPeerType() int32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *DraftMessage) GetDate() int64 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *DraftMessage) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

func (m *DraftMessage) GetEntities() []*MessageEntity {
	if m != nil {
		return m.Entities
	}
	return nil
}

func (m *DraftMessage) GetReplyTo() int64 {
	if m != nil {
		return m.ReplyTo
	}
	return 0
}

func (m *DraftMessage) GetEditedID() int64 {
	if m != nil {
		return m.EditedID
	}
	return 0
}

// MessageEntity
type MessageEntity struct {
	Type   MessageEntityType `protobuf:"varint,1,req,name=Type,enum=msg.MessageEntityType" json:"Type"`
	Offset int32             `protobuf:"varint,2,req,name=Offset" json:"Offset"`
	Length int32             `protobuf:"varint,3,req,name=Length" json:"Length"`
	UserID int64             `protobuf:"varint,4,opt,name=UserID" json:"UserID"`
}

func (m *MessageEntity) Reset()         { *m = MessageEntity{} }
func (m *MessageEntity) String() string { return proto.CompactTextString(m) }
func (*MessageEntity) ProtoMessage()    {}
func (*MessageEntity) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{24}
}
func (m *MessageEntity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageEntity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageEntity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageEntity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageEntity.Merge(m, src)
}
func (m *MessageEntity) XXX_Size() int {
	return m.Size()
}
func (m *MessageEntity) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageEntity.DiscardUnknown(m)
}

var xxx_messageInfo_MessageEntity proto.InternalMessageInfo

func (m *MessageEntity) GetType() MessageEntityType {
	if m != nil {
		return m.Type
	}
	return MessageEntityTypeBold
}

func (m *MessageEntity) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *MessageEntity) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *MessageEntity) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

// RSAPublicKey
type RSAPublicKey struct {
	FingerPrint int64  `protobuf:"varint,1,req,name=FingerPrint" json:"FingerPrint"`
	N           string `protobuf:"bytes,2,req,name=N" json:"N"`
	E           uint32 `protobuf:"varint,3,req,name=E" json:"E"`
}

func (m *RSAPublicKey) Reset()         { *m = RSAPublicKey{} }
func (m *RSAPublicKey) String() string { return proto.CompactTextString(m) }
func (*RSAPublicKey) ProtoMessage()    {}
func (*RSAPublicKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{25}
}
func (m *RSAPublicKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RSAPublicKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RSAPublicKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RSAPublicKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RSAPublicKey.Merge(m, src)
}
func (m *RSAPublicKey) XXX_Size() int {
	return m.Size()
}
func (m *RSAPublicKey) XXX_DiscardUnknown() {
	xxx_messageInfo_RSAPublicKey.DiscardUnknown(m)
}

var xxx_messageInfo_RSAPublicKey proto.InternalMessageInfo

func (m *RSAPublicKey) GetFingerPrint() int64 {
	if m != nil {
		return m.FingerPrint
	}
	return 0
}

func (m *RSAPublicKey) GetN() string {
	if m != nil {
		return m.N
	}
	return ""
}

func (m *RSAPublicKey) GetE() uint32 {
	if m != nil {
		return m.E
	}
	return 0
}

// DHGroup
type DHGroup struct {
	FingerPrint int64  `protobuf:"varint,1,req,name=FingerPrint" json:"FingerPrint"`
	Prime       string `protobuf:"bytes,2,req,name=Prime" json:"Prime"`
	Gen         int32  `protobuf:"varint,3,req,name=Gen" json:"Gen"`
}

func (m *DHGroup) Reset()         { *m = DHGroup{} }
func (m *DHGroup) String() string { return proto.CompactTextString(m) }
func (*DHGroup) ProtoMessage()    {}
func (*DHGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{26}
}
func (m *DHGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DHGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DHGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHGroup.Merge(m, src)
}
func (m *DHGroup) XXX_Size() int {
	return m.Size()
}
func (m *DHGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_DHGroup.DiscardUnknown(m)
}

var xxx_messageInfo_DHGroup proto.InternalMessageInfo

func (m *DHGroup) GetFingerPrint() int64 {
	if m != nil {
		return m.FingerPrint
	}
	return 0
}

func (m *DHGroup) GetPrime() string {
	if m != nil {
		return m.Prime
	}
	return ""
}

func (m *DHGroup) GetGen() int32 {
	if m != nil {
		return m.Gen
	}
	return 0
}

// PhoneContact
type PhoneContact struct {
	ClientID  int64  `protobuf:"varint,1,req,name=ClientID" json:"ClientID"`
	FirstName string `protobuf:"bytes,2,req,name=FirstName" json:"FirstName"`
	LastName  string `protobuf:"bytes,3,req,name=LastName" json:"LastName"`
	Phone     string `protobuf:"bytes,4,req,name=Phone" json:"Phone"`
}

func (m *PhoneContact) Reset()         { *m = PhoneContact{} }
func (m *PhoneContact) String() string { return proto.CompactTextString(m) }
func (*PhoneContact) ProtoMessage()    {}
func (*PhoneContact) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{27}
}
func (m *PhoneContact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhoneContact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhoneContact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhoneContact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhoneContact.Merge(m, src)
}
func (m *PhoneContact) XXX_Size() int {
	return m.Size()
}
func (m *PhoneContact) XXX_DiscardUnknown() {
	xxx_messageInfo_PhoneContact.DiscardUnknown(m)
}

var xxx_messageInfo_PhoneContact proto.InternalMessageInfo

func (m *PhoneContact) GetClientID() int64 {
	if m != nil {
		return m.ClientID
	}
	return 0
}

func (m *PhoneContact) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *PhoneContact) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *PhoneContact) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

// PeerNotifySettings
type PeerNotifySettings struct {
	Flags     int32  `protobuf:"varint,1,req,name=Flags" json:"Flags"`
	MuteUntil int64  `protobuf:"varint,2,opt,name=MuteUntil" json:"MuteUntil"`
	Sound     string `protobuf:"bytes,3,opt,name=Sound" json:"Sound"`
}

func (m *PeerNotifySettings) Reset()         { *m = PeerNotifySettings{} }
func (m *PeerNotifySettings) String() string { return proto.CompactTextString(m) }
func (*PeerNotifySettings) ProtoMessage()    {}
func (*PeerNotifySettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{28}
}
func (m *PeerNotifySettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerNotifySettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerNotifySettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerNotifySettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerNotifySettings.Merge(m, src)
}
func (m *PeerNotifySettings) XXX_Size() int {
	return m.Size()
}
func (m *PeerNotifySettings) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerNotifySettings.DiscardUnknown(m)
}

var xxx_messageInfo_PeerNotifySettings proto.InternalMessageInfo

func (m *PeerNotifySettings) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *PeerNotifySettings) GetMuteUntil() int64 {
	if m != nil {
		return m.MuteUntil
	}
	return 0
}

func (m *PeerNotifySettings) GetSound() string {
	if m != nil {
		return m.Sound
	}
	return ""
}

// InputFile
type InputFile struct {
	FileID      int64  `protobuf:"varint,1,req,name=FileID" json:"FileID"`
	TotalParts  int32  `protobuf:"varint,2,req,name=TotalParts" json:"TotalParts"`
	FileName    string `protobuf:"bytes,3,req,name=FileName" json:"FileName"`
	MD5Checksum string `protobuf:"bytes,4,req,name=MD5Checksum" json:"MD5Checksum"`
}

func (m *InputFile) Reset()         { *m = InputFile{} }
func (m *InputFile) String() string { return proto.CompactTextString(m) }
func (*InputFile) ProtoMessage()    {}
func (*InputFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{29}
}
func (m *InputFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputFile.Merge(m, src)
}
func (m *InputFile) XXX_Size() int {
	return m.Size()
}
func (m *InputFile) XXX_DiscardUnknown() {
	xxx_messageInfo_InputFile.DiscardUnknown(m)
}

var xxx_messageInfo_InputFile proto.InternalMessageInfo

func (m *InputFile) GetFileID() int64 {
	if m != nil {
		return m.FileID
	}
	return 0
}

func (m *InputFile) GetTotalParts() int32 {
	if m != nil {
		return m.TotalParts
	}
	return 0
}

func (m *InputFile) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *InputFile) GetMD5Checksum() string {
	if m != nil {
		return m.MD5Checksum
	}
	return ""
}

// GroupPhoto
type GroupPhoto struct {
	PhotoBig   *FileLocation `protobuf:"bytes,1,req,name=PhotoBig" json:"PhotoBig,omitempty"`
	PhotoSmall *FileLocation `protobuf:"bytes,2,req,name=PhotoSmall" json:"PhotoSmall,omitempty"`
	PhotoID    int64         `protobuf:"varint,3,opt,name=PhotoID" json:"PhotoID"`
}

func (m *GroupPhoto) Reset()         { *m = GroupPhoto{} }
func (m *GroupPhoto) String() string { return proto.CompactTextString(m) }
func (*GroupPhoto) ProtoMessage()    {}
func (*GroupPhoto) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{30}
}
func (m *GroupPhoto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupPhoto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupPhoto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupPhoto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupPhoto.Merge(m, src)
}
func (m *GroupPhoto) XXX_Size() int {
	return m.Size()
}
func (m *GroupPhoto) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupPhoto.DiscardUnknown(m)
}

var xxx_messageInfo_GroupPhoto proto.InternalMessageInfo

func (m *GroupPhoto) GetPhotoBig() *FileLocation {
	if m != nil {
		return m.PhotoBig
	}
	return nil
}

func (m *GroupPhoto) GetPhotoSmall() *FileLocation {
	if m != nil {
		return m.PhotoSmall
	}
	return nil
}

func (m *GroupPhoto) GetPhotoID() int64 {
	if m != nil {
		return m.PhotoID
	}
	return 0
}

// Group
type Group struct {
	ID           int64        `protobuf:"varint,1,req,name=ID" json:"ID"`
	Title        string       `protobuf:"bytes,2,req,name=Title" json:"Title"`
	CreatedOn    int64        `protobuf:"varint,3,req,name=CreatedOn" json:"CreatedOn"`
	Participants int32        `protobuf:"varint,4,req,name=Participants" json:"Participants"`
	EditedOn     int64        `protobuf:"varint,5,opt,name=EditedOn" json:"EditedOn"`
	Flags        []GroupFlags `protobuf:"varint,6,rep,name=Flags,enum=msg.GroupFlags" json:"Flags,omitempty"`
	Photo        *GroupPhoto  `protobuf:"bytes,7,opt,name=Photo" json:"Photo,omitempty"`
}

func (m *Group) Reset()         { *m = Group{} }
func (m *Group) String() string { return proto.CompactTextString(m) }
func (*Group) ProtoMessage()    {}
func (*Group) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{31}
}
func (m *Group) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Group) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Group.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Group) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Group.Merge(m, src)
}
func (m *Group) XXX_Size() int {
	return m.Size()
}
func (m *Group) XXX_DiscardUnknown() {
	xxx_messageInfo_Group.DiscardUnknown(m)
}

var xxx_messageInfo_Group proto.InternalMessageInfo

func (m *Group) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Group) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Group) GetCreatedOn() int64 {
	if m != nil {
		return m.CreatedOn
	}
	return 0
}

func (m *Group) GetParticipants() int32 {
	if m != nil {
		return m.Participants
	}
	return 0
}

func (m *Group) GetEditedOn() int64 {
	if m != nil {
		return m.EditedOn
	}
	return 0
}

func (m *Group) GetFlags() []GroupFlags {
	if m != nil {
		return m.Flags
	}
	return nil
}

func (m *Group) GetPhoto() *GroupPhoto {
	if m != nil {
		return m.Photo
	}
	return nil
}

// GroupFull
type GroupFull struct {
	Group          *Group              `protobuf:"bytes,1,req,name=Group" json:"Group,omitempty"`
	Users          []*User             `protobuf:"bytes,2,rep,name=Users" json:"Users,omitempty"`
	Participants   []*GroupParticipant `protobuf:"bytes,3,rep,name=Participants" json:"Participants,omitempty"`
	NotifySettings *PeerNotifySettings `protobuf:"bytes,4,req,name=NotifySettings" json:"NotifySettings,omitempty"`
	PhotoGallery   []*GroupPhoto       `protobuf:"bytes,5,rep,name=PhotoGallery" json:"PhotoGallery,omitempty"`
}

func (m *GroupFull) Reset()         { *m = GroupFull{} }
func (m *GroupFull) String() string { return proto.CompactTextString(m) }
func (*GroupFull) ProtoMessage()    {}
func (*GroupFull) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{32}
}
func (m *GroupFull) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupFull) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupFull.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupFull) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupFull.Merge(m, src)
}
func (m *GroupFull) XXX_Size() int {
	return m.Size()
}
func (m *GroupFull) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupFull.DiscardUnknown(m)
}

var xxx_messageInfo_GroupFull proto.InternalMessageInfo

func (m *GroupFull) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *GroupFull) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *GroupFull) GetParticipants() []*GroupParticipant {
	if m != nil {
		return m.Participants
	}
	return nil
}

func (m *GroupFull) GetNotifySettings() *PeerNotifySettings {
	if m != nil {
		return m.NotifySettings
	}
	return nil
}

func (m *GroupFull) GetPhotoGallery() []*GroupPhoto {
	if m != nil {
		return m.PhotoGallery
	}
	return nil
}

// GroupParticipant
type GroupParticipant struct {
	UserID     int64           `protobuf:"varint,1,req,name=UserID" json:"UserID"`
	FirstName  string          `protobuf:"bytes,2,req,name=FirstName" json:"FirstName"`
	LastName   string          `protobuf:"bytes,3,req,name=LastName" json:"LastName"`
	Type       ParticipantType `protobuf:"varint,4,req,name=Type,enum=msg.ParticipantType" json:"Type"`
	AccessHash uint64          `protobuf:"varint,5,req,name=AccessHash" json:"AccessHash"`
	Username   string          `protobuf:"bytes,6,req,name=Username" json:"Username"`
	Photo      *UserPhoto      `protobuf:"bytes,8,opt,name=Photo" json:"Photo,omitempty"`
}

func (m *GroupParticipant) Reset()         { *m = GroupParticipant{} }
func (m *GroupParticipant) String() string { return proto.CompactTextString(m) }
func (*GroupParticipant) ProtoMessage()    {}
func (*GroupParticipant) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{33}
}
func (m *GroupParticipant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupParticipant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupParticipant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupParticipant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupParticipant.Merge(m, src)
}
func (m *GroupParticipant) XXX_Size() int {
	return m.Size()
}
func (m *GroupParticipant) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupParticipant.DiscardUnknown(m)
}

var xxx_messageInfo_GroupParticipant proto.InternalMessageInfo

func (m *GroupParticipant) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *GroupParticipant) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *GroupParticipant) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *GroupParticipant) GetType() ParticipantType {
	if m != nil {
		return m.Type
	}
	return ParticipantTypeMember
}

func (m *GroupParticipant) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *GroupParticipant) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *GroupParticipant) GetPhoto() *UserPhoto {
	if m != nil {
		return m.Photo
	}
	return nil
}

// InputDocument
type InputDocument struct {
	ID         int64  `protobuf:"varint,1,req,name=ID" json:"ID"`
	AccessHash uint64 `protobuf:"fixed64,2,req,name=AccessHash" json:"AccessHash"`
	ClusterID  int32  `protobuf:"varint,3,req,name=ClusterID" json:"ClusterID"`
}

func (m *InputDocument) Reset()         { *m = InputDocument{} }
func (m *InputDocument) String() string { return proto.CompactTextString(m) }
func (*InputDocument) ProtoMessage()    {}
func (*InputDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{34}
}
func (m *InputDocument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputDocument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputDocument.Merge(m, src)
}
func (m *InputDocument) XXX_Size() int {
	return m.Size()
}
func (m *InputDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_InputDocument.DiscardUnknown(m)
}

var xxx_messageInfo_InputDocument proto.InternalMessageInfo

func (m *InputDocument) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *InputDocument) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *InputDocument) GetClusterID() int32 {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

// PrivacyRule
type PrivacyRule struct {
	PrivacyType PrivacyType `protobuf:"varint,1,req,name=PrivacyType,enum=msg.PrivacyType" json:"PrivacyType"`
	UserIDs     []int64     `protobuf:"varint,2,rep,name=UserIDs" json:"UserIDs,omitempty"`
}

func (m *PrivacyRule) Reset()         { *m = PrivacyRule{} }
func (m *PrivacyRule) String() string { return proto.CompactTextString(m) }
func (*PrivacyRule) ProtoMessage()    {}
func (*PrivacyRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{35}
}
func (m *PrivacyRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrivacyRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrivacyRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrivacyRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrivacyRule.Merge(m, src)
}
func (m *PrivacyRule) XXX_Size() int {
	return m.Size()
}
func (m *PrivacyRule) XXX_DiscardUnknown() {
	xxx_messageInfo_PrivacyRule.DiscardUnknown(m)
}

var xxx_messageInfo_PrivacyRule proto.InternalMessageInfo

func (m *PrivacyRule) GetPrivacyType() PrivacyType {
	if m != nil {
		return m.PrivacyType
	}
	return PrivacyTypeAllowAll
}

func (m *PrivacyRule) GetUserIDs() []int64 {
	if m != nil {
		return m.UserIDs
	}
	return nil
}

// Label
type Label struct {
	ID     int32  `protobuf:"varint,1,req,name=ID" json:"ID"`
	Name   string `protobuf:"bytes,2,req,name=Name" json:"Name"`
	Colour string `protobuf:"bytes,3,req,name=Colour" json:"Colour"`
	Count  int32  `protobuf:"varint,4,opt,name=Count" json:"Count"`
}

func (m *Label) Reset()         { *m = Label{} }
func (m *Label) String() string { return proto.CompactTextString(m) }
func (*Label) ProtoMessage()    {}
func (*Label) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{36}
}
func (m *Label) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Label) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Label.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Label) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Label.Merge(m, src)
}
func (m *Label) XXX_Size() int {
	return m.Size()
}
func (m *Label) XXX_DiscardUnknown() {
	xxx_messageInfo_Label.DiscardUnknown(m)
}

var xxx_messageInfo_Label proto.InternalMessageInfo

func (m *Label) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Label) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Label) GetColour() string {
	if m != nil {
		return m.Colour
	}
	return ""
}

func (m *Label) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

// LabelsMany
type LabelsMany struct {
	Labels []*Label `protobuf:"bytes,1,rep,name=Labels" json:"Labels,omitempty"`
}

func (m *LabelsMany) Reset()         { *m = LabelsMany{} }
func (m *LabelsMany) String() string { return proto.CompactTextString(m) }
func (*LabelsMany) ProtoMessage()    {}
func (*LabelsMany) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{37}
}
func (m *LabelsMany) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LabelsMany) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LabelsMany.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LabelsMany) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LabelsMany.Merge(m, src)
}
func (m *LabelsMany) XXX_Size() int {
	return m.Size()
}
func (m *LabelsMany) XXX_DiscardUnknown() {
	xxx_messageInfo_LabelsMany.DiscardUnknown(m)
}

var xxx_messageInfo_LabelsMany proto.InternalMessageInfo

func (m *LabelsMany) GetLabels() []*Label {
	if m != nil {
		return m.Labels
	}
	return nil
}

// GeoLocation
type GeoLocation struct {
	Lat  float32 `protobuf:"fixed32,1,req,name=Lat" json:"Lat"`
	Long float32 `protobuf:"fixed32,2,req,name=Long" json:"Long"`
}

func (m *GeoLocation) Reset()         { *m = GeoLocation{} }
func (m *GeoLocation) String() string { return proto.CompactTextString(m) }
func (*GeoLocation) ProtoMessage()    {}
func (*GeoLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{38}
}
func (m *GeoLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GeoLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GeoLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GeoLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeoLocation.Merge(m, src)
}
func (m *GeoLocation) XXX_Size() int {
	return m.Size()
}
func (m *GeoLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_GeoLocation.DiscardUnknown(m)
}

var xxx_messageInfo_GeoLocation proto.InternalMessageInfo

func (m *GeoLocation) GetLat() float32 {
	if m != nil {
		return m.Lat
	}
	return 0
}

func (m *GeoLocation) GetLong() float32 {
	if m != nil {
		return m.Long
	}
	return 0
}

// InputGeoLocation
type InputGeoLocation struct {
	Lat  float32 `protobuf:"fixed32,1,req,name=Lat" json:"Lat"`
	Long float32 `protobuf:"fixed32,2,req,name=Long" json:"Long"`
}

func (m *InputGeoLocation) Reset()         { *m = InputGeoLocation{} }
func (m *InputGeoLocation) String() string { return proto.CompactTextString(m) }
func (*InputGeoLocation) ProtoMessage()    {}
func (*InputGeoLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{39}
}
func (m *InputGeoLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputGeoLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputGeoLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputGeoLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputGeoLocation.Merge(m, src)
}
func (m *InputGeoLocation) XXX_Size() int {
	return m.Size()
}
func (m *InputGeoLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_InputGeoLocation.DiscardUnknown(m)
}

var xxx_messageInfo_InputGeoLocation proto.InternalMessageInfo

func (m *InputGeoLocation) GetLat() float32 {
	if m != nil {
		return m.Lat
	}
	return 0
}

func (m *InputGeoLocation) GetLong() float32 {
	if m != nil {
		return m.Long
	}
	return 0
}

func init() {
	proto.RegisterEnum("msg.TypingAction", TypingAction_name, TypingAction_value)
	proto.RegisterEnum("msg.PeerType", PeerType_name, PeerType_value)
	proto.RegisterEnum("msg.UserStatus", UserStatus_name, UserStatus_value)
	proto.RegisterEnum("msg.MediaType", MediaType_name, MediaType_value)
	proto.RegisterEnum("msg.InputMediaType", InputMediaType_name, InputMediaType_value)
	proto.RegisterEnum("msg.MessageEntityType", MessageEntityType_name, MessageEntityType_value)
	proto.RegisterEnum("msg.GroupFlags", GroupFlags_name, GroupFlags_value)
	proto.RegisterEnum("msg.ParticipantType", ParticipantType_name, ParticipantType_value)
	proto.RegisterEnum("msg.PushTokenProvider", PushTokenProvider_name, PushTokenProvider_value)
	proto.RegisterEnum("msg.PrivacyKey", PrivacyKey_name, PrivacyKey_value)
	proto.RegisterEnum("msg.PrivacyType", PrivacyType_name, PrivacyType_value)
	proto.RegisterType((*MessageEnvelope)(nil), "msg.MessageEnvelope")
	proto.RegisterType((*MessageContainer)(nil), "msg.MessageContainer")
	proto.RegisterType((*UpdateEnvelope)(nil), "msg.UpdateEnvelope")
	proto.RegisterType((*UpdateContainer)(nil), "msg.UpdateContainer")
	proto.RegisterType((*ProtoMessage)(nil), "msg.ProtoMessage")
	proto.RegisterType((*ProtoEncryptedPayload)(nil), "msg.ProtoEncryptedPayload")
	proto.RegisterType((*Error)(nil), "msg.Error")
	proto.RegisterType((*Ack)(nil), "msg.Ack")
	proto.RegisterType((*Bool)(nil), "msg.Bool")
	proto.RegisterType((*Dialog)(nil), "msg.Dialog")
	proto.RegisterType((*Peer)(nil), "msg.Peer")
	proto.RegisterType((*InputPeer)(nil), "msg.InputPeer")
	proto.RegisterType((*InputUser)(nil), "msg.InputUser")
	proto.RegisterType((*InputPassword)(nil), "msg.InputPassword")
	proto.RegisterType((*InputFileLocation)(nil), "msg.InputFileLocation")
	proto.RegisterType((*FileLocation)(nil), "msg.FileLocation")
	proto.RegisterType((*UserPhoto)(nil), "msg.UserPhoto")
	proto.RegisterType((*User)(nil), "msg.User")
	proto.RegisterType((*Bot)(nil), "msg.Bot")
	proto.RegisterType((*BotCommands)(nil), "msg.BotCommands")
	proto.RegisterType((*BotInfo)(nil), "msg.BotInfo")
	proto.RegisterType((*ContactUser)(nil), "msg.ContactUser")
	proto.RegisterType((*UserMessage)(nil), "msg.UserMessage")
	proto.RegisterType((*DraftMessage)(nil), "msg.DraftMessage")
	proto.RegisterType((*MessageEntity)(nil), "msg.MessageEntity")
	proto.RegisterType((*RSAPublicKey)(nil), "msg.RSAPublicKey")
	proto.RegisterType((*DHGroup)(nil), "msg.DHGroup")
	proto.RegisterType((*PhoneContact)(nil), "msg.PhoneContact")
	proto.RegisterType((*PeerNotifySettings)(nil), "msg.PeerNotifySettings")
	proto.RegisterType((*InputFile)(nil), "msg.InputFile")
	proto.RegisterType((*GroupPhoto)(nil), "msg.GroupPhoto")
	proto.RegisterType((*Group)(nil), "msg.Group")
	proto.RegisterType((*GroupFull)(nil), "msg.GroupFull")
	proto.RegisterType((*GroupParticipant)(nil), "msg.GroupParticipant")
	proto.RegisterType((*InputDocument)(nil), "msg.InputDocument")
	proto.RegisterType((*PrivacyRule)(nil), "msg.PrivacyRule")
	proto.RegisterType((*Label)(nil), "msg.Label")
	proto.RegisterType((*LabelsMany)(nil), "msg.LabelsMany")
	proto.RegisterType((*GeoLocation)(nil), "msg.GeoLocation")
	proto.RegisterType((*InputGeoLocation)(nil), "msg.InputGeoLocation")
}

func init() { proto.RegisterFile("chat.core.types.proto", fileDescriptor_fa76a373a8c28436) }

var fileDescriptor_fa76a373a8c28436 = []byte{
	// 3106 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x59, 0x4f, 0x6f, 0xdc, 0xc6,
	0x15, 0x17, 0xc9, 0xfd, 0x23, 0x3d, 0xad, 0xa4, 0xf1, 0xd8, 0xb2, 0x19, 0x47, 0x55, 0x04, 0xc2,
	0x49, 0x04, 0xa1, 0x56, 0x6c, 0x25, 0x4e, 0xdc, 0x43, 0x11, 0x48, 0x5a, 0xc9, 0x11, 0x62, 0xd9,
	0xc2, 0x4a, 0x4e, 0x80, 0x1e, 0x8a, 0x52, 0xcb, 0xd1, 0x8a, 0x30, 0x97, 0xb3, 0x21, 0x67, 0xe5,
	0x6c, 0x81, 0x5e, 0x7a, 0xeb, 0xa9, 0x39, 0x14, 0x68, 0x8b, 0xa0, 0xe8, 0xa1, 0x1f, 0xa2, 0x68,
	0x4f, 0x3d, 0xe6, 0x18, 0xa0, 0x97, 0xf4, 0x52, 0xb4, 0xc9, 0x47, 0x28, 0xd0, 0xa2, 0xa7, 0x16,
	0x6f, 0xc8, 0x19, 0x0e, 0xb9, 0xbb, 0xb6, 0xda, 0x06, 0xcd, 0x49, 0x3b, 0xbf, 0xdf, 0xe3, 0xcc,
	0x7b, 0x6f, 0xde, 0xbc, 0x79, 0x6f, 0x04, 0xcb, 0xdd, 0x73, 0x5f, 0x6c, 0x76, 0x79, 0xc2, 0x36,
	0xc5, 0x68, 0xc0, 0xd2, 0xcd, 0x41, 0xc2, 0x05, 0xa7, 0x4e, 0x3f, 0xed, 0xdd, 0xbc, 0xdd, 0x0b,
	0xc5, 0xf9, 0xf0, 0x74, 0xb3, 0xcb, 0xfb, 0x6f, 0xf4, 0x78, 0x8f, 0xbf, 0x21, 0xb9, 0xd3, 0xe1,
	0x99, 0x1c, 0xc9, 0x81, 0xfc, 0x95, 0x7d, 0xe3, 0xfd, 0x08, 0x96, 0x0e, 0x59, 0x9a, 0xfa, 0x3d,
	0xb6, 0x17, 0x5f, 0xb0, 0x88, 0x0f, 0x18, 0x7d, 0x0d, 0xe6, 0x77, 0x79, 0x9c, 0x8a, 0x64, 0xd8,
	0x15, 0x3c, 0x71, 0xad, 0x35, 0x7b, 0xdd, 0xd9, 0xa9, 0x7d, 0xf6, 0xe7, 0x57, 0x66, 0x3a, 0x26,
	0x41, 0x3d, 0x98, 0xeb, 0xb0, 0x8f, 0x86, 0x2c, 0x15, 0x07, 0x6d, 0xd7, 0x5e, 0xb3, 0xd7, 0x1b,
	0xb9, 0x54, 0x01, 0xd3, 0x55, 0x68, 0xe6, 0xd3, 0xbb, 0xb5, 0x35, 0x7b, 0xbd, 0x95, 0x4b, 0x28,
	0xd0, 0x0b, 0x80, 0xe4, 0x3f, 0x77, 0x79, 0x2c, 0xfc, 0x30, 0x66, 0x09, 0x5d, 0x81, 0xc6, 0x43,
	0x16, 0xf7, 0xc4, 0xb9, 0x5c, 0xba, 0x9e, 0x7f, 0x92, 0x63, 0x74, 0x0b, 0xe6, 0x94, 0xa6, 0xa9,
	0x6b, 0xaf, 0x39, 0xeb, 0xf3, 0x5b, 0xd7, 0x36, 0xfb, 0x69, 0x6f, 0xb3, 0x62, 0x46, 0xa7, 0x10,
	0xf3, 0x7e, 0x6f, 0xc1, 0xe2, 0x93, 0x41, 0xe0, 0x8b, 0xff, 0xdc, 0xc8, 0x15, 0x68, 0x64, 0x5f,
	0x4a, 0x0b, 0x95, 0xfe, 0x39, 0x26, 0xd9, 0x5d, 0x3e, 0x8c, 0x85, 0xeb, 0x98, 0xaa, 0x66, 0x18,
	0x5d, 0x83, 0xd9, 0x4c, 0xee, 0xa0, 0x2d, 0xad, 0x57, 0x0b, 0x68, 0x14, 0x5d, 0x78, 0x12, 0xf6,
	0x59, 0x2a, 0xfc, 0xfe, 0xc0, 0xad, 0x1b, 0x22, 0x05, 0xec, 0xfd, 0xcd, 0x82, 0xa5, 0xec, 0x83,
	0xcb, 0xba, 0xe8, 0x36, 0x34, 0xb3, 0x0f, 0x94, 0x83, 0xae, 0x4a, 0x07, 0x95, 0x3d, 0xd0, 0x51,
	0x32, 0xe8, 0x8a, 0xc3, 0x30, 0xd6, 0x9a, 0x3a, 0xa6, 0x2b, 0x0c, 0x42, 0xca, 0xf9, 0x1f, 0x4f,
	0xb4, 0xc8, 0x24, 0xe8, 0x2b, 0x50, 0x7f, 0x92, 0xb2, 0x24, 0x75, 0xeb, 0x72, 0xf1, 0xb9, 0x6c,
	0xf1, 0x94, 0x25, 0x9d, 0x0c, 0xa7, 0x1e, 0x34, 0x1e, 0x24, 0x7c, 0x38, 0x48, 0xdd, 0x86, 0x94,
	0x00, 0x29, 0x21, 0xa1, 0x4e, 0xce, 0x78, 0x09, 0xb4, 0x8e, 0x30, 0x40, 0xf3, 0x5d, 0x45, 0x8b,
	0xb7, 0x87, 0xe2, 0xfc, 0xa0, 0xed, 0x5a, 0x6b, 0x96, 0x5e, 0x37, 0xc7, 0xe8, 0x2d, 0x80, 0x5c,
	0xf0, 0x7d, 0x36, 0x72, 0xed, 0x35, 0x4b, 0xef, 0x94, 0x81, 0x63, 0x30, 0x1e, 0xf9, 0xa3, 0x88,
	0xfb, 0x81, 0x34, 0x52, 0x07, 0x63, 0x0e, 0x7a, 0xbf, 0xb5, 0x60, 0x59, 0x2e, 0xba, 0x17, 0x77,
	0x93, 0xd1, 0x40, 0xb0, 0x20, 0x67, 0x70, 0xfe, 0x63, 0x96, 0x5c, 0xb0, 0xe4, 0xd8, 0x8f, 0x44,
	0x29, 0x58, 0x0c, 0x1c, 0x77, 0x33, 0x5f, 0x2d, 0x3f, 0x10, 0x35, 0xb5, 0x9b, 0x1a, 0x46, 0x99,
	0x63, 0x96, 0xa6, 0x21, 0x8f, 0x2b, 0xae, 0x2e, 0x60, 0x7a, 0x07, 0x66, 0xd5, 0x2e, 0x49, 0x2f,
	0x4f, 0x8b, 0x70, 0x2d, 0xe5, 0x7d, 0x17, 0xea, 0x7b, 0x49, 0xc2, 0x13, 0xea, 0x42, 0x6d, 0x97,
	0x07, 0x4c, 0xaa, 0x38, 0x97, 0xcf, 0x2c, 0x11, 0x7a, 0x13, 0xea, 0x07, 0x82, 0xf5, 0x53, 0xa9,
	0x98, 0xa2, 0x32, 0xc8, 0x7b, 0x15, 0x9c, 0xed, 0xee, 0x53, 0xba, 0xaa, 0xbd, 0x78, 0xd0, 0x4e,
	0x5d, 0x6b, 0xcd, 0x59, 0xaf, 0x75, 0x0c, 0xc4, 0xbb, 0x05, 0xb5, 0x1d, 0xce, 0x23, 0xdc, 0x8b,
	0x0e, 0x4b, 0x87, 0xb9, 0x27, 0x66, 0xd5, 0x5e, 0x64, 0x98, 0xf7, 0x85, 0x03, 0x8d, 0x76, 0xe8,
	0x47, 0xbc, 0x47, 0x57, 0xa1, 0x71, 0xc4, 0x58, 0x22, 0x37, 0x0d, 0x2d, 0x6d, 0xa0, 0xe0, 0x1d,
	0xab, 0x93, 0xa3, 0x78, 0x40, 0xf0, 0xd7, 0xc9, 0x68, 0x90, 0x1d, 0x2f, 0x15, 0xc8, 0x1a, 0xa5,
	0xeb, 0xd0, 0x3a, 0xe1, 0x83, 0xc2, 0xab, 0xa6, 0xc7, 0x4a, 0x0c, 0xfd, 0x36, 0x2c, 0x76, 0x98,
	0x1f, 0x1c, 0xc4, 0xa7, 0xfc, 0xe3, 0x43, 0xff, 0xe3, 0x4a, 0x80, 0x56, 0x38, 0xba, 0x09, 0x4b,
	0x88, 0x3c, 0x1e, 0x0a, 0x2d, 0x6e, 0x1e, 0xbf, 0x2a, 0x89, 0xb1, 0xff, 0x24, 0x4e, 0x98, 0x1f,
	0x64, 0xa7, 0xbd, 0x61, 0x28, 0x6b, 0x12, 0xf4, 0x35, 0x80, 0xed, 0x6e, 0x97, 0xa5, 0xe9, 0x7b,
	0x7e, 0x7a, 0xee, 0x36, 0x65, 0x52, 0x54, 0x56, 0x1b, 0x0c, 0x7d, 0x17, 0x16, 0x1f, 0x71, 0x11,
	0x9e, 0x8d, 0x8e, 0x99, 0x10, 0x61, 0xdc, 0x4b, 0xdd, 0xd9, 0x35, 0x6b, 0x7d, 0x7e, 0xeb, 0x86,
	0xdc, 0x68, 0x34, 0xbf, 0x4c, 0x77, 0x2a, 0xe2, 0x68, 0xee, 0x21, 0x8b, 0x45, 0xc8, 0x63, 0x96,
	0xeb, 0x34, 0xb7, 0x66, 0x69, 0x9d, 0x2a, 0x1c, 0xee, 0xd8, 0x51, 0x18, 0xc7, 0x2c, 0x70, 0xc1,
	0xdc, 0xb1, 0x0c, 0xa3, 0xaf, 0x43, 0xbd, 0x9d, 0xf8, 0x67, 0xc2, 0x9d, 0x97, 0x3a, 0x5c, 0x91,
	0x3a, 0x48, 0x24, 0x77, 0x6f, 0x27, 0xe3, 0xbd, 0x1f, 0x40, 0x0d, 0x55, 0xa3, 0xd7, 0xc1, 0x1e,
	0xdb, 0x53, 0xfb, 0xa0, 0x8d, 0xd1, 0x37, 0xb6, 0x97, 0x12, 0xa9, 0xf8, 0xc5, 0x99, 0xe6, 0x17,
	0x4f, 0xc0, 0xdc, 0x41, 0x3c, 0x18, 0x8a, 0xe7, 0x2e, 0xf3, 0xba, 0xb1, 0xcc, 0xe2, 0xd6, 0x82,
	0x76, 0x19, 0x82, 0xff, 0xd5, 0xaa, 0xc7, 0xf9, 0xaa, 0x98, 0x9e, 0x30, 0x68, 0xf1, 0xef, 0x78,
	0xd0, 0x66, 0x68, 0x65, 0x52, 0x7b, 0xea, 0xa4, 0x1f, 0xc2, 0x42, 0x66, 0x8a, 0x9f, 0xa6, 0xcf,
	0x78, 0x12, 0xd0, 0x15, 0xa8, 0x1f, 0x27, 0x83, 0xb1, 0x79, 0x33, 0x90, 0x52, 0xb0, 0xb6, 0x4b,
	0x77, 0x8c, 0xb5, 0x4d, 0xaf, 0x81, 0x7d, 0x78, 0xb7, 0x94, 0xab, 0xec, 0xc3, 0xbb, 0xde, 0xaf,
	0x2d, 0xb8, 0x22, 0x67, 0xde, 0x0f, 0x23, 0xf6, 0x90, 0x77, 0x7d, 0xdc, 0x69, 0x4c, 0x2c, 0xbb,
	0xd1, 0x30, 0x15, 0x5a, 0x73, 0xb5, 0x01, 0x05, 0x8c, 0xa6, 0xe1, 0x37, 0x79, 0x76, 0x32, 0x4c,
	0xcb, 0xd0, 0xcb, 0xfa, 0x0b, 0x13, 0xe9, 0x07, 0x2c, 0xc1, 0x6c, 0xe5, 0xd6, 0x8c, 0xa8, 0x53,
	0xa0, 0xf7, 0x43, 0x68, 0x7d, 0x53, 0xba, 0x79, 0x3f, 0xb5, 0x60, 0x0e, 0x77, 0xea, 0xe8, 0x1c,
	0x4b, 0xa2, 0xdb, 0x30, 0x2b, 0x7f, 0xec, 0x84, 0x3d, 0xb9, 0xb0, 0x8a, 0x6e, 0x53, 0xbd, 0x8e,
	0x16, 0xa1, 0x77, 0x01, 0xe4, 0xef, 0xe3, 0xbe, 0x1f, 0x45, 0x52, 0x91, 0x89, 0x1f, 0x18, 0x42,
	0x74, 0x0d, 0x9a, 0x72, 0xa4, 0x93, 0x93, 0x52, 0x4a, 0xc1, 0xde, 0x9f, 0x6a, 0x50, 0x93, 0x91,
	0x35, 0x2d, 0x9e, 0x3d, 0x98, 0xdb, 0x0f, 0x93, 0x54, 0x3c, 0xf2, 0xfb, 0xac, 0x94, 0x9e, 0x0b,
	0x18, 0x53, 0xe5, 0x43, 0x3f, 0x17, 0x71, 0x0c, 0x11, 0x8d, 0xca, 0x6a, 0x23, 0x65, 0x49, 0x8c,
	0x12, 0xb8, 0x2b, 0x5a, 0x42, 0xa1, 0xf4, 0x36, 0x34, 0x8e, 0x85, 0x2f, 0x86, 0xa9, 0xcc, 0x75,
	0x8b, 0x5b, 0x4b, 0xfa, 0x66, 0xce, 0x60, 0x95, 0x16, 0xb2, 0x11, 0x5e, 0x7a, 0x1d, 0x96, 0x8a,
	0x24, 0xec, 0x0a, 0x16, 0xc8, 0x94, 0xa7, 0x12, 0x87, 0x81, 0x5f, 0x3a, 0xe3, 0xdd, 0x82, 0xba,
	0x74, 0x48, 0x9e, 0xe8, 0x16, 0xf5, 0xda, 0x12, 0xed, 0x64, 0x24, 0xbd, 0x0e, 0xce, 0x4e, 0xc8,
	0x65, 0x2e, 0x53, 0xfa, 0x23, 0x80, 0xb7, 0xd7, 0xd1, 0x39, 0x8f, 0x99, 0x0b, 0x06, 0x93, 0x41,
	0xca, 0x35, 0xc7, 0x8c, 0xc5, 0x32, 0x83, 0x39, 0xa6, 0x6b, 0x10, 0xa5, 0x5b, 0xd0, 0x92, 0xd3,
	0x3f, 0xf0, 0xa3, 0x88, 0x25, 0x23, 0xb7, 0x25, 0xcb, 0x8e, 0xaa, 0x0a, 0x25, 0x19, 0x79, 0x5f,
	0xa6, 0x3b, 0x5c, 0xb8, 0x0b, 0x6b, 0x96, 0x36, 0x3c, 0x83, 0x30, 0xfe, 0xdb, 0x2c, 0x62, 0xe8,
	0x96, 0x45, 0x83, 0x55, 0x20, 0xf2, 0x3b, 0x11, 0xef, 0x3e, 0x65, 0x81, 0xbb, 0x64, 0xf2, 0x39,
	0x48, 0x5f, 0x83, 0xe6, 0x0e, 0x17, 0x07, 0xf1, 0x19, 0x77, 0x89, 0xf4, 0x46, 0x4b, 0xaa, 0x92,
	0x63, 0x1d, 0x45, 0xa2, 0x65, 0x8f, 0xcf, 0xce, 0xc2, 0x6e, 0xe8, 0x47, 0xee, 0x15, 0x63, 0x22,
	0x8d, 0x7a, 0x1f, 0x81, 0x83, 0x0a, 0x3d, 0x27, 0x21, 0x8f, 0x05, 0x55, 0x6d, 0x2c, 0x5a, 0x4a,
	0xf1, 0xa4, 0xa3, 0x25, 0xdf, 0x8a, 0x5a, 0x65, 0x2b, 0xbc, 0x27, 0x30, 0xbf, 0xc3, 0xc5, 0x2e,
	0xef, 0xf7, 0xfd, 0x38, 0x48, 0xd1, 0xd6, 0xfc, 0x77, 0xa9, 0xe8, 0x50, 0x20, 0xde, 0x9c, 0x6d,
	0x96, 0x76, 0x93, 0x70, 0x80, 0x47, 0x47, 0xd6, 0x66, 0x4a, 0xc6, 0x24, 0xbc, 0x7f, 0x58, 0xda,
	0x29, 0xf4, 0xa6, 0xb4, 0x2a, 0x3f, 0xb0, 0xb3, 0xca, 0x37, 0x1d, 0x69, 0xea, 0x8a, 0x4e, 0xcf,
	0xb6, 0x71, 0x61, 0x17, 0xc9, 0xb9, 0xb4, 0x9a, 0x33, 0x65, 0x35, 0xba, 0x55, 0x32, 0xc2, 0xad,
	0xc9, 0x80, 0x20, 0x6a, 0x25, 0x85, 0x77, 0x4a, 0x96, 0x7a, 0x78, 0x4b, 0x44, 0x61, 0xcc, 0x1e,
	0x30, 0xee, 0xd6, 0x8d, 0xed, 0x28, 0x60, 0xba, 0x85, 0xa9, 0x19, 0x07, 0x47, 0x91, 0xdf, 0x65,
	0xef, 0xf1, 0x28, 0x60, 0x89, 0xdb, 0x30, 0xb4, 0x18, 0xa7, 0xbd, 0x4f, 0x6d, 0xd9, 0x8b, 0x08,
	0xbf, 0x2b, 0xfe, 0x0f, 0x69, 0xa2, 0x7c, 0x5e, 0x6b, 0x53, 0xcf, 0xab, 0x3e, 0x71, 0x75, 0xb3,
	0x5e, 0xd4, 0x27, 0x4e, 0x07, 0x4f, 0x63, 0x62, 0xf0, 0x78, 0x30, 0xbb, 0x1b, 0x85, 0x2c, 0xc6,
	0xd6, 0xb0, 0x59, 0xb2, 0x44, 0xe3, 0x97, 0xcb, 0x08, 0xde, 0xcf, 0x9b, 0x30, 0x8f, 0xa0, 0x6a,
	0x04, 0xae, 0x19, 0xde, 0xc9, 0xef, 0xc4, 0xec, 0xf6, 0xc8, 0x2b, 0x4d, 0xfb, 0x85, 0x95, 0xa6,
	0x33, 0xb1, 0xd2, 0xc4, 0x3b, 0x2a, 0x61, 0xbe, 0x60, 0xc1, 0xe3, 0xb8, 0x54, 0x3a, 0x16, 0x30,
	0xce, 0xb2, 0x17, 0x84, 0x99, 0x88, 0x59, 0x2e, 0x6a, 0x94, 0xae, 0xc3, 0xfc, 0xfe, 0xb3, 0xe0,
	0x98, 0xc5, 0x81, 0x54, 0xa6, 0x51, 0x52, 0xc6, 0xa4, 0xe8, 0x06, 0xb4, 0xf6, 0x9f, 0x05, 0xbb,
	0xe7, 0x7e, 0x1c, 0xb3, 0x68, 0xcc, 0x4b, 0x25, 0x8e, 0xde, 0x87, 0xab, 0xc5, 0xb8, 0x28, 0x86,
	0x67, 0x4b, 0x9f, 0x4c, 0x12, 0xc1, 0x5d, 0xdc, 0x8f, 0xfc, 0x5e, 0xea, 0xce, 0x19, 0x46, 0x67,
	0x90, 0xec, 0xe7, 0x32, 0x41, 0xe9, 0x16, 0x28, 0xf5, 0x73, 0x05, 0x81, 0x49, 0x64, 0x87, 0x07,
	0x23, 0x77, 0xde, 0x4c, 0x22, 0x88, 0xe0, 0x2e, 0x6b, 0x53, 0x5b, 0xe5, 0x5d, 0xd6, 0x76, 0x66,
	0x8d, 0xb6, 0x60, 0xb1, 0xc0, 0x9a, 0xda, 0x5d, 0x30, 0xae, 0x11, 0x93, 0x90, 0xf9, 0x16, 0xeb,
	0x73, 0x77, 0xd1, 0x90, 0xc8, 0x20, 0xcc, 0x31, 0x1d, 0x36, 0x88, 0x46, 0x27, 0xdc, 0x5d, 0x32,
	0xb4, 0x54, 0x20, 0xdd, 0x80, 0x85, 0x5c, 0xe1, 0xed, 0xae, 0x3c, 0xf7, 0xc4, 0xa8, 0x4a, 0xca,
	0x14, 0x9e, 0xd0, 0x12, 0xd0, 0xf6, 0x85, 0x2f, 0x93, 0xab, 0x2a, 0xb1, 0xc6, 0x69, 0xba, 0x89,
	0x0d, 0x99, 0x08, 0x45, 0xc8, 0x52, 0x97, 0xca, 0x54, 0x41, 0xcb, 0x0d, 0x99, 0x08, 0xc5, 0xa8,
	0xa3, 0x65, 0xe8, 0x16, 0x36, 0x82, 0x41, 0xe8, 0x4b, 0xbf, 0x5e, 0x5d, 0xb3, 0xd6, 0x17, 0xf3,
	0xe8, 0xd6, 0x68, 0xd1, 0x18, 0xe6, 0x00, 0xda, 0x2f, 0x07, 0xee, 0x35, 0x43, 0x97, 0x0c, 0x42,
	0x1f, 0x4a, 0x53, 0x0f, 0xfd, 0xe4, 0xe9, 0x70, 0xe0, 0x2e, 0x1b, 0x97, 0x9c, 0x49, 0x64, 0x5d,
	0x8d, 0x1e, 0x4a, 0xcb, 0xae, 0x1b, 0xb3, 0x55, 0x49, 0x7a, 0x13, 0xb3, 0xc5, 0x29, 0x86, 0x58,
	0xea, 0xde, 0x58, 0x73, 0xd6, 0xeb, 0x1d, 0x3d, 0xc6, 0x58, 0xff, 0x20, 0xf4, 0x31, 0x23, 0xb7,
	0x5d, 0xd7, 0xbc, 0x55, 0x15, 0xea, 0xfd, 0xdd, 0x82, 0x96, 0xd9, 0x25, 0x7c, 0x0d, 0x87, 0xd0,
	0x85, 0x5a, 0xdb, 0x17, 0xac, 0x74, 0xfe, 0x24, 0xa2, 0x83, 0xb0, 0x3e, 0x16, 0x84, 0xe6, 0xe6,
	0x34, 0x2e, 0xb1, 0x39, 0x46, 0x30, 0x35, 0x27, 0x05, 0x93, 0x3e, 0xe4, 0xf2, 0x84, 0x59, 0xd5,
	0x43, 0x7e, 0xd0, 0xf6, 0x7e, 0x65, 0xe9, 0x78, 0xcb, 0x66, 0xa7, 0x77, 0xf2, 0x8e, 0xc4, 0x92,
	0x75, 0xd5, 0xf5, 0xf1, 0xf5, 0xc7, 0x5a, 0x93, 0x15, 0x68, 0x3c, 0x3e, 0x3b, 0x4b, 0x99, 0x28,
	0x35, 0x4b, 0x39, 0x66, 0xbc, 0xef, 0x38, 0x13, 0xde, 0x77, 0x8a, 0x0e, 0xa5, 0x26, 0xf5, 0xab,
	0x74, 0x28, 0xde, 0xf7, 0xa1, 0xd5, 0x39, 0xde, 0x3e, 0x1a, 0x9e, 0x46, 0x61, 0xf7, 0x7d, 0x36,
	0xc2, 0xf0, 0xd9, 0x0f, 0xe3, 0x1e, 0x4b, 0x8e, 0x92, 0x30, 0x2e, 0x3f, 0x5f, 0x98, 0x04, 0xb6,
	0x20, 0x8f, 0x4a, 0x17, 0x8b, 0xf5, 0x08, 0xb1, 0x3d, 0xa9, 0xc4, 0x82, 0xc2, 0xf6, 0x3c, 0x06,
	0xcd, 0xf6, 0x7b, 0xf2, 0x9d, 0xe6, 0xd2, 0x53, 0xe3, 0x6d, 0x92, 0x84, 0x95, 0x7b, 0x2b, 0x83,
	0xb0, 0xd0, 0x78, 0xc0, 0xe2, 0x92, 0xa5, 0x08, 0x78, 0x3f, 0xb3, 0x64, 0xd9, 0x16, 0xb3, 0xfc,
	0x72, 0x2c, 0x5d, 0x2a, 0xd6, 0x94, 0x4b, 0xe5, 0xeb, 0xb9, 0x24, 0xf5, 0xe5, 0x57, 0x1b, 0xbb,
	0xfc, 0xbc, 0x01, 0xd0, 0xf1, 0xfe, 0xbc, 0x48, 0xb4, 0xd6, 0x78, 0xa2, 0xf5, 0x60, 0xee, 0x70,
	0x28, 0xd8, 0x93, 0x58, 0x84, 0x91, 0x2c, 0x80, 0xf4, 0xd5, 0xa2, 0x61, 0xfc, 0xfe, 0x98, 0x0f,
	0xe3, 0xa0, 0x54, 0xb2, 0x64, 0x90, 0xf7, 0xa9, 0x95, 0xf7, 0xa7, 0xd8, 0x84, 0x18, 0x8d, 0x92,
	0x35, 0xb1, 0x51, 0xba, 0x05, 0x70, 0xc2, 0x85, 0x1f, 0x1d, 0xf9, 0x89, 0x48, 0x4b, 0xd1, 0x65,
	0xe0, 0xe8, 0x03, 0x94, 0x1f, 0xf7, 0x81, 0x42, 0xe5, 0xf5, 0xd0, 0xbe, 0xb7, 0x7b, 0xce, 0xba,
	0x4f, 0xd3, 0x61, 0xbf, 0xe4, 0x09, 0x93, 0xf0, 0x3e, 0xb1, 0x00, 0x64, 0x30, 0x7c, 0x23, 0x1d,
	0x97, 0x35, 0xa9, 0xe3, 0xfa, 0xa7, 0x05, 0xf5, 0x2c, 0x3e, 0xa7, 0xd5, 0x52, 0x37, 0xa1, 0x7e,
	0x12, 0x8a, 0xa8, 0x12, 0x8f, 0x12, 0x2a, 0x57, 0x02, 0xce, 0xe4, 0x4a, 0x60, 0x1d, 0x5a, 0xe8,
	0xc7, 0xb0, 0x1b, 0x0e, 0xfc, 0x58, 0xa4, 0xd2, 0x3b, 0xca, 0xcd, 0x25, 0xa6, 0x52, 0x33, 0x58,
	0x13, 0x6a, 0x86, 0x57, 0x55, 0xe8, 0x60, 0xf6, 0x52, 0x5d, 0x99, 0x54, 0x5f, 0xc2, 0x2a, 0x8a,
	0x5e, 0x55, 0xe5, 0x52, 0x53, 0x96, 0x4b, 0x86, 0x58, 0xa9, 0x5e, 0xfa, 0x97, 0x05, 0x73, 0xd9,
	0xc7, 0x43, 0xe9, 0xab, 0xcc, 0x11, 0xf9, 0x56, 0x98, 0x2f, 0xad, 0xb9, 0x87, 0xf4, 0x6b, 0xad,
	0x3d, 0xe5, 0xb5, 0xf6, 0x3b, 0x15, 0x53, 0x1d, 0x29, 0xb7, 0x6c, 0x2c, 0x5f, 0xb0, 0x15, 0xdb,
	0xc7, 0x5f, 0xb9, 0xb2, 0xe7, 0xcc, 0x4b, 0xbf, 0x72, 0xbd, 0x59, 0x69, 0xdc, 0xb2, 0x17, 0xe5,
	0x31, 0xd3, 0x4b, 0x42, 0xde, 0x2f, 0x6c, 0x20, 0x55, 0xc5, 0x5e, 0xf8, 0xaa, 0xf3, 0xf5, 0xe4,
	0x8d, 0xcd, 0xfc, 0x1e, 0xa8, 0xc9, 0x7b, 0x20, 0x7b, 0xb5, 0x35, 0xb4, 0x78, 0xc1, 0x03, 0x55,
	0x5d, 0x3e, 0x19, 0x4f, 0x2a, 0xc6, 0x5f, 0x5c, 0x70, 0x5f, 0xae, 0x98, 0x4e, 0xf3, 0x37, 0xa9,
	0x36, 0xef, 0x0e, 0xfb, 0x2c, 0x9e, 0xde, 0x38, 0x5e, 0xf2, 0x91, 0xab, 0xfc, 0xb2, 0xe3, 0x4c,
	0x7c, 0xd9, 0xf1, 0x18, 0xcc, 0x1f, 0x25, 0xe1, 0x85, 0xdf, 0x1d, 0x75, 0x86, 0x11, 0xa3, 0xf7,
	0xf5, 0xd0, 0xb8, 0x32, 0xb3, 0xd6, 0xcb, 0xc0, 0x55, 0xa6, 0x31, 0x20, 0xba, 0x02, 0xcd, 0x6c,
	0xb7, 0xb2, 0x60, 0x75, 0x76, 0x6c, 0x3c, 0xf4, 0x39, 0xe4, 0x7d, 0x04, 0x75, 0x59, 0xbc, 0x18,
	0x1d, 0x42, 0xdd, 0xe8, 0x10, 0xa6, 0xb7, 0xc2, 0x2b, 0xd0, 0xd8, 0xe5, 0x11, 0x1f, 0x26, 0xa5,
	0x4d, 0xcd, 0x31, 0xcc, 0x14, 0xd9, 0xfb, 0xaa, 0xf9, 0xd2, 0x95, 0x41, 0xde, 0x1d, 0x00, 0xb9,
	0x64, 0x7a, 0xe8, 0xc7, 0x58, 0x0d, 0x37, 0xb2, 0x91, 0x7c, 0x3a, 0x57, 0x87, 0x4d, 0x42, 0x9d,
	0x9c, 0xf1, 0xde, 0x85, 0xf9, 0x07, 0x8c, 0xeb, 0x87, 0xb1, 0xeb, 0xe0, 0x3c, 0xf4, 0xb3, 0x6b,
	0xd3, 0x56, 0x57, 0xdf, 0x43, 0x5f, 0xa0, 0xb2, 0x0f, 0x79, 0xdc, 0x93, 0xca, 0x2a, 0x42, 0x22,
	0x5e, 0x1b, 0x88, 0xdc, 0xc1, 0xff, 0x69, 0x96, 0x8d, 0x5f, 0x5a, 0xd0, 0x3a, 0x19, 0x0d, 0xc2,
	0xb8, 0x97, 0x57, 0xc5, 0xd7, 0x81, 0x9a, 0xe3, 0xec, 0x37, 0x99, 0xa1, 0xab, 0x70, 0xd3, 0xc4,
	0x3b, 0xac, 0xcb, 0x93, 0x20, 0x8c, 0x7b, 0x1f, 0xf0, 0xb0, 0xcb, 0x88, 0x35, 0x9d, 0x0f, 0x03,
	0xc6, 0x89, 0x4d, 0x5f, 0x82, 0x65, 0x93, 0x7f, 0x32, 0x88, 0xb8, 0x8f, 0x3c, 0x71, 0xaa, 0x4b,
	0xee, 0xfa, 0x71, 0x97, 0x45, 0xa4, 0xb6, 0xf1, 0xbd, 0xa2, 0x4a, 0xa4, 0xad, 0xec, 0xf7, 0x31,
	0x8b, 0xce, 0xc8, 0x8c, 0x1a, 0xe1, 0x86, 0x13, 0x8b, 0x2e, 0xc0, 0x1c, 0x8e, 0xe4, 0x49, 0x27,
	0x36, 0xa5, 0xb0, 0x28, 0x45, 0x87, 0x03, 0x85, 0x39, 0x74, 0x09, 0xe6, 0x11, 0xcb, 0xbb, 0x22,
	0x52, 0xdb, 0xf8, 0xb1, 0x05, 0x50, 0xbc, 0x77, 0xd1, 0x65, 0xb8, 0x52, 0x8c, 0x1e, 0x9f, 0x9d,
	0x61, 0x67, 0x4e, 0x66, 0xe8, 0x35, 0x20, 0x06, 0x2c, 0xfb, 0x75, 0x62, 0xa1, 0xbe, 0x05, 0xda,
	0x61, 0x5d, 0x16, 0x8b, 0x68, 0x44, 0xec, 0x32, 0x8e, 0x99, 0xe0, 0x43, 0xc6, 0x9e, 0x12, 0x87,
	0xde, 0x80, 0xab, 0x65, 0xfc, 0x90, 0xc7, 0xe2, 0x9c, 0xd4, 0x36, 0x7e, 0x62, 0x1b, 0xed, 0x01,
	0xea, 0xad, 0x07, 0x7b, 0xfd, 0x81, 0x18, 0x91, 0x19, 0x7a, 0x05, 0xeb, 0xcb, 0x1c, 0x3b, 0xe2,
	0x51, 0x44, 0x2c, 0x54, 0x55, 0x43, 0xea, 0xf4, 0x12, 0x1b, 0x55, 0xd5, 0x70, 0x5e, 0x26, 0x11,
	0x87, 0xba, 0x70, 0x4d, 0xa3, 0x46, 0xa0, 0x90, 0x5a, 0x49, 0xfe, 0x20, 0xbe, 0x90, 0xbb, 0x58,
	0x2f, 0xc9, 0x7f, 0xc8, 0x4e, 0xf5, 0xfc, 0x0d, 0x34, 0x4e, 0x33, 0x1d, 0x96, 0xb2, 0xe4, 0x82,
	0x05, 0x5b, 0xa4, 0x39, 0x11, 0x7f, 0x93, 0xcc, 0x4e, 0xc4, 0xdf, 0x22, 0x73, 0x13, 0xf1, 0x7b,
	0x04, 0x36, 0xfe, 0xe0, 0xc0, 0xa2, 0x8c, 0xe7, 0xc2, 0x21, 0x37, 0xe0, 0x6a, 0x19, 0x51, 0x5e,
	0x79, 0x09, 0x96, 0xcb, 0x84, 0x32, 0x40, 0xee, 0x4d, 0x99, 0x92, 0x5e, 0xb3, 0xc7, 0x3f, 0x29,
	0x7c, 0xe4, 0xc1, 0x6a, 0x99, 0xca, 0x62, 0x93, 0x05, 0xda, 0xfa, 0x1a, 0xbd, 0x09, 0xd7, 0xcb,
	0x32, 0x9a, 0xab, 0xd3, 0x6f, 0xc1, 0x4b, 0x65, 0xce, 0x74, 0x74, 0x63, 0x9c, 0x36, 0xfd, 0xda,
	0xa4, 0x2f, 0xc3, 0x8d, 0x32, 0x5d, 0x38, 0x77, 0x76, 0x3a, 0xf9, 0x26, 0x99, 0x9b, 0x4e, 0xbe,
	0x45, 0x60, 0x3a, 0x79, 0x8f, 0xcc, 0x4f, 0x27, 0xdf, 0x26, 0xad, 0xe9, 0xe4, 0x3b, 0x64, 0x61,
	0x3a, 0x79, 0x9f, 0x2c, 0x6e, 0xfc, 0xce, 0xd1, 0x1d, 0x75, 0xd1, 0xeb, 0xa0, 0xe7, 0xc7, 0x1b,
	0x20, 0x1e, 0x05, 0x64, 0x06, 0x67, 0x1b, 0xa3, 0x0e, 0x84, 0x1f, 0x85, 0x5d, 0x62, 0xd1, 0x15,
	0x70, 0xc7, 0xc8, 0xfc, 0x9f, 0x59, 0xc4, 0xce, 0x02, 0xb5, 0xc2, 0x3e, 0x49, 0x22, 0xe2, 0xe0,
	0x56, 0x8d, 0x31, 0x7b, 0x7d, 0x3f, 0x8c, 0x48, 0x6d, 0xe2, 0x9c, 0x78, 0x7b, 0x9d, 0xf8, 0x3d,
	0x52, 0x9f, 0xa8, 0xe9, 0x2e, 0x0f, 0x18, 0x69, 0xd0, 0x57, 0xe0, 0xe5, 0x09, 0x46, 0xa8, 0x17,
	0x41, 0xd2, 0xc4, 0xf4, 0x37, 0x26, 0x60, 0x1e, 0x87, 0xe7, 0xf1, 0x78, 0x2c, 0x9e, 0xc7, 0xdf,
	0x23, 0xf0, 0x5c, 0xfe, 0x6d, 0x32, 0xff, 0x5c, 0xfe, 0x1d, 0xd2, 0x7a, 0x2e, 0x7f, 0x9f, 0x2c,
	0x6c, 0xfc, 0x46, 0xd5, 0xee, 0x59, 0x89, 0x79, 0x15, 0x96, 0x8a, 0x91, 0x3a, 0x76, 0xcb, 0x70,
	0xa5, 0x00, 0x65, 0x05, 0xcc, 0x93, 0x6c, 0xa3, 0x0a, 0xf8, 0x11, 0x8f, 0x8d, 0x32, 0x87, 0xd8,
	0xe5, 0x99, 0xb6, 0x83, 0x7e, 0x18, 0x13, 0x07, 0x37, 0xbe, 0x02, 0xa6, 0x7b, 0xb1, 0x7f, 0x1a,
	0xb1, 0x80, 0xd4, 0x70, 0x1b, 0x0a, 0xb2, 0xcd, 0xfc, 0xae, 0x08, 0x2f, 0xb0, 0xd8, 0x26, 0xf5,
	0x8d, 0x53, 0x58, 0xaa, 0x14, 0x51, 0x28, 0x5d, 0x81, 0x0e, 0x59, 0xff, 0x94, 0x25, 0x64, 0x06,
	0x63, 0xa4, 0x42, 0x65, 0xeb, 0x5b, 0x18, 0x23, 0x15, 0x46, 0x99, 0x63, 0x6f, 0x74, 0xe0, 0xca,
	0xd1, 0x30, 0x3d, 0x3f, 0xe1, 0x4f, 0x59, 0x7c, 0x94, 0xf0, 0x8b, 0x30, 0x60, 0x09, 0x9a, 0xae,
	0xc1, 0xfd, 0x30, 0x61, 0xa7, 0x7e, 0x8a, 0xf7, 0x03, 0x81, 0x96, 0x86, 0xb7, 0x07, 0x38, 0xf3,
	0x35, 0x20, 0xc5, 0xd7, 0xc3, 0xf4, 0xfc, 0xfd, 0x50, 0x10, 0x7b, 0xe3, 0x8f, 0x36, 0x40, 0x5e,
	0xbf, 0x60, 0x1b, 0x8e, 0x37, 0x94, 0x1e, 0x3d, 0xe2, 0xf2, 0xaa, 0x41, 0x65, 0x35, 0xb6, 0x7b,
	0xee, 0x8b, 0x83, 0xf8, 0x22, 0x14, 0x79, 0x4a, 0x2b, 0x18, 0xf5, 0x9f, 0x8c, 0x2c, 0xa5, 0x15,
	0xb8, 0xec, 0x48, 0x1f, 0x0d, 0xa5, 0xe5, 0xf2, 0x0c, 0x18, 0x54, 0xc2, 0xcf, 0xc2, 0x88, 0xc9,
	0xba, 0x8f, 0xd4, 0x30, 0x12, 0x0a, 0x6e, 0x9f, 0x27, 0xcf, 0xfc, 0x24, 0x60, 0x41, 0x1e, 0x1c,
	0xa4, 0x5e, 0x56, 0x6e, 0xd7, 0x8f, 0x22, 0xd2, 0xc0, 0x4c, 0x5c, 0x60, 0x2a, 0x6c, 0xee, 0x92,
	0xe6, 0x64, 0x02, 0x33, 0xd7, 0x44, 0x02, 0xb3, 0xd6, 0x44, 0x02, 0x33, 0xd6, 0x44, 0x02, 0xb3,
	0xd5, 0x44, 0xe2, 0x6d, 0xd2, 0xc2, 0xda, 0xa5, 0x54, 0x15, 0x16, 0x82, 0x72, 0xaf, 0xa3, 0x88,
	0x3f, 0xdb, 0x8e, 0x22, 0x32, 0x83, 0x11, 0x5a, 0x25, 0xf2, 0xf4, 0x9f, 0xe6, 0xc1, 0x50, 0xb0,
	0xed, 0x30, 0xf5, 0xd5, 0x97, 0xa6, 0x8f, 0xf5, 0x97, 0xb2, 0x17, 0x22, 0xac, 0x32, 0xa9, 0xfa,
	0x2c, 0x63, 0xcf, 0x76, 0x56, 0x3e, 0xff, 0xeb, 0xea, 0xcc, 0x67, 0x5f, 0xae, 0x5a, 0x9f, 0x7f,
	0xb9, 0x6a, 0xfd, 0xe5, 0xcb, 0x55, 0xeb, 0x93, 0xaf, 0x56, 0x67, 0x3e, 0xff, 0x6a, 0x75, 0xe6,
	0x8b, 0xaf, 0x56, 0x67, 0xfe, 0x1d, 0x00, 0x00, 0xff, 0xff, 0x2f, 0x0f, 0x49, 0x0f, 0xb7, 0x25,
	0x00, 0x00,
}

func (m *MessageEnvelope) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageEnvelope) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageEnvelope) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x22
	}
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.RequestID))
	i--
	dAtA[i] = 0x11
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Constructor))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *MessageContainer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageContainer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageContainer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Envelopes) > 0 {
		for iNdEx := len(m.Envelopes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Envelopes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Length))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *UpdateEnvelope) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateEnvelope) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateEnvelope) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Timestamp))
	i--
	dAtA[i] = 0x28
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.UpdateID))
	i--
	dAtA[i] = 0x20
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.UCount))
	i--
	dAtA[i] = 0x18
	if m.Update != nil {
		i -= len(m.Update)
		copy(dAtA[i:], m.Update)
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Update)))
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Constructor))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *UpdateContainer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateContainer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateContainer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for iNdEx := len(m.Groups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Groups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Users) > 0 {
		for iNdEx := len(m.Users) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Users[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.MaxUpdateID))
	i--
	dAtA[i] = 0x20
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.MinUpdateID))
	i--
	dAtA[i] = 0x18
	if len(m.Updates) > 0 {
		for iNdEx := len(m.Updates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Updates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Length))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *ProtoMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtoMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtoMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MessageKey != nil {
		i -= len(m.MessageKey)
		copy(dAtA[i:], m.MessageKey)
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.MessageKey)))
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.AuthID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *ProtoEncryptedPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtoEncryptedPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtoEncryptedPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Envelope == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("Envelope")
	} else {
		{
			size, err := m.Envelope.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.SessionID))
	i--
	dAtA[i] = 0x18
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.MessageID))
	i--
	dAtA[i] = 0x10
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ServerSalt))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Items)
	copy(dAtA[i:], m.Items)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Items)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Code)
	copy(dAtA[i:], m.Code)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Code)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Ack) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ack) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ack) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MessageIDs) > 0 {
		for iNdEx := len(m.MessageIDs) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.MessageIDs[iNdEx]))
			i--
			dAtA[i] = 0x8
		}
	}
	return len(dAtA) - i, nil
}

func (m *Bool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Bool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.Result {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *Dialog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dialog) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Dialog) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Draft != nil {
		{
			size, err := m.Draft.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	i--
	if m.Pinned {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x50
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.MentionedCount))
	i--
	dAtA[i] = 0x48
	if m.NotifySettings != nil {
		{
			size, err := m.NotifySettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i--
	dAtA[i] = 0x39
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.UnreadCount))
	i--
	dAtA[i] = 0x30
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ReadOutboxMaxID))
	i--
	dAtA[i] = 0x28
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ReadInboxMaxID))
	i--
	dAtA[i] = 0x20
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.TopMessageID))
	i--
	dAtA[i] = 0x18
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.PeerType))
	i--
	dAtA[i] = 0x10
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.PeerID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *Peer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Peer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Peer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i--
	dAtA[i] = 0x19
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x10
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *InputPeer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputPeer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InputPeer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i--
	dAtA[i] = 0x19
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x10
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *InputUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InputUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i--
	dAtA[i] = 0x11
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.UserID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *InputPassword) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputPassword) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InputPassword) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.M1 != nil {
		i -= len(m.M1)
		copy(dAtA[i:], m.M1)
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.M1)))
		i--
		dAtA[i] = 0x1a
	}
	if m.A != nil {
		i -= len(m.A)
		copy(dAtA[i:], m.A)
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.A)))
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.SrpID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *InputFileLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputFileLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InputFileLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Version))
	i--
	dAtA[i] = 0x20
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i--
	dAtA[i] = 0x19
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.FileID))
	i--
	dAtA[i] = 0x10
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ClusterID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *FileLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i--
	dAtA[i] = 0x19
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.FileID))
	i--
	dAtA[i] = 0x10
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ClusterID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *UserPhoto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserPhoto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserPhoto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.PhotoID))
	i--
	dAtA[i] = 0x18
	if m.PhotoSmall == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("PhotoSmall")
	} else {
		{
			size, err := m.PhotoSmall.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PhotoBig == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("PhotoBig")
	} else {
		{
			size, err := m.PhotoBig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *User) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.Official {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x88
	if m.BotInfo != nil {
		{
			size, err := m.BotInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	i--
	if m.Blocked {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x78
	i--
	if m.Deleted {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x70
	i--
	if m.IsBot {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x68
	if len(m.PhotoGallery) > 0 {
		for iNdEx := len(m.PhotoGallery) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PhotoGallery[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.LastSeen))
	i--
	dAtA[i] = 0x58
	i -= len(m.Phone)
	copy(dAtA[i:], m.Phone)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Phone)))
	i--
	dAtA[i] = 0x52
	i -= len(m.Bio)
	copy(dAtA[i:], m.Bio)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Bio)))
	i--
	dAtA[i] = 0x4a
	if m.Photo != nil {
		{
			size, err := m.Photo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i--
	dAtA[i] = 0x39
	i--
	if m.Restricted {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x30
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Status))
	i--
	dAtA[i] = 0x28
	i -= len(m.Username)
	copy(dAtA[i:], m.Username)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Username)))
	i--
	dAtA[i] = 0x22
	i -= len(m.LastName)
	copy(dAtA[i:], m.LastName)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.LastName)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.FirstName)
	copy(dAtA[i:], m.FirstName)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.FirstName)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *Bot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Bot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Bio)
	copy(dAtA[i:], m.Bio)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Bio)))
	i--
	dAtA[i] = 0x22
	i -= len(m.Username)
	copy(dAtA[i:], m.Username)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Username)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *BotCommands) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BotCommands) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotCommands) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Description)
	copy(dAtA[i:], m.Description)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Description)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Command)
	copy(dAtA[i:], m.Command)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Command)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BotInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BotInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.InlinePlaceHolder)
	copy(dAtA[i:], m.InlinePlaceHolder)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.InlinePlaceHolder)))
	i--
	dAtA[i] = 0x32
	i--
	if m.InlineGeo {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x28
	if len(m.BotCommands) > 0 {
		for iNdEx := len(m.BotCommands) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BotCommands[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	i -= len(m.Description)
	copy(dAtA[i:], m.Description)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Description)))
	i--
	dAtA[i] = 0x1a
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.UserID))
	i--
	dAtA[i] = 0x10
	if m.Bot == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("Bot")
	} else {
		{
			size, err := m.Bot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContactUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContactUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContactUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Photo != nil {
		{
			size, err := m.Photo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ClientID))
	i--
	dAtA[i] = 0x38
	i -= len(m.Username)
	copy(dAtA[i:], m.Username)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Username)))
	i--
	dAtA[i] = 0x32
	i -= len(m.Phone)
	copy(dAtA[i:], m.Phone)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Phone)))
	i--
	dAtA[i] = 0x2a
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i--
	dAtA[i] = 0x21
	i -= len(m.LastName)
	copy(dAtA[i:], m.LastName)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.LastName)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.FirstName)
	copy(dAtA[i:], m.FirstName)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.FirstName)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *UserMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ViaBotID))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xc0
	if len(m.LabelIDs) > 0 {
		for iNdEx := len(m.LabelIDs) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.LabelIDs[iNdEx]))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb8
		}
	}
	if m.ReplyMarkupData != nil {
		i -= len(m.ReplyMarkupData)
		copy(dAtA[i:], m.ReplyMarkupData)
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.ReplyMarkupData)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ReplyMarkup))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa8
	if m.Media != nil {
		i -= len(m.Media)
		copy(dAtA[i:], m.Media)
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Media)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.MediaType))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x98
	if len(m.Entities) > 0 {
		for iNdEx := len(m.Entities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if m.MessageActionData != nil {
		i -= len(m.MessageActionData)
		copy(dAtA[i:], m.MessageActionData)
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.MessageActionData)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.MessageAction))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ReplyTo))
	i--
	dAtA[i] = 0x78
	i--
	if m.Inbox {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x70
	i--
	if m.ContentRead {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x68
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.SenderID))
	i--
	dAtA[i] = 0x60
	i -= len(m.Body)
	copy(dAtA[i:], m.Body)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Body)))
	i--
	dAtA[i] = 0x5a
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.MessageType))
	i--
	dAtA[i] = 0x50
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Flags))
	i--
	dAtA[i] = 0x48
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.FwdChannelMessageID))
	i--
	dAtA[i] = 0x40
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.FwdChannelID))
	i--
	dAtA[i] = 0x38
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.FwdSenderID))
	i--
	dAtA[i] = 0x30
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.EditedOn))
	i--
	dAtA[i] = 0x28
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.CreatedOn))
	i--
	dAtA[i] = 0x20
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.PeerType))
	i--
	dAtA[i] = 0x18
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.PeerID))
	i--
	dAtA[i] = 0x10
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *DraftMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DraftMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DraftMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.EditedID))
	i--
	dAtA[i] = 0x40
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ReplyTo))
	i--
	dAtA[i] = 0x38
	if len(m.Entities) > 0 {
		for iNdEx := len(m.Entities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	i -= len(m.Body)
	copy(dAtA[i:], m.Body)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Body)))
	i--
	dAtA[i] = 0x2a
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Date))
	i--
	dAtA[i] = 0x20
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.PeerType))
	i--
	dAtA[i] = 0x18
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.PeerID))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}

func (m *MessageEntity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageEntity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageEntity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.UserID))
	i--
	dAtA[i] = 0x20
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Length))
	i--
	dAtA[i] = 0x18
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Offset))
	i--
	dAtA[i] = 0x10
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *RSAPublicKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RSAPublicKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RSAPublicKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.E))
	i--
	dAtA[i] = 0x18
	i -= len(m.N)
	copy(dAtA[i:], m.N)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.N)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.FingerPrint))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *DHGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Gen))
	i--
	dAtA[i] = 0x18
	i -= len(m.Prime)
	copy(dAtA[i:], m.Prime)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Prime)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.FingerPrint))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *PhoneContact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhoneContact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PhoneContact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Phone)
	copy(dAtA[i:], m.Phone)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Phone)))
	i--
	dAtA[i] = 0x22
	i -= len(m.LastName)
	copy(dAtA[i:], m.LastName)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.LastName)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.FirstName)
	copy(dAtA[i:], m.FirstName)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.FirstName)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ClientID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *PeerNotifySettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerNotifySettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerNotifySettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Sound)
	copy(dAtA[i:], m.Sound)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Sound)))
	i--
	dAtA[i] = 0x1a
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.MuteUntil))
	i--
	dAtA[i] = 0x10
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Flags))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *InputFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InputFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.MD5Checksum)
	copy(dAtA[i:], m.MD5Checksum)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.MD5Checksum)))
	i--
	dAtA[i] = 0x22
	i -= len(m.FileName)
	copy(dAtA[i:], m.FileName)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.FileName)))
	i--
	dAtA[i] = 0x1a
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.TotalParts))
	i--
	dAtA[i] = 0x10
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.FileID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *GroupPhoto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupPhoto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupPhoto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.PhotoID))
	i--
	dAtA[i] = 0x18
	if m.PhotoSmall == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("PhotoSmall")
	} else {
		{
			size, err := m.PhotoSmall.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PhotoBig == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("PhotoBig")
	} else {
		{
			size, err := m.PhotoBig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Group) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Group) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Group) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Photo != nil {
		{
			size, err := m.Photo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Flags) > 0 {
		for iNdEx := len(m.Flags) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Flags[iNdEx]))
			i--
			dAtA[i] = 0x30
		}
	}
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.EditedOn))
	i--
	dAtA[i] = 0x28
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Participants))
	i--
	dAtA[i] = 0x20
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.CreatedOn))
	i--
	dAtA[i] = 0x18
	i -= len(m.Title)
	copy(dAtA[i:], m.Title)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Title)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *GroupFull) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupFull) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupFull) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PhotoGallery) > 0 {
		for iNdEx := len(m.PhotoGallery) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PhotoGallery[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.NotifySettings == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("NotifySettings")
	} else {
		{
			size, err := m.NotifySettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Participants) > 0 {
		for iNdEx := len(m.Participants) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Participants[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Users) > 0 {
		for iNdEx := len(m.Users) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Users[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Group == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("Group")
	} else {
		{
			size, err := m.Group.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GroupParticipant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupParticipant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupParticipant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Photo != nil {
		{
			size, err := m.Photo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	i -= len(m.Username)
	copy(dAtA[i:], m.Username)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Username)))
	i--
	dAtA[i] = 0x32
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.AccessHash))
	i--
	dAtA[i] = 0x28
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x20
	i -= len(m.LastName)
	copy(dAtA[i:], m.LastName)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.LastName)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.FirstName)
	copy(dAtA[i:], m.FirstName)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.FirstName)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.UserID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *InputDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputDocument) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InputDocument) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ClusterID))
	i--
	dAtA[i] = 0x18
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i--
	dAtA[i] = 0x11
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *PrivacyRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrivacyRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrivacyRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UserIDs) > 0 {
		for iNdEx := len(m.UserIDs) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.UserIDs[iNdEx]))
			i--
			dAtA[i] = 0x10
		}
	}
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.PrivacyType))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *Label) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Label) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Label) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Count))
	i--
	dAtA[i] = 0x20
	i -= len(m.Colour)
	copy(dAtA[i:], m.Colour)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Colour)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *LabelsMany) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelsMany) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LabelsMany) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Labels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatCoreTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GeoLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeoLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GeoLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Long))))
	i--
	dAtA[i] = 0x15
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Lat))))
	i--
	dAtA[i] = 0xd
	return len(dAtA) - i, nil
}

func (m *InputGeoLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputGeoLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InputGeoLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Long))))
	i--
	dAtA[i] = 0x15
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Lat))))
	i--
	dAtA[i] = 0xd
	return len(dAtA) - i, nil
}

func encodeVarintChatCoreTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovChatCoreTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MessageEnvelope) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.Constructor))
	n += 9
	if m.Message != nil {
		l = len(m.Message)
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	return n
}

func (m *MessageContainer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.Length))
	if len(m.Envelopes) > 0 {
		for _, e := range m.Envelopes {
			l = e.Size()
			n += 1 + l + sovChatCoreTypes(uint64(l))
		}
	}
	return n
}

func (m *UpdateEnvelope) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.Constructor))
	if m.Update != nil {
		l = len(m.Update)
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	n += 1 + sovChatCoreTypes(uint64(m.UCount))
	n += 1 + sovChatCoreTypes(uint64(m.UpdateID))
	n += 1 + sovChatCoreTypes(uint64(m.Timestamp))
	return n
}

func (m *UpdateContainer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.Length))
	if len(m.Updates) > 0 {
		for _, e := range m.Updates {
			l = e.Size()
			n += 1 + l + sovChatCoreTypes(uint64(l))
		}
	}
	n += 1 + sovChatCoreTypes(uint64(m.MinUpdateID))
	n += 1 + sovChatCoreTypes(uint64(m.MaxUpdateID))
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovChatCoreTypes(uint64(l))
		}
	}
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovChatCoreTypes(uint64(l))
		}
	}
	return n
}

func (m *ProtoMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.AuthID))
	if m.MessageKey != nil {
		l = len(m.MessageKey)
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	if m.Payload != nil {
		l = len(m.Payload)
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	return n
}

func (m *ProtoEncryptedPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.ServerSalt))
	n += 1 + sovChatCoreTypes(uint64(m.MessageID))
	n += 1 + sovChatCoreTypes(uint64(m.SessionID))
	if m.Envelope != nil {
		l = m.Envelope.Size()
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	return n
}

func (m *Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Code)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.Items)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	return n
}

func (m *Ack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MessageIDs) > 0 {
		for _, e := range m.MessageIDs {
			n += 1 + sovChatCoreTypes(uint64(e))
		}
	}
	return n
}

func (m *Bool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}

func (m *Dialog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.PeerID))
	n += 1 + sovChatCoreTypes(uint64(m.PeerType))
	n += 1 + sovChatCoreTypes(uint64(m.TopMessageID))
	n += 1 + sovChatCoreTypes(uint64(m.ReadInboxMaxID))
	n += 1 + sovChatCoreTypes(uint64(m.ReadOutboxMaxID))
	n += 1 + sovChatCoreTypes(uint64(m.UnreadCount))
	n += 9
	if m.NotifySettings != nil {
		l = m.NotifySettings.Size()
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	n += 1 + sovChatCoreTypes(uint64(m.MentionedCount))
	n += 2
	if m.Draft != nil {
		l = m.Draft.Size()
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	return n
}

func (m *Peer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.ID))
	n += 1 + sovChatCoreTypes(uint64(m.Type))
	n += 9
	return n
}

func (m *InputPeer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.ID))
	n += 1 + sovChatCoreTypes(uint64(m.Type))
	n += 9
	return n
}

func (m *InputUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.UserID))
	n += 9
	return n
}

func (m *InputPassword) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.SrpID))
	if m.A != nil {
		l = len(m.A)
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	if m.M1 != nil {
		l = len(m.M1)
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	return n
}

func (m *InputFileLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.ClusterID))
	n += 1 + sovChatCoreTypes(uint64(m.FileID))
	n += 9
	n += 1 + sovChatCoreTypes(uint64(m.Version))
	return n
}

func (m *FileLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.ClusterID))
	n += 1 + sovChatCoreTypes(uint64(m.FileID))
	n += 9
	return n
}

func (m *UserPhoto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PhotoBig != nil {
		l = m.PhotoBig.Size()
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	if m.PhotoSmall != nil {
		l = m.PhotoSmall.Size()
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	n += 1 + sovChatCoreTypes(uint64(m.PhotoID))
	return n
}

func (m *User) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.ID))
	l = len(m.FirstName)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.LastName)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.Username)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	n += 1 + sovChatCoreTypes(uint64(m.Status))
	n += 2
	n += 9
	if m.Photo != nil {
		l = m.Photo.Size()
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	l = len(m.Bio)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.Phone)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	n += 1 + sovChatCoreTypes(uint64(m.LastSeen))
	if len(m.PhotoGallery) > 0 {
		for _, e := range m.PhotoGallery {
			l = e.Size()
			n += 1 + l + sovChatCoreTypes(uint64(l))
		}
	}
	n += 2
	n += 2
	n += 2
	if m.BotInfo != nil {
		l = m.BotInfo.Size()
		n += 2 + l + sovChatCoreTypes(uint64(l))
	}
	n += 3
	return n
}

func (m *Bot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.ID))
	l = len(m.Name)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.Username)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.Bio)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	return n
}

func (m *BotCommands) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Command)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.Description)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	return n
}

func (m *BotInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bot != nil {
		l = m.Bot.Size()
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	n += 1 + sovChatCoreTypes(uint64(m.UserID))
	l = len(m.Description)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	if len(m.BotCommands) > 0 {
		for _, e := range m.BotCommands {
			l = e.Size()
			n += 1 + l + sovChatCoreTypes(uint64(l))
		}
	}
	n += 2
	l = len(m.InlinePlaceHolder)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	return n
}

func (m *ContactUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.ID))
	l = len(m.FirstName)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.LastName)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	n += 9
	l = len(m.Phone)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.Username)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	n += 1 + sovChatCoreTypes(uint64(m.ClientID))
	if m.Photo != nil {
		l = m.Photo.Size()
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	return n
}

func (m *UserMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.ID))
	n += 1 + sovChatCoreTypes(uint64(m.PeerID))
	n += 1 + sovChatCoreTypes(uint64(m.PeerType))
	n += 1 + sovChatCoreTypes(uint64(m.CreatedOn))
	n += 1 + sovChatCoreTypes(uint64(m.EditedOn))
	n += 1 + sovChatCoreTypes(uint64(m.FwdSenderID))
	n += 1 + sovChatCoreTypes(uint64(m.FwdChannelID))
	n += 1 + sovChatCoreTypes(uint64(m.FwdChannelMessageID))
	n += 1 + sovChatCoreTypes(uint64(m.Flags))
	n += 1 + sovChatCoreTypes(uint64(m.MessageType))
	l = len(m.Body)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	n += 1 + sovChatCoreTypes(uint64(m.SenderID))
	n += 2
	n += 2
	n += 1 + sovChatCoreTypes(uint64(m.ReplyTo))
	n += 2 + sovChatCoreTypes(uint64(m.MessageAction))
	if m.MessageActionData != nil {
		l = len(m.MessageActionData)
		n += 2 + l + sovChatCoreTypes(uint64(l))
	}
	if len(m.Entities) > 0 {
		for _, e := range m.Entities {
			l = e.Size()
			n += 2 + l + sovChatCoreTypes(uint64(l))
		}
	}
	n += 2 + sovChatCoreTypes(uint64(m.MediaType))
	if m.Media != nil {
		l = len(m.Media)
		n += 2 + l + sovChatCoreTypes(uint64(l))
	}
	n += 2 + sovChatCoreTypes(uint64(m.ReplyMarkup))
	if m.ReplyMarkupData != nil {
		l = len(m.ReplyMarkupData)
		n += 2 + l + sovChatCoreTypes(uint64(l))
	}
	if len(m.LabelIDs) > 0 {
		for _, e := range m.LabelIDs {
			n += 2 + sovChatCoreTypes(uint64(e))
		}
	}
	n += 2 + sovChatCoreTypes(uint64(m.ViaBotID))
	return n
}

func (m *DraftMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.PeerID))
	n += 1 + sovChatCoreTypes(uint64(m.PeerType))
	n += 1 + sovChatCoreTypes(uint64(m.Date))
	l = len(m.Body)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	if len(m.Entities) > 0 {
		for _, e := range m.Entities {
			l = e.Size()
			n += 1 + l + sovChatCoreTypes(uint64(l))
		}
	}
	n += 1 + sovChatCoreTypes(uint64(m.ReplyTo))
	n += 1 + sovChatCoreTypes(uint64(m.EditedID))
	return n
}

func (m *MessageEntity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.Type))
	n += 1 + sovChatCoreTypes(uint64(m.Offset))
	n += 1 + sovChatCoreTypes(uint64(m.Length))
	n += 1 + sovChatCoreTypes(uint64(m.UserID))
	return n
}

func (m *RSAPublicKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.FingerPrint))
	l = len(m.N)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	n += 1 + sovChatCoreTypes(uint64(m.E))
	return n
}

func (m *DHGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.FingerPrint))
	l = len(m.Prime)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	n += 1 + sovChatCoreTypes(uint64(m.Gen))
	return n
}

func (m *PhoneContact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.ClientID))
	l = len(m.FirstName)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.LastName)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.Phone)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	return n
}

func (m *PeerNotifySettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.Flags))
	n += 1 + sovChatCoreTypes(uint64(m.MuteUntil))
	l = len(m.Sound)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	return n
}

func (m *InputFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.FileID))
	n += 1 + sovChatCoreTypes(uint64(m.TotalParts))
	l = len(m.FileName)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.MD5Checksum)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	return n
}

func (m *GroupPhoto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PhotoBig != nil {
		l = m.PhotoBig.Size()
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	if m.PhotoSmall != nil {
		l = m.PhotoSmall.Size()
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	n += 1 + sovChatCoreTypes(uint64(m.PhotoID))
	return n
}

func (m *Group) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.ID))
	l = len(m.Title)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	n += 1 + sovChatCoreTypes(uint64(m.CreatedOn))
	n += 1 + sovChatCoreTypes(uint64(m.Participants))
	n += 1 + sovChatCoreTypes(uint64(m.EditedOn))
	if len(m.Flags) > 0 {
		for _, e := range m.Flags {
			n += 1 + sovChatCoreTypes(uint64(e))
		}
	}
	if m.Photo != nil {
		l = m.Photo.Size()
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	return n
}

func (m *GroupFull) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovChatCoreTypes(uint64(l))
		}
	}
	if len(m.Participants) > 0 {
		for _, e := range m.Participants {
			l = e.Size()
			n += 1 + l + sovChatCoreTypes(uint64(l))
		}
	}
	if m.NotifySettings != nil {
		l = m.NotifySettings.Size()
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	if len(m.PhotoGallery) > 0 {
		for _, e := range m.PhotoGallery {
			l = e.Size()
			n += 1 + l + sovChatCoreTypes(uint64(l))
		}
	}
	return n
}

func (m *GroupParticipant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.UserID))
	l = len(m.FirstName)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.LastName)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	n += 1 + sovChatCoreTypes(uint64(m.Type))
	n += 1 + sovChatCoreTypes(uint64(m.AccessHash))
	l = len(m.Username)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	if m.Photo != nil {
		l = m.Photo.Size()
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	return n
}

func (m *InputDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.ID))
	n += 9
	n += 1 + sovChatCoreTypes(uint64(m.ClusterID))
	return n
}

func (m *PrivacyRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.PrivacyType))
	if len(m.UserIDs) > 0 {
		for _, e := range m.UserIDs {
			n += 1 + sovChatCoreTypes(uint64(e))
		}
	}
	return n
}

func (m *Label) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.ID))
	l = len(m.Name)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.Colour)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	n += 1 + sovChatCoreTypes(uint64(m.Count))
	return n
}

func (m *LabelsMany) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovChatCoreTypes(uint64(l))
		}
	}
	return n
}

func (m *GeoLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	n += 5
	return n
}

func (m *InputGeoLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	n += 5
	return n
}

func sovChatCoreTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozChatCoreTypes(x uint64) (n int) {
	return sovChatCoreTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MessageEnvelope) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageEnvelope: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageEnvelope: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = append(m.Message[:0], dAtA[iNdEx:postIndex]...)
			if m.Message == nil {
				m.Message = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Constructor")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("RequestID")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Message")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageContainer) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageContainer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageContainer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Envelopes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Envelopes = append(m.Envelopes, &MessageEnvelope{})
			if err := m.Envelopes[len(m.Envelopes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Length")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateEnvelope) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateEnvelope: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateEnvelope: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Update = append(m.Update[:0], dAtA[iNdEx:postIndex]...)
			if m.Update == nil {
				m.Update = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000010)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Constructor")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Update")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UCount")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UpdateID")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Timestamp")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateContainer) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateContainer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateContainer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Updates = append(m.Updates, &UpdateEnvelope{})
			if err := m.Updates[len(m.Updates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinUpdateID", wireType)
			}
			m.MinUpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinUpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUpdateID", wireType)
			}
			m.MaxUpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxUpdateID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &User{})
			if err := m.Users[len(m.Users)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &Group{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Length")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MinUpdateID")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MaxUpdateID")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtoMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtoMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtoMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthID", wireType)
			}
			m.AuthID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageKey = append(m.MessageKey[:0], dAtA[iNdEx:postIndex]...)
			if m.MessageKey == nil {
				m.MessageKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Payload")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtoEncryptedPayload) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtoEncryptedPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtoEncryptedPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSalt", wireType)
			}
			m.ServerSalt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerSalt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageID", wireType)
			}
			m.MessageID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			m.SessionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Envelope", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Envelope == nil {
				m.Envelope = &MessageEnvelope{}
			}
			if err := m.Envelope.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ServerSalt")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MessageID")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("SessionID")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Envelope")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Code")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Items")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ack) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChatCoreTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MessageIDs = append(m.MessageIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChatCoreTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthChatCoreTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthChatCoreTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.MessageIDs) == 0 {
					m.MessageIDs = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChatCoreTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MessageIDs = append(m.MessageIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Bool) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Result")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dialog) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dialog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dialog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerID", wireType)
			}
			m.PeerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopMessageID", wireType)
			}
			m.TopMessageID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopMessageID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadInboxMaxID", wireType)
			}
			m.ReadInboxMaxID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadInboxMaxID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOutboxMaxID", wireType)
			}
			m.ReadOutboxMaxID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadOutboxMaxID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnreadCount", wireType)
			}
			m.UnreadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnreadCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000040)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifySettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NotifySettings == nil {
				m.NotifySettings = &PeerNotifySettings{}
			}
			if err := m.NotifySettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MentionedCount", wireType)
			}
			m.MentionedCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MentionedCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pinned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pinned = bool(v != 0)
			hasFields[0] |= uint64(0x00000080)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Draft", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Draft == nil {
				m.Draft = &DraftMessage{}
			}
			if err := m.Draft.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PeerID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PeerType")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("TopMessageID")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ReadInboxMaxID")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ReadOutboxMaxID")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UnreadCount")
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}
	if hasFields[0]&uint64(0x00000080) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Pinned")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Peer) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Peer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Peer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Type")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputPeer) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputPeer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputPeer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= PeerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Type")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputUser) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UserID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputPassword) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputPassword: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputPassword: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrpID", wireType)
			}
			m.SrpID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrpID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.A = append(m.A[:0], dAtA[iNdEx:postIndex]...)
			if m.A == nil {
				m.A = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field M1", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.M1 = append(m.M1[:0], dAtA[iNdEx:postIndex]...)
			if m.M1 == nil {
				m.M1 = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("SrpID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("A")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("M1")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputFileLocation) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputFileLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputFileLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileID", wireType)
			}
			m.FileID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ClusterID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FileID")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileLocation) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileID", wireType)
			}
			m.FileID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ClusterID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FileID")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserPhoto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPhoto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPhoto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoBig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PhotoBig == nil {
				m.PhotoBig = &FileLocation{}
			}
			if err := m.PhotoBig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoSmall", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PhotoSmall == nil {
				m.PhotoSmall = &FileLocation{}
			}
			if err := m.PhotoSmall.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoID", wireType)
			}
			m.PhotoID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhotoID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PhotoBig")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PhotoSmall")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PhotoID")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= UserStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Restricted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Restricted = bool(v != 0)
			hasFields[0] |= uint64(0x00000010)
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000020)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Photo == nil {
				m.Photo = &UserPhoto{}
			}
			if err := m.Photo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSeen", wireType)
			}
			m.LastSeen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSeen |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoGallery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhotoGallery = append(m.PhotoGallery, &UserPhoto{})
			if err := m.PhotoGallery[len(m.PhotoGallery)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBot = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deleted = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Blocked = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BotInfo == nil {
				m.BotInfo = &BotInfo{}
			}
			if err := m.BotInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Official", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Official = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FirstName")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("LastName")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Status")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Restricted")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Bot) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Name")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Username")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BotCommands) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BotCommands: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BotCommands: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Command")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BotInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BotInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BotInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bot == nil {
				m.Bot = &Bot{}
			}
			if err := m.Bot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotCommands", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BotCommands = append(m.BotCommands, &BotCommands{})
			if err := m.BotCommands[len(m.BotCommands)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlineGeo", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InlineGeo = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlinePlaceHolder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InlinePlaceHolder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Bot")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UserID")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContactUser) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContactUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContactUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			m.ClientID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000040)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Photo == nil {
				m.Photo = &UserPhoto{}
			}
			if err := m.Photo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FirstName")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("LastName")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Phone")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Username")
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ClientID")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerID", wireType)
			}
			m.PeerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedOn", wireType)
			}
			m.CreatedOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedOn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditedOn", wireType)
			}
			m.EditedOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EditedOn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwdSenderID", wireType)
			}
			m.FwdSenderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FwdSenderID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwdChannelID", wireType)
			}
			m.FwdChannelID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FwdChannelID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000040)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwdChannelMessageID", wireType)
			}
			m.FwdChannelMessageID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FwdChannelMessageID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000080)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000100)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageType", wireType)
			}
			m.MessageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000200)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000400)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderID", wireType)
			}
			m.SenderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SenderID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000800)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentRead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContentRead = bool(v != 0)
			hasFields[0] |= uint64(0x00001000)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inbox", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Inbox = bool(v != 0)
			hasFields[0] |= uint64(0x00002000)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyTo", wireType)
			}
			m.ReplyTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyTo |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00004000)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageAction", wireType)
			}
			m.MessageAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageAction |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageActionData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageActionData = append(m.MessageActionData[:0], dAtA[iNdEx:postIndex]...)
			if m.MessageActionData == nil {
				m.MessageActionData = []byte{}
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, &MessageEntity{})
			if err := m.Entities[len(m.Entities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaType", wireType)
			}
			m.MediaType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MediaType |= MediaType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Media = append(m.Media[:0], dAtA[iNdEx:postIndex]...)
			if m.Media == nil {
				m.Media = []byte{}
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			m.ReplyMarkup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyMarkup |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkupData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyMarkupData = append(m.ReplyMarkupData[:0], dAtA[iNdEx:postIndex]...)
			if m.ReplyMarkupData == nil {
				m.ReplyMarkupData = []byte{}
			}
			iNdEx = postIndex
		case 23:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChatCoreTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LabelIDs = append(m.LabelIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChatCoreTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthChatCoreTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthChatCoreTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LabelIDs) == 0 {
					m.LabelIDs = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChatCoreTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LabelIDs = append(m.LabelIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelIDs", wireType)
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViaBotID", wireType)
			}
			m.ViaBotID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ViaBotID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PeerID")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PeerType")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("CreatedOn")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("EditedOn")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FwdSenderID")
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FwdChannelID")
	}
	if hasFields[0]&uint64(0x00000080) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FwdChannelMessageID")
	}
	if hasFields[0]&uint64(0x00000100) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Flags")
	}
	if hasFields[0]&uint64(0x00000200) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MessageType")
	}
	if hasFields[0]&uint64(0x00000400) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Body")
	}
	if hasFields[0]&uint64(0x00000800) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("SenderID")
	}
	if hasFields[0]&uint64(0x00001000) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ContentRead")
	}
	if hasFields[0]&uint64(0x00002000) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Inbox")
	}
	if hasFields[0]&uint64(0x00004000) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ReplyTo")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DraftMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DraftMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DraftMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerID", wireType)
			}
			m.PeerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, &MessageEntity{})
			if err := m.Entities[len(m.Entities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyTo", wireType)
			}
			m.ReplyTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyTo |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000010)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditedID", wireType)
			}
			m.EditedID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EditedID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PeerID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PeerType")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Date")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Body")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ReplyTo")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageEntity) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageEntity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageEntity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MessageEntityType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Type")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Offset")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Length")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RSAPublicKey) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RSAPublicKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RSAPublicKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FingerPrint", wireType)
			}
			m.FingerPrint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FingerPrint |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.N = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field E", wireType)
			}
			m.E = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.E |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FingerPrint")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("N")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("E")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHGroup) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FingerPrint", wireType)
			}
			m.FingerPrint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FingerPrint |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gen", wireType)
			}
			m.Gen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gen |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FingerPrint")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Prime")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Gen")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhoneContact) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhoneContact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhoneContact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			m.ClientID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ClientID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FirstName")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("LastName")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Phone")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerNotifySettings) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerNotifySettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerNotifySettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MuteUntil", wireType)
			}
			m.MuteUntil = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MuteUntil |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sound", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sound = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Flags")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputFile) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileID", wireType)
			}
			m.FileID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalParts", wireType)
			}
			m.TotalParts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalParts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MD5Checksum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MD5Checksum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FileID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("TotalParts")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FileName")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MD5Checksum")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupPhoto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupPhoto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupPhoto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoBig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PhotoBig == nil {
				m.PhotoBig = &FileLocation{}
			}
			if err := m.PhotoBig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoSmall", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PhotoSmall == nil {
				m.PhotoSmall = &FileLocation{}
			}
			if err := m.PhotoSmall.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoID", wireType)
			}
			m.PhotoID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhotoID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PhotoBig")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PhotoSmall")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Group) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedOn", wireType)
			}
			m.CreatedOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedOn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Participants", wireType)
			}
			m.Participants = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Participants |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditedOn", wireType)
			}
			m.EditedOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EditedOn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v GroupFlags
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChatCoreTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= GroupFlags(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Flags = append(m.Flags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChatCoreTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthChatCoreTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthChatCoreTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Flags) == 0 {
					m.Flags = make([]GroupFlags, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v GroupFlags
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChatCoreTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= GroupFlags(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Flags = append(m.Flags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Photo == nil {
				m.Photo = &GroupPhoto{}
			}
			if err := m.Photo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Title")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("CreatedOn")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Participants")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupFull) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupFull: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupFull: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &Group{}
			}
			if err := m.Group.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &User{})
			if err := m.Users[len(m.Users)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Participants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Participants = append(m.Participants, &GroupParticipant{})
			if err := m.Participants[len(m.Participants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifySettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NotifySettings == nil {
				m.NotifySettings = &PeerNotifySettings{}
			}
			if err := m.NotifySettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoGallery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhotoGallery = append(m.PhotoGallery, &GroupPhoto{})
			if err := m.PhotoGallery[len(m.PhotoGallery)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Group")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("NotifySettings")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupParticipant) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupParticipant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupParticipant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ParticipantType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000020)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Photo == nil {
				m.Photo = &UserPhoto{}
			}
			if err := m.Photo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UserID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FirstName")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("LastName")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Type")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Username")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputDocument) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ClusterID")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrivacyRule) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrivacyRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrivacyRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivacyType", wireType)
			}
			m.PrivacyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrivacyType |= PrivacyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChatCoreTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIDs = append(m.UserIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChatCoreTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthChatCoreTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthChatCoreTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UserIDs) == 0 {
					m.UserIDs = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChatCoreTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIDs = append(m.UserIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PrivacyType")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Label) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Label: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Label: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Colour", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Colour = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Name")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Colour")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelsMany) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelsMany: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelsMany: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, &Label{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeoLocation) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeoLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeoLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lat", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Lat = float32(math.Float32frombits(v))
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Long", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Long = float32(math.Float32frombits(v))
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Lat")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Long")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputGeoLocation) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputGeoLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputGeoLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lat", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Lat = float32(math.Float32frombits(v))
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Long", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Long = float32(math.Float32frombits(v))
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Lat")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Long")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipChatCoreTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthChatCoreTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupChatCoreTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthChatCoreTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthChatCoreTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowChatCoreTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupChatCoreTypes = fmt.Errorf("proto: unexpected end of group")
)

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.updates.proto

package msg

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// UpdateGetState
// @Function
// @Return: UpdateState
type UpdateGetState struct {
}

func (m *UpdateGetState) Reset()         { *m = UpdateGetState{} }
func (m *UpdateGetState) String() string { return proto.CompactTextString(m) }
func (*UpdateGetState) ProtoMessage()    {}
func (*UpdateGetState) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_updates_e07deb79f5e91f20, []int{0}
}
func (m *UpdateGetState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGetState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGetState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateGetState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGetState.Merge(dst, src)
}
func (m *UpdateGetState) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGetState) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGetState.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGetState proto.InternalMessageInfo

// UpdateGetDifference
// @Function
// @Return: UpdateDifference
type UpdateGetDifference struct {
	From  int64 `protobuf:"varint,1,req,name=From" json:"From"`
	Limit int32 `protobuf:"varint,2,req,name=Limit" json:"Limit"`
}

func (m *UpdateGetDifference) Reset()         { *m = UpdateGetDifference{} }
func (m *UpdateGetDifference) String() string { return proto.CompactTextString(m) }
func (*UpdateGetDifference) ProtoMessage()    {}
func (*UpdateGetDifference) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_updates_e07deb79f5e91f20, []int{1}
}
func (m *UpdateGetDifference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGetDifference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGetDifference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateGetDifference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGetDifference.Merge(dst, src)
}
func (m *UpdateGetDifference) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGetDifference) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGetDifference.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGetDifference proto.InternalMessageInfo

func (m *UpdateGetDifference) GetFrom() int64 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *UpdateGetDifference) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

// UpdateDifference
type UpdateDifference struct {
	More        bool              `protobuf:"varint,1,req,name=More" json:"More"`
	MaxUpdateID int64             `protobuf:"varint,2,req,name=MaxUpdateID" json:"MaxUpdateID"`
	MinUpdateID int64             `protobuf:"varint,3,req,name=MinUpdateID" json:"MinUpdateID"`
	Updates     []*UpdateEnvelope `protobuf:"bytes,4,rep,name=Updates" json:"Updates,omitempty"`
	Users       []*User           `protobuf:"bytes,5,rep,name=Users" json:"Users,omitempty"`
}

func (m *UpdateDifference) Reset()         { *m = UpdateDifference{} }
func (m *UpdateDifference) String() string { return proto.CompactTextString(m) }
func (*UpdateDifference) ProtoMessage()    {}
func (*UpdateDifference) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_updates_e07deb79f5e91f20, []int{2}
}
func (m *UpdateDifference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateDifference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateDifference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateDifference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateDifference.Merge(dst, src)
}
func (m *UpdateDifference) XXX_Size() int {
	return m.Size()
}
func (m *UpdateDifference) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateDifference.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateDifference proto.InternalMessageInfo

func (m *UpdateDifference) GetMore() bool {
	if m != nil {
		return m.More
	}
	return false
}

func (m *UpdateDifference) GetMaxUpdateID() int64 {
	if m != nil {
		return m.MaxUpdateID
	}
	return 0
}

func (m *UpdateDifference) GetMinUpdateID() int64 {
	if m != nil {
		return m.MinUpdateID
	}
	return 0
}

func (m *UpdateDifference) GetUpdates() []*UpdateEnvelope {
	if m != nil {
		return m.Updates
	}
	return nil
}

func (m *UpdateDifference) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

// UpdateState
type UpdateState struct {
	UpdateID int64 `protobuf:"varint,1,req,name=UpdateID" json:"UpdateID"`
}

func (m *UpdateState) Reset()         { *m = UpdateState{} }
func (m *UpdateState) String() string { return proto.CompactTextString(m) }
func (*UpdateState) ProtoMessage()    {}
func (*UpdateState) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_updates_e07deb79f5e91f20, []int{3}
}
func (m *UpdateState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateState.Merge(dst, src)
}
func (m *UpdateState) XXX_Size() int {
	return m.Size()
}
func (m *UpdateState) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateState.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateState proto.InternalMessageInfo

func (m *UpdateState) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

// UpdateMessageID
type UpdateMessageID struct {
	UCount    int32 `protobuf:"varint,100,req,name=UCount" json:"UCount"`
	MessageID int64 `protobuf:"varint,1,req,name=MessageID" json:"MessageID"`
	RandomID  int64 `protobuf:"varint,2,req,name=RandomID" json:"RandomID"`
}

func (m *UpdateMessageID) Reset()         { *m = UpdateMessageID{} }
func (m *UpdateMessageID) String() string { return proto.CompactTextString(m) }
func (*UpdateMessageID) ProtoMessage()    {}
func (*UpdateMessageID) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_updates_e07deb79f5e91f20, []int{4}
}
func (m *UpdateMessageID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateMessageID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateMessageID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateMessageID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateMessageID.Merge(dst, src)
}
func (m *UpdateMessageID) XXX_Size() int {
	return m.Size()
}
func (m *UpdateMessageID) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateMessageID.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateMessageID proto.InternalMessageInfo

func (m *UpdateMessageID) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateMessageID) GetMessageID() int64 {
	if m != nil {
		return m.MessageID
	}
	return 0
}

func (m *UpdateMessageID) GetRandomID() int64 {
	if m != nil {
		return m.RandomID
	}
	return 0
}

// UpdateNewMessage
type UpdateNewMessage struct {
	UCount     int32        `protobuf:"varint,100,req,name=UCount" json:"UCount"`
	UpdateID   int64        `protobuf:"varint,101,req,name=UpdateID" json:"UpdateID"`
	Message    *UserMessage `protobuf:"bytes,1,req,name=Message" json:"Message,omitempty"`
	Sender     *User        `protobuf:"bytes,2,req,name=Sender" json:"Sender,omitempty"`
	AccessHash uint64       `protobuf:"fixed64,3,opt,name=AccessHash" json:"AccessHash"`
}

func (m *UpdateNewMessage) Reset()         { *m = UpdateNewMessage{} }
func (m *UpdateNewMessage) String() string { return proto.CompactTextString(m) }
func (*UpdateNewMessage) ProtoMessage()    {}
func (*UpdateNewMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_updates_e07deb79f5e91f20, []int{5}
}
func (m *UpdateNewMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateNewMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateNewMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateNewMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateNewMessage.Merge(dst, src)
}
func (m *UpdateNewMessage) XXX_Size() int {
	return m.Size()
}
func (m *UpdateNewMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateNewMessage.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateNewMessage proto.InternalMessageInfo

func (m *UpdateNewMessage) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateNewMessage) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateNewMessage) GetMessage() *UserMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *UpdateNewMessage) GetSender() *User {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *UpdateNewMessage) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// UpdateMessageEdited
type UpdateMessageEdited struct {
	UCount   int32        `protobuf:"varint,100,req,name=UCount" json:"UCount"`
	UpdateID int64        `protobuf:"varint,101,req,name=UpdateID" json:"UpdateID"`
	Message  *UserMessage `protobuf:"bytes,1,req,name=Message" json:"Message,omitempty"`
}

func (m *UpdateMessageEdited) Reset()         { *m = UpdateMessageEdited{} }
func (m *UpdateMessageEdited) String() string { return proto.CompactTextString(m) }
func (*UpdateMessageEdited) ProtoMessage()    {}
func (*UpdateMessageEdited) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_updates_e07deb79f5e91f20, []int{6}
}
func (m *UpdateMessageEdited) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateMessageEdited) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateMessageEdited.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateMessageEdited) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateMessageEdited.Merge(dst, src)
}
func (m *UpdateMessageEdited) XXX_Size() int {
	return m.Size()
}
func (m *UpdateMessageEdited) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateMessageEdited.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateMessageEdited proto.InternalMessageInfo

func (m *UpdateMessageEdited) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateMessageEdited) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateMessageEdited) GetMessage() *UserMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

// UpdateReadHistoryInbox
type UpdateReadHistoryInbox struct {
	UCount   int32 `protobuf:"varint,100,req,name=UCount" json:"UCount"`
	UpdateID int64 `protobuf:"varint,101,req,name=UpdateID" json:"UpdateID"`
	Peer     *Peer `protobuf:"bytes,1,req,name=Peer" json:"Peer,omitempty"`
	MaxID    int64 `protobuf:"varint,2,req,name=MaxID" json:"MaxID"`
}

func (m *UpdateReadHistoryInbox) Reset()         { *m = UpdateReadHistoryInbox{} }
func (m *UpdateReadHistoryInbox) String() string { return proto.CompactTextString(m) }
func (*UpdateReadHistoryInbox) ProtoMessage()    {}
func (*UpdateReadHistoryInbox) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_updates_e07deb79f5e91f20, []int{7}
}
func (m *UpdateReadHistoryInbox) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateReadHistoryInbox) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateReadHistoryInbox.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateReadHistoryInbox) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateReadHistoryInbox.Merge(dst, src)
}
func (m *UpdateReadHistoryInbox) XXX_Size() int {
	return m.Size()
}
func (m *UpdateReadHistoryInbox) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateReadHistoryInbox.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateReadHistoryInbox proto.InternalMessageInfo

func (m *UpdateReadHistoryInbox) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateReadHistoryInbox) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateReadHistoryInbox) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *UpdateReadHistoryInbox) GetMaxID() int64 {
	if m != nil {
		return m.MaxID
	}
	return 0
}

// UpdateReadHistoryOutbox
type UpdateReadHistoryOutbox struct {
	UCount   int32 `protobuf:"varint,100,req,name=UCount" json:"UCount"`
	UpdateID int64 `protobuf:"varint,101,req,name=UpdateID" json:"UpdateID"`
	Peer     *Peer `protobuf:"bytes,1,req,name=Peer" json:"Peer,omitempty"`
	MaxID    int64 `protobuf:"varint,2,req,name=MaxID" json:"MaxID"`
}

func (m *UpdateReadHistoryOutbox) Reset()         { *m = UpdateReadHistoryOutbox{} }
func (m *UpdateReadHistoryOutbox) String() string { return proto.CompactTextString(m) }
func (*UpdateReadHistoryOutbox) ProtoMessage()    {}
func (*UpdateReadHistoryOutbox) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_updates_e07deb79f5e91f20, []int{8}
}
func (m *UpdateReadHistoryOutbox) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateReadHistoryOutbox) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateReadHistoryOutbox.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateReadHistoryOutbox) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateReadHistoryOutbox.Merge(dst, src)
}
func (m *UpdateReadHistoryOutbox) XXX_Size() int {
	return m.Size()
}
func (m *UpdateReadHistoryOutbox) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateReadHistoryOutbox.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateReadHistoryOutbox proto.InternalMessageInfo

func (m *UpdateReadHistoryOutbox) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateReadHistoryOutbox) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateReadHistoryOutbox) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *UpdateReadHistoryOutbox) GetMaxID() int64 {
	if m != nil {
		return m.MaxID
	}
	return 0
}

// UpdateUserTyping
type UpdateUserTyping struct {
	UCount int32        `protobuf:"varint,100,req,name=UCount" json:"UCount"`
	UserID int64        `protobuf:"varint,1,req,name=UserID" json:"UserID"`
	Action TypingAction `protobuf:"varint,2,req,name=Action,enum=msg.TypingAction" json:"Action"`
}

func (m *UpdateUserTyping) Reset()         { *m = UpdateUserTyping{} }
func (m *UpdateUserTyping) String() string { return proto.CompactTextString(m) }
func (*UpdateUserTyping) ProtoMessage()    {}
func (*UpdateUserTyping) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_updates_e07deb79f5e91f20, []int{9}
}
func (m *UpdateUserTyping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateUserTyping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateUserTyping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateUserTyping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateUserTyping.Merge(dst, src)
}
func (m *UpdateUserTyping) XXX_Size() int {
	return m.Size()
}
func (m *UpdateUserTyping) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateUserTyping.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateUserTyping proto.InternalMessageInfo

func (m *UpdateUserTyping) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateUserTyping) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UpdateUserTyping) GetAction() TypingAction {
	if m != nil {
		return m.Action
	}
	return TypingAction_Typing
}

// UpdateUserStatus
type UpdateUserStatus struct {
	UCount int32 `protobuf:"varint,100,req,name=UCount" json:"UCount"`
	UserID int64 `protobuf:"varint,1,req,name=UserID" json:"UserID"`
	Status int32 `protobuf:"varint,2,req,name=Status" json:"Status"`
}

func (m *UpdateUserStatus) Reset()         { *m = UpdateUserStatus{} }
func (m *UpdateUserStatus) String() string { return proto.CompactTextString(m) }
func (*UpdateUserStatus) ProtoMessage()    {}
func (*UpdateUserStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_updates_e07deb79f5e91f20, []int{10}
}
func (m *UpdateUserStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateUserStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateUserStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateUserStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateUserStatus.Merge(dst, src)
}
func (m *UpdateUserStatus) XXX_Size() int {
	return m.Size()
}
func (m *UpdateUserStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateUserStatus.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateUserStatus proto.InternalMessageInfo

func (m *UpdateUserStatus) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateUserStatus) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UpdateUserStatus) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func init() {
	proto.RegisterType((*UpdateGetState)(nil), "msg.UpdateGetState")
	proto.RegisterType((*UpdateGetDifference)(nil), "msg.UpdateGetDifference")
	proto.RegisterType((*UpdateDifference)(nil), "msg.UpdateDifference")
	proto.RegisterType((*UpdateState)(nil), "msg.UpdateState")
	proto.RegisterType((*UpdateMessageID)(nil), "msg.UpdateMessageID")
	proto.RegisterType((*UpdateNewMessage)(nil), "msg.UpdateNewMessage")
	proto.RegisterType((*UpdateMessageEdited)(nil), "msg.UpdateMessageEdited")
	proto.RegisterType((*UpdateReadHistoryInbox)(nil), "msg.UpdateReadHistoryInbox")
	proto.RegisterType((*UpdateReadHistoryOutbox)(nil), "msg.UpdateReadHistoryOutbox")
	proto.RegisterType((*UpdateUserTyping)(nil), "msg.UpdateUserTyping")
	proto.RegisterType((*UpdateUserStatus)(nil), "msg.UpdateUserStatus")
}
func (m *UpdateGetState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGetState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *UpdateGetDifference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGetDifference) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintApiUpdates(dAtA, i, uint64(m.From))
	dAtA[i] = 0x10
	i++
	i = encodeVarintApiUpdates(dAtA, i, uint64(m.Limit))
	return i, nil
}

func (m *UpdateDifference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateDifference) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.More {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x10
	i++
	i = encodeVarintApiUpdates(dAtA, i, uint64(m.MaxUpdateID))
	dAtA[i] = 0x18
	i++
	i = encodeVarintApiUpdates(dAtA, i, uint64(m.MinUpdateID))
	if len(m.Updates) > 0 {
		for _, msg := range m.Updates {
			dAtA[i] = 0x22
			i++
			i = encodeVarintApiUpdates(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Users) > 0 {
		for _, msg := range m.Users {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintApiUpdates(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UpdateState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintApiUpdates(dAtA, i, uint64(m.UpdateID))
	return i, nil
}

func (m *UpdateMessageID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateMessageID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintApiUpdates(dAtA, i, uint64(m.MessageID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintApiUpdates(dAtA, i, uint64(m.RandomID))
	dAtA[i] = 0xa0
	i++
	dAtA[i] = 0x6
	i++
	i = encodeVarintApiUpdates(dAtA, i, uint64(m.UCount))
	return i, nil
}

func (m *UpdateNewMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateNewMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Message == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("Message")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApiUpdates(dAtA, i, uint64(m.Message.Size()))
		n1, err := m.Message.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Sender == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("Sender")
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApiUpdates(dAtA, i, uint64(m.Sender.Size()))
		n2, err := m.Sender.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	dAtA[i] = 0x19
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i += 8
	dAtA[i] = 0xa0
	i++
	dAtA[i] = 0x6
	i++
	i = encodeVarintApiUpdates(dAtA, i, uint64(m.UCount))
	dAtA[i] = 0xa8
	i++
	dAtA[i] = 0x6
	i++
	i = encodeVarintApiUpdates(dAtA, i, uint64(m.UpdateID))
	return i, nil
}

func (m *UpdateMessageEdited) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateMessageEdited) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Message == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("Message")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApiUpdates(dAtA, i, uint64(m.Message.Size()))
		n3, err := m.Message.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	dAtA[i] = 0xa0
	i++
	dAtA[i] = 0x6
	i++
	i = encodeVarintApiUpdates(dAtA, i, uint64(m.UCount))
	dAtA[i] = 0xa8
	i++
	dAtA[i] = 0x6
	i++
	i = encodeVarintApiUpdates(dAtA, i, uint64(m.UpdateID))
	return i, nil
}

func (m *UpdateReadHistoryInbox) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateReadHistoryInbox) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Peer == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("Peer")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApiUpdates(dAtA, i, uint64(m.Peer.Size()))
		n4, err := m.Peer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintApiUpdates(dAtA, i, uint64(m.MaxID))
	dAtA[i] = 0xa0
	i++
	dAtA[i] = 0x6
	i++
	i = encodeVarintApiUpdates(dAtA, i, uint64(m.UCount))
	dAtA[i] = 0xa8
	i++
	dAtA[i] = 0x6
	i++
	i = encodeVarintApiUpdates(dAtA, i, uint64(m.UpdateID))
	return i, nil
}

func (m *UpdateReadHistoryOutbox) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateReadHistoryOutbox) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Peer == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("Peer")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApiUpdates(dAtA, i, uint64(m.Peer.Size()))
		n5, err := m.Peer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintApiUpdates(dAtA, i, uint64(m.MaxID))
	dAtA[i] = 0xa0
	i++
	dAtA[i] = 0x6
	i++
	i = encodeVarintApiUpdates(dAtA, i, uint64(m.UCount))
	dAtA[i] = 0xa8
	i++
	dAtA[i] = 0x6
	i++
	i = encodeVarintApiUpdates(dAtA, i, uint64(m.UpdateID))
	return i, nil
}

func (m *UpdateUserTyping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUserTyping) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintApiUpdates(dAtA, i, uint64(m.UserID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintApiUpdates(dAtA, i, uint64(m.Action))
	dAtA[i] = 0xa0
	i++
	dAtA[i] = 0x6
	i++
	i = encodeVarintApiUpdates(dAtA, i, uint64(m.UCount))
	return i, nil
}

func (m *UpdateUserStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUserStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintApiUpdates(dAtA, i, uint64(m.UserID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintApiUpdates(dAtA, i, uint64(m.Status))
	dAtA[i] = 0xa0
	i++
	dAtA[i] = 0x6
	i++
	i = encodeVarintApiUpdates(dAtA, i, uint64(m.UCount))
	return i, nil
}

func encodeVarintApiUpdates(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *UpdateGetState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *UpdateGetDifference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovApiUpdates(uint64(m.From))
	n += 1 + sovApiUpdates(uint64(m.Limit))
	return n
}

func (m *UpdateDifference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	n += 1 + sovApiUpdates(uint64(m.MaxUpdateID))
	n += 1 + sovApiUpdates(uint64(m.MinUpdateID))
	if len(m.Updates) > 0 {
		for _, e := range m.Updates {
			l = e.Size()
			n += 1 + l + sovApiUpdates(uint64(l))
		}
	}
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovApiUpdates(uint64(l))
		}
	}
	return n
}

func (m *UpdateState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovApiUpdates(uint64(m.UpdateID))
	return n
}

func (m *UpdateMessageID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovApiUpdates(uint64(m.MessageID))
	n += 1 + sovApiUpdates(uint64(m.RandomID))
	n += 2 + sovApiUpdates(uint64(m.UCount))
	return n
}

func (m *UpdateNewMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovApiUpdates(uint64(l))
	}
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovApiUpdates(uint64(l))
	}
	n += 9
	n += 2 + sovApiUpdates(uint64(m.UCount))
	n += 2 + sovApiUpdates(uint64(m.UpdateID))
	return n
}

func (m *UpdateMessageEdited) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovApiUpdates(uint64(l))
	}
	n += 2 + sovApiUpdates(uint64(m.UCount))
	n += 2 + sovApiUpdates(uint64(m.UpdateID))
	return n
}

func (m *UpdateReadHistoryInbox) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovApiUpdates(uint64(l))
	}
	n += 1 + sovApiUpdates(uint64(m.MaxID))
	n += 2 + sovApiUpdates(uint64(m.UCount))
	n += 2 + sovApiUpdates(uint64(m.UpdateID))
	return n
}

func (m *UpdateReadHistoryOutbox) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovApiUpdates(uint64(l))
	}
	n += 1 + sovApiUpdates(uint64(m.MaxID))
	n += 2 + sovApiUpdates(uint64(m.UCount))
	n += 2 + sovApiUpdates(uint64(m.UpdateID))
	return n
}

func (m *UpdateUserTyping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovApiUpdates(uint64(m.UserID))
	n += 1 + sovApiUpdates(uint64(m.Action))
	n += 2 + sovApiUpdates(uint64(m.UCount))
	return n
}

func (m *UpdateUserStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovApiUpdates(uint64(m.UserID))
	n += 1 + sovApiUpdates(uint64(m.Status))
	n += 2 + sovApiUpdates(uint64(m.UCount))
	return n
}

func sovApiUpdates(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApiUpdates(x uint64) (n int) {
	return sovApiUpdates(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UpdateGetState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGetState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGetState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApiUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApiUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGetDifference) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGetDifference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGetDifference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipApiUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApiUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("From")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Limit")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateDifference) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateDifference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateDifference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field More", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.More = bool(v != 0)
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUpdateID", wireType)
			}
			m.MaxUpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxUpdateID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinUpdateID", wireType)
			}
			m.MinUpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinUpdateID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApiUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Updates = append(m.Updates, &UpdateEnvelope{})
			if err := m.Updates[len(m.Updates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApiUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &User{})
			if err := m.Users[len(m.Users)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApiUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApiUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("More")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MaxUpdateID")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MinUpdateID")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateState) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipApiUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApiUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UpdateID")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateMessageID) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateMessageID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateMessageID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageID", wireType)
			}
			m.MessageID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomID", wireType)
			}
			m.RandomID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RandomID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipApiUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApiUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MessageID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("RandomID")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UCount")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateNewMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateNewMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateNewMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApiUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &UserMessage{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApiUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &User{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipApiUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApiUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Message")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Sender")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UCount")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UpdateID")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateMessageEdited) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateMessageEdited: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateMessageEdited: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApiUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &UserMessage{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipApiUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApiUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Message")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UCount")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UpdateID")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateReadHistoryInbox) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateReadHistoryInbox: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateReadHistoryInbox: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApiUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxID", wireType)
			}
			m.MaxID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipApiUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApiUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Peer")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MaxID")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UCount")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UpdateID")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateReadHistoryOutbox) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateReadHistoryOutbox: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateReadHistoryOutbox: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApiUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxID", wireType)
			}
			m.MaxID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipApiUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApiUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Peer")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MaxID")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UCount")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UpdateID")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUserTyping) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUserTyping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUserTyping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (TypingAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipApiUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApiUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UserID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Action")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UCount")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUserStatus) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUserStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUserStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipApiUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApiUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UserID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Status")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UCount")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApiUpdates(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApiUpdates
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApiUpdates
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApiUpdates
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApiUpdates
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApiUpdates(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApiUpdates = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApiUpdates   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("api.updates.proto", fileDescriptor_api_updates_e07deb79f5e91f20) }

var fileDescriptor_api_updates_e07deb79f5e91f20 = []byte{
	// 551 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x94, 0xdf, 0x6e, 0xd3, 0x30,
	0x14, 0xc6, 0x9b, 0xfe, 0xc9, 0xb6, 0x53, 0x69, 0x74, 0xae, 0x04, 0x51, 0x35, 0xb2, 0x92, 0x8b,
	0xa9, 0x42, 0xa2, 0x43, 0x7d, 0x83, 0x95, 0x0e, 0x56, 0x41, 0x01, 0x65, 0xf4, 0x01, 0x42, 0x73,
	0x56, 0x22, 0x91, 0x38, 0xb2, 0x5d, 0x68, 0x2f, 0xf7, 0x06, 0x48, 0xf0, 0x50, 0x43, 0xe2, 0x62,
	0x97, 0x5c, 0x21, 0xd4, 0xbe, 0x08, 0x8a, 0xed, 0x78, 0xcd, 0x40, 0x9b, 0xd0, 0x2e, 0x76, 0x67,
	0xff, 0xce, 0xe7, 0xe3, 0x2f, 0x9f, 0xed, 0xc0, 0x4e, 0x90, 0x46, 0xdd, 0x59, 0x1a, 0x06, 0x02,
	0x79, 0x37, 0x65, 0x54, 0x50, 0x52, 0x89, 0xf9, 0xb4, 0xd5, 0x9c, 0x50, 0x86, 0xdd, 0x18, 0x39,
	0x0f, 0xa6, 0x79, 0xa5, 0xd5, 0x90, 0x50, 0x2c, 0xd2, 0x9c, 0x78, 0x0d, 0xd8, 0x1e, 0xcb, 0xc5,
	0x2f, 0x50, 0x9c, 0x88, 0x40, 0xa0, 0xf7, 0x12, 0x9a, 0x86, 0x0c, 0xa2, 0xd3, 0x53, 0x64, 0x98,
	0x4c, 0x90, 0x38, 0x50, 0x7d, 0xce, 0x68, 0xec, 0x58, 0xed, 0x72, 0xa7, 0xd2, 0xaf, 0x9e, 0xff,
	0xda, 0x2b, 0xf9, 0x92, 0x90, 0x16, 0xd4, 0x5e, 0x45, 0x71, 0x24, 0x9c, 0x72, 0xbb, 0xdc, 0xa9,
	0xe9, 0x92, 0x42, 0xde, 0x0f, 0x0b, 0x1a, 0xaa, 0x5b, 0xb1, 0xd5, 0x88, 0x32, 0x94, 0xad, 0x36,
	0xf3, 0x56, 0x19, 0x21, 0xfb, 0x50, 0x1f, 0x05, 0x73, 0xb5, 0x60, 0x38, 0x90, 0x0d, 0xf3, 0xbd,
	0xd6, 0x0b, 0x52, 0x17, 0x25, 0x46, 0x57, 0x29, 0xe8, 0x2e, 0x0b, 0xe4, 0x09, 0x6c, 0xa8, 0x31,
	0x77, 0xaa, 0xed, 0x4a, 0xa7, 0xde, 0x6b, 0x76, 0x63, 0x3e, 0xed, 0x2a, 0x76, 0x94, 0x7c, 0xc2,
	0x8f, 0x34, 0x45, 0x3f, 0xd7, 0x90, 0x3d, 0xa8, 0x8d, 0x39, 0x32, 0xee, 0xd4, 0xa4, 0x78, 0x4b,
	0x89, 0x39, 0x32, 0x5f, 0x71, 0xef, 0x00, 0xea, 0x4a, 0x2b, 0xa3, 0x22, 0x6d, 0xd8, 0x34, 0x1e,
	0xd6, 0x73, 0x31, 0xd4, 0x9b, 0xc1, 0x3d, 0x35, 0x1e, 0xa9, 0x83, 0x18, 0x0e, 0x88, 0x07, 0x5b,
	0x66, 0x52, 0x58, 0x75, 0x89, 0xb3, 0xc6, 0x7e, 0x90, 0x84, 0x34, 0xbe, 0x12, 0x82, 0xa1, 0x64,
	0x17, 0xec, 0xf1, 0x33, 0x3a, 0x4b, 0x84, 0x13, 0xae, 0xa5, 0xae, 0x99, 0xf7, 0xdd, 0xc4, 0xfe,
	0x1a, 0x3f, 0xeb, 0xb6, 0xe4, 0x31, 0x6c, 0xe8, 0xa1, 0xdc, 0xb6, 0xde, 0x6b, 0x98, 0xef, 0xd3,
	0xdc, 0xcf, 0x05, 0xe4, 0x11, 0xd8, 0x27, 0x98, 0x84, 0xc8, 0xe4, 0xf6, 0x85, 0x28, 0x74, 0x81,
	0xec, 0x03, 0x1c, 0x4e, 0x26, 0xc8, 0xf9, 0x71, 0xc0, 0x3f, 0x38, 0x95, 0xb6, 0xd5, 0xb1, 0xfb,
	0x76, 0xe6, 0xe2, 0xa9, 0xe5, 0xaf, 0x55, 0xae, 0x77, 0x5a, 0x88, 0x10, 0xff, 0x19, 0xe1, 0x99,
	0x95, 0x5f, 0x48, 0x6d, 0xee, 0x28, 0x8c, 0x04, 0x86, 0xff, 0xf5, 0x39, 0xb7, 0xf5, 0xf0, 0xd5,
	0x82, 0xfb, 0x6a, 0xe2, 0x63, 0x10, 0x1e, 0x47, 0x5c, 0x50, 0xb6, 0x18, 0x26, 0xef, 0xe9, 0x9c,
	0x3c, 0x84, 0xea, 0x5b, 0x44, 0xa6, 0x3d, 0xa8, 0x9c, 0x32, 0xe0, 0x4b, 0x9c, 0x3d, 0x8e, 0x51,
	0x30, 0xbf, 0x72, 0x8c, 0x0a, 0xdd, 0xda, 0xd5, 0x37, 0x0b, 0x1e, 0xfc, 0xe5, 0xea, 0xcd, 0x4c,
	0xdc, 0xb1, 0xad, 0x33, 0x73, 0xf9, 0xb2, 0xb3, 0x78, 0xb7, 0x48, 0xa3, 0x64, 0x4a, 0x5c, 0xb0,
	0xb3, 0x99, 0xb9, 0xf2, 0xf9, 0x4d, 0xd1, 0x94, 0x1c, 0x80, 0x7d, 0x38, 0x11, 0x11, 0x4d, 0xa4,
	0xa3, 0xed, 0xde, 0x8e, 0x74, 0xac, 0x16, 0xab, 0x42, 0xee, 0x43, 0xcd, 0x6e, 0x78, 0x00, 0xc9,
	0xba, 0x85, 0xec, 0xb1, 0xce, 0xf8, 0x8d, 0x16, 0x76, 0xc1, 0x56, 0xca, 0xc2, 0x8f, 0x4c, 0xb3,
	0xeb, 0xf7, 0xeb, 0x3b, 0xe7, 0x4b, 0xd7, 0xba, 0x58, 0xba, 0xd6, 0xef, 0xa5, 0x6b, 0x7d, 0x59,
	0xb9, 0xa5, 0x8b, 0x95, 0x5b, 0xfa, 0xb9, 0x72, 0x4b, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x4c,
	0xbd, 0xc6, 0xab, 0xa0, 0x05, 0x00, 0x00,
}

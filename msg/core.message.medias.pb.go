// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: core.message.medias.proto

package msg

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// DocumentAttributeType
type DocumentAttributeType int32

const (
	AttributeTypeNone  DocumentAttributeType = 0
	AttributeTypeAudio DocumentAttributeType = 1
	AttributeTypeVideo DocumentAttributeType = 2
	AttributeTypePhoto DocumentAttributeType = 3
	AttributeTypeFile  DocumentAttributeType = 4
	AttributeAnimated  DocumentAttributeType = 5
)

var DocumentAttributeType_name = map[int32]string{
	0: "AttributeTypeNone",
	1: "AttributeTypeAudio",
	2: "AttributeTypeVideo",
	3: "AttributeTypePhoto",
	4: "AttributeTypeFile",
	5: "AttributeAnimated",
}

var DocumentAttributeType_value = map[string]int32{
	"AttributeTypeNone":  0,
	"AttributeTypeAudio": 1,
	"AttributeTypeVideo": 2,
	"AttributeTypePhoto": 3,
	"AttributeTypeFile":  4,
	"AttributeAnimated":  5,
}

func (x DocumentAttributeType) Enum() *DocumentAttributeType {
	p := new(DocumentAttributeType)
	*p = x
	return p
}

func (x DocumentAttributeType) String() string {
	return proto.EnumName(DocumentAttributeType_name, int32(x))
}

func (x *DocumentAttributeType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DocumentAttributeType_value, data, "DocumentAttributeType")
	if err != nil {
		return err
	}
	*x = DocumentAttributeType(value)
	return nil
}

func (DocumentAttributeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c3fb7b389bdbc716, []int{0}
}

// Document Type
type DocumentType int32

const (
	DocumentTypeUnknown DocumentType = 0
	DocumentTypePhoto   DocumentType = 1
	DocumentTypeVoice   DocumentType = 2
	DocumentTypeVideo   DocumentType = 3
	DocumentTypeWebPage DocumentType = 4
)

var DocumentType_name = map[int32]string{
	0: "DocumentTypeUnknown",
	1: "DocumentTypePhoto",
	2: "DocumentTypeVoice",
	3: "DocumentTypeVideo",
	4: "DocumentTypeWebPage",
}

var DocumentType_value = map[string]int32{
	"DocumentTypeUnknown": 0,
	"DocumentTypePhoto":   1,
	"DocumentTypeVoice":   2,
	"DocumentTypeVideo":   3,
	"DocumentTypeWebPage": 4,
}

func (x DocumentType) Enum() *DocumentType {
	p := new(DocumentType)
	*p = x
	return p
}

func (x DocumentType) String() string {
	return proto.EnumName(DocumentType_name, int32(x))
}

func (x *DocumentType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DocumentType_value, data, "DocumentType")
	if err != nil {
		return err
	}
	*x = DocumentType(value)
	return nil
}

func (DocumentType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c3fb7b389bdbc716, []int{1}
}

// DocumentAttributeAudio
type DocumentAttributeAudio struct {
	Voice     bool   `protobuf:"varint,1,req,name=Voice" json:"Voice"`
	Duration  uint32 `protobuf:"varint,2,req,name=Duration" json:"Duration"`
	Title     string `protobuf:"bytes,3,req,name=Title" json:"Title"`
	Performer string `protobuf:"bytes,4,req,name=Performer" json:"Performer"`
	Album     string `protobuf:"bytes,5,req,name=Album" json:"Album"`
	Waveform  []byte `protobuf:"bytes,6,opt,name=Waveform" json:"Waveform"`
}

func (m *DocumentAttributeAudio) Reset()         { *m = DocumentAttributeAudio{} }
func (m *DocumentAttributeAudio) String() string { return proto.CompactTextString(m) }
func (*DocumentAttributeAudio) ProtoMessage()    {}
func (*DocumentAttributeAudio) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3fb7b389bdbc716, []int{0}
}
func (m *DocumentAttributeAudio) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DocumentAttributeAudio) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DocumentAttributeAudio.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DocumentAttributeAudio) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DocumentAttributeAudio.Merge(m, src)
}
func (m *DocumentAttributeAudio) XXX_Size() int {
	return m.Size()
}
func (m *DocumentAttributeAudio) XXX_DiscardUnknown() {
	xxx_messageInfo_DocumentAttributeAudio.DiscardUnknown(m)
}

var xxx_messageInfo_DocumentAttributeAudio proto.InternalMessageInfo

func (m *DocumentAttributeAudio) GetVoice() bool {
	if m != nil {
		return m.Voice
	}
	return false
}

func (m *DocumentAttributeAudio) GetDuration() uint32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *DocumentAttributeAudio) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *DocumentAttributeAudio) GetPerformer() string {
	if m != nil {
		return m.Performer
	}
	return ""
}

func (m *DocumentAttributeAudio) GetAlbum() string {
	if m != nil {
		return m.Album
	}
	return ""
}

func (m *DocumentAttributeAudio) GetWaveform() []byte {
	if m != nil {
		return m.Waveform
	}
	return nil
}

// DocumentAttributeVideo
type DocumentAttributeVideo struct {
	Width    uint32 `protobuf:"varint,1,req,name=Width" json:"Width"`
	Height   uint32 `protobuf:"varint,2,req,name=Height" json:"Height"`
	Duration uint32 `protobuf:"varint,3,req,name=Duration" json:"Duration"`
	Round    bool   `protobuf:"varint,4,req,name=Round" json:"Round"`
}

func (m *DocumentAttributeVideo) Reset()         { *m = DocumentAttributeVideo{} }
func (m *DocumentAttributeVideo) String() string { return proto.CompactTextString(m) }
func (*DocumentAttributeVideo) ProtoMessage()    {}
func (*DocumentAttributeVideo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3fb7b389bdbc716, []int{1}
}
func (m *DocumentAttributeVideo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DocumentAttributeVideo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DocumentAttributeVideo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DocumentAttributeVideo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DocumentAttributeVideo.Merge(m, src)
}
func (m *DocumentAttributeVideo) XXX_Size() int {
	return m.Size()
}
func (m *DocumentAttributeVideo) XXX_DiscardUnknown() {
	xxx_messageInfo_DocumentAttributeVideo.DiscardUnknown(m)
}

var xxx_messageInfo_DocumentAttributeVideo proto.InternalMessageInfo

func (m *DocumentAttributeVideo) GetWidth() uint32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *DocumentAttributeVideo) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *DocumentAttributeVideo) GetDuration() uint32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *DocumentAttributeVideo) GetRound() bool {
	if m != nil {
		return m.Round
	}
	return false
}

// DocumentAttributePhoto
type DocumentAttributePhoto struct {
	Width  uint32 `protobuf:"varint,1,req,name=Width" json:"Width"`
	Height uint32 `protobuf:"varint,2,req,name=Height" json:"Height"`
}

func (m *DocumentAttributePhoto) Reset()         { *m = DocumentAttributePhoto{} }
func (m *DocumentAttributePhoto) String() string { return proto.CompactTextString(m) }
func (*DocumentAttributePhoto) ProtoMessage()    {}
func (*DocumentAttributePhoto) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3fb7b389bdbc716, []int{2}
}
func (m *DocumentAttributePhoto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DocumentAttributePhoto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DocumentAttributePhoto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DocumentAttributePhoto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DocumentAttributePhoto.Merge(m, src)
}
func (m *DocumentAttributePhoto) XXX_Size() int {
	return m.Size()
}
func (m *DocumentAttributePhoto) XXX_DiscardUnknown() {
	xxx_messageInfo_DocumentAttributePhoto.DiscardUnknown(m)
}

var xxx_messageInfo_DocumentAttributePhoto proto.InternalMessageInfo

func (m *DocumentAttributePhoto) GetWidth() uint32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *DocumentAttributePhoto) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

// DocumentAttributeFile
type DocumentAttributeFile struct {
	Filename string `protobuf:"bytes,1,req,name=Filename" json:"Filename"`
}

func (m *DocumentAttributeFile) Reset()         { *m = DocumentAttributeFile{} }
func (m *DocumentAttributeFile) String() string { return proto.CompactTextString(m) }
func (*DocumentAttributeFile) ProtoMessage()    {}
func (*DocumentAttributeFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3fb7b389bdbc716, []int{3}
}
func (m *DocumentAttributeFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DocumentAttributeFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DocumentAttributeFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DocumentAttributeFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DocumentAttributeFile.Merge(m, src)
}
func (m *DocumentAttributeFile) XXX_Size() int {
	return m.Size()
}
func (m *DocumentAttributeFile) XXX_DiscardUnknown() {
	xxx_messageInfo_DocumentAttributeFile.DiscardUnknown(m)
}

var xxx_messageInfo_DocumentAttributeFile proto.InternalMessageInfo

func (m *DocumentAttributeFile) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

// DocumentAttribute
type DocumentAttribute struct {
	Type DocumentAttributeType `protobuf:"varint,1,req,name=Type,enum=msg.DocumentAttributeType" json:"Type"`
	Data []byte                `protobuf:"bytes,2,opt,name=Data" json:"Data"`
}

func (m *DocumentAttribute) Reset()         { *m = DocumentAttribute{} }
func (m *DocumentAttribute) String() string { return proto.CompactTextString(m) }
func (*DocumentAttribute) ProtoMessage()    {}
func (*DocumentAttribute) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3fb7b389bdbc716, []int{4}
}
func (m *DocumentAttribute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DocumentAttribute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DocumentAttribute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DocumentAttribute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DocumentAttribute.Merge(m, src)
}
func (m *DocumentAttribute) XXX_Size() int {
	return m.Size()
}
func (m *DocumentAttribute) XXX_DiscardUnknown() {
	xxx_messageInfo_DocumentAttribute.DiscardUnknown(m)
}

var xxx_messageInfo_DocumentAttribute proto.InternalMessageInfo

func (m *DocumentAttribute) GetType() DocumentAttributeType {
	if m != nil {
		return m.Type
	}
	return AttributeTypeNone
}

func (m *DocumentAttribute) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// Document
type Document struct {
	ID         int64                `protobuf:"varint,1,req,name=ID" json:"ID"`
	AccessHash uint64               `protobuf:"fixed64,2,req,name=AccessHash" json:"AccessHash"`
	Date       int64                `protobuf:"varint,3,req,name=Date" json:"Date"`
	MimeType   string               `protobuf:"bytes,4,req,name=MimeType" json:"MimeType"`
	FileSize   int32                `protobuf:"varint,5,req,name=FileSize" json:"FileSize"`
	Version    int32                `protobuf:"varint,6,req,name=Version" json:"Version"`
	ClusterID  int32                `protobuf:"varint,7,req,name=ClusterID" json:"ClusterID"`
	Attributes []*DocumentAttribute `protobuf:"bytes,8,rep,name=Attributes" json:"Attributes,omitempty"`
}

func (m *Document) Reset()         { *m = Document{} }
func (m *Document) String() string { return proto.CompactTextString(m) }
func (*Document) ProtoMessage()    {}
func (*Document) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3fb7b389bdbc716, []int{5}
}
func (m *Document) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Document) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Document.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Document) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Document.Merge(m, src)
}
func (m *Document) XXX_Size() int {
	return m.Size()
}
func (m *Document) XXX_DiscardUnknown() {
	xxx_messageInfo_Document.DiscardUnknown(m)
}

var xxx_messageInfo_Document proto.InternalMessageInfo

func (m *Document) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Document) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *Document) GetDate() int64 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *Document) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *Document) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *Document) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Document) GetClusterID() int32 {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

func (m *Document) GetAttributes() []*DocumentAttribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

// InputMediaUploadedPhoto
type InputMediaUploadedPhoto struct {
	Caption    string               `protobuf:"bytes,1,req,name=Caption" json:"Caption"`
	Stickers   []*InputDocument     `protobuf:"bytes,2,rep,name=Stickers" json:"Stickers,omitempty"`
	File       *InputFile           `protobuf:"bytes,3,req,name=File" json:"File,omitempty"`
	Attributes []*DocumentAttribute `protobuf:"bytes,4,rep,name=Attributes" json:"Attributes,omitempty"`
}

func (m *InputMediaUploadedPhoto) Reset()         { *m = InputMediaUploadedPhoto{} }
func (m *InputMediaUploadedPhoto) String() string { return proto.CompactTextString(m) }
func (*InputMediaUploadedPhoto) ProtoMessage()    {}
func (*InputMediaUploadedPhoto) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3fb7b389bdbc716, []int{6}
}
func (m *InputMediaUploadedPhoto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputMediaUploadedPhoto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputMediaUploadedPhoto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputMediaUploadedPhoto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputMediaUploadedPhoto.Merge(m, src)
}
func (m *InputMediaUploadedPhoto) XXX_Size() int {
	return m.Size()
}
func (m *InputMediaUploadedPhoto) XXX_DiscardUnknown() {
	xxx_messageInfo_InputMediaUploadedPhoto.DiscardUnknown(m)
}

var xxx_messageInfo_InputMediaUploadedPhoto proto.InternalMessageInfo

func (m *InputMediaUploadedPhoto) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InputMediaUploadedPhoto) GetStickers() []*InputDocument {
	if m != nil {
		return m.Stickers
	}
	return nil
}

func (m *InputMediaUploadedPhoto) GetFile() *InputFile {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *InputMediaUploadedPhoto) GetAttributes() []*DocumentAttribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

// InputMediaPhoto
type InputMediaPhoto struct {
	Caption string         `protobuf:"bytes,1,req,name=Caption" json:"Caption"`
	Photo   *InputDocument `protobuf:"bytes,2,req,name=Photo" json:"Photo,omitempty"`
}

func (m *InputMediaPhoto) Reset()         { *m = InputMediaPhoto{} }
func (m *InputMediaPhoto) String() string { return proto.CompactTextString(m) }
func (*InputMediaPhoto) ProtoMessage()    {}
func (*InputMediaPhoto) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3fb7b389bdbc716, []int{7}
}
func (m *InputMediaPhoto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputMediaPhoto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputMediaPhoto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputMediaPhoto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputMediaPhoto.Merge(m, src)
}
func (m *InputMediaPhoto) XXX_Size() int {
	return m.Size()
}
func (m *InputMediaPhoto) XXX_DiscardUnknown() {
	xxx_messageInfo_InputMediaPhoto.DiscardUnknown(m)
}

var xxx_messageInfo_InputMediaPhoto proto.InternalMessageInfo

func (m *InputMediaPhoto) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InputMediaPhoto) GetPhoto() *InputDocument {
	if m != nil {
		return m.Photo
	}
	return nil
}

// InputMediaContact
type InputMediaContact struct {
	Phone     string `protobuf:"bytes,1,req,name=Phone" json:"Phone"`
	FirstName string `protobuf:"bytes,2,req,name=FirstName" json:"FirstName"`
	LastName  string `protobuf:"bytes,3,req,name=LastName" json:"LastName"`
	VCard     string `protobuf:"bytes,4,opt,name=VCard" json:"VCard"`
}

func (m *InputMediaContact) Reset()         { *m = InputMediaContact{} }
func (m *InputMediaContact) String() string { return proto.CompactTextString(m) }
func (*InputMediaContact) ProtoMessage()    {}
func (*InputMediaContact) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3fb7b389bdbc716, []int{8}
}
func (m *InputMediaContact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputMediaContact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputMediaContact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputMediaContact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputMediaContact.Merge(m, src)
}
func (m *InputMediaContact) XXX_Size() int {
	return m.Size()
}
func (m *InputMediaContact) XXX_DiscardUnknown() {
	xxx_messageInfo_InputMediaContact.DiscardUnknown(m)
}

var xxx_messageInfo_InputMediaContact proto.InternalMessageInfo

func (m *InputMediaContact) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *InputMediaContact) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *InputMediaContact) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *InputMediaContact) GetVCard() string {
	if m != nil {
		return m.VCard
	}
	return ""
}

// InputMediaUploadedDocument
type InputMediaUploadedDocument struct {
	File       *InputFile           `protobuf:"bytes,1,req,name=File" json:"File,omitempty"`
	Thumbnail  *InputFile           `protobuf:"bytes,2,opt,name=Thumbnail" json:"Thumbnail,omitempty"`
	MimeType   string               `protobuf:"bytes,3,req,name=MimeType" json:"MimeType"`
	Caption    string               `protobuf:"bytes,4,req,name=Caption" json:"Caption"`
	Stickers   []*InputDocument     `protobuf:"bytes,5,rep,name=Stickers" json:"Stickers,omitempty"`
	Attributes []*DocumentAttribute `protobuf:"bytes,6,rep,name=Attributes" json:"Attributes,omitempty"`
}

func (m *InputMediaUploadedDocument) Reset()         { *m = InputMediaUploadedDocument{} }
func (m *InputMediaUploadedDocument) String() string { return proto.CompactTextString(m) }
func (*InputMediaUploadedDocument) ProtoMessage()    {}
func (*InputMediaUploadedDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3fb7b389bdbc716, []int{9}
}
func (m *InputMediaUploadedDocument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputMediaUploadedDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputMediaUploadedDocument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputMediaUploadedDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputMediaUploadedDocument.Merge(m, src)
}
func (m *InputMediaUploadedDocument) XXX_Size() int {
	return m.Size()
}
func (m *InputMediaUploadedDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_InputMediaUploadedDocument.DiscardUnknown(m)
}

var xxx_messageInfo_InputMediaUploadedDocument proto.InternalMessageInfo

func (m *InputMediaUploadedDocument) GetFile() *InputFile {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *InputMediaUploadedDocument) GetThumbnail() *InputFile {
	if m != nil {
		return m.Thumbnail
	}
	return nil
}

func (m *InputMediaUploadedDocument) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *InputMediaUploadedDocument) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InputMediaUploadedDocument) GetStickers() []*InputDocument {
	if m != nil {
		return m.Stickers
	}
	return nil
}

func (m *InputMediaUploadedDocument) GetAttributes() []*DocumentAttribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

// InputMediaDocument
type InputMediaDocument struct {
	Caption  string         `protobuf:"bytes,1,req,name=Caption" json:"Caption"`
	Document *InputDocument `protobuf:"bytes,2,req,name=Document" json:"Document,omitempty"`
}

func (m *InputMediaDocument) Reset()         { *m = InputMediaDocument{} }
func (m *InputMediaDocument) String() string { return proto.CompactTextString(m) }
func (*InputMediaDocument) ProtoMessage()    {}
func (*InputMediaDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3fb7b389bdbc716, []int{10}
}
func (m *InputMediaDocument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputMediaDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputMediaDocument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputMediaDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputMediaDocument.Merge(m, src)
}
func (m *InputMediaDocument) XXX_Size() int {
	return m.Size()
}
func (m *InputMediaDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_InputMediaDocument.DiscardUnknown(m)
}

var xxx_messageInfo_InputMediaDocument proto.InternalMessageInfo

func (m *InputMediaDocument) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InputMediaDocument) GetDocument() *InputDocument {
	if m != nil {
		return m.Document
	}
	return nil
}

// MediaPhoto
type MediaPhoto struct {
}

func (m *MediaPhoto) Reset()         { *m = MediaPhoto{} }
func (m *MediaPhoto) String() string { return proto.CompactTextString(m) }
func (*MediaPhoto) ProtoMessage()    {}
func (*MediaPhoto) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3fb7b389bdbc716, []int{11}
}
func (m *MediaPhoto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MediaPhoto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MediaPhoto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MediaPhoto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MediaPhoto.Merge(m, src)
}
func (m *MediaPhoto) XXX_Size() int {
	return m.Size()
}
func (m *MediaPhoto) XXX_DiscardUnknown() {
	xxx_messageInfo_MediaPhoto.DiscardUnknown(m)
}

var xxx_messageInfo_MediaPhoto proto.InternalMessageInfo

// MediaDocument
type MediaDocument struct {
	Caption      string    `protobuf:"bytes,1,req,name=Caption" json:"Caption"`
	TTLinSeconds int32     `protobuf:"varint,2,req,name=TTLinSeconds" json:"TTLinSeconds"`
	Doc          *Document `protobuf:"bytes,3,req,name=Doc" json:"Doc,omitempty"`
}

func (m *MediaDocument) Reset()         { *m = MediaDocument{} }
func (m *MediaDocument) String() string { return proto.CompactTextString(m) }
func (*MediaDocument) ProtoMessage()    {}
func (*MediaDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3fb7b389bdbc716, []int{12}
}
func (m *MediaDocument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MediaDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MediaDocument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MediaDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MediaDocument.Merge(m, src)
}
func (m *MediaDocument) XXX_Size() int {
	return m.Size()
}
func (m *MediaDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_MediaDocument.DiscardUnknown(m)
}

var xxx_messageInfo_MediaDocument proto.InternalMessageInfo

func (m *MediaDocument) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *MediaDocument) GetTTLinSeconds() int32 {
	if m != nil {
		return m.TTLinSeconds
	}
	return 0
}

func (m *MediaDocument) GetDoc() *Document {
	if m != nil {
		return m.Doc
	}
	return nil
}

// MediaContact
type MediaContact struct {
	Phone     string `protobuf:"bytes,1,req,name=Phone" json:"Phone"`
	FirstName string `protobuf:"bytes,2,req,name=FirstName" json:"FirstName"`
	LastName  string `protobuf:"bytes,3,req,name=LastName" json:"LastName"`
	VCard     string `protobuf:"bytes,4,opt,name=VCard" json:"VCard"`
}

func (m *MediaContact) Reset()         { *m = MediaContact{} }
func (m *MediaContact) String() string { return proto.CompactTextString(m) }
func (*MediaContact) ProtoMessage()    {}
func (*MediaContact) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3fb7b389bdbc716, []int{13}
}
func (m *MediaContact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MediaContact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MediaContact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MediaContact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MediaContact.Merge(m, src)
}
func (m *MediaContact) XXX_Size() int {
	return m.Size()
}
func (m *MediaContact) XXX_DiscardUnknown() {
	xxx_messageInfo_MediaContact.DiscardUnknown(m)
}

var xxx_messageInfo_MediaContact proto.InternalMessageInfo

func (m *MediaContact) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *MediaContact) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *MediaContact) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *MediaContact) GetVCard() string {
	if m != nil {
		return m.VCard
	}
	return ""
}

// MediaWebPage
type MediaWebPage struct {
}

func (m *MediaWebPage) Reset()         { *m = MediaWebPage{} }
func (m *MediaWebPage) String() string { return proto.CompactTextString(m) }
func (*MediaWebPage) ProtoMessage()    {}
func (*MediaWebPage) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3fb7b389bdbc716, []int{14}
}
func (m *MediaWebPage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MediaWebPage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MediaWebPage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MediaWebPage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MediaWebPage.Merge(m, src)
}
func (m *MediaWebPage) XXX_Size() int {
	return m.Size()
}
func (m *MediaWebPage) XXX_DiscardUnknown() {
	xxx_messageInfo_MediaWebPage.DiscardUnknown(m)
}

var xxx_messageInfo_MediaWebPage proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("msg.DocumentAttributeType", DocumentAttributeType_name, DocumentAttributeType_value)
	proto.RegisterEnum("msg.DocumentType", DocumentType_name, DocumentType_value)
	proto.RegisterType((*DocumentAttributeAudio)(nil), "msg.DocumentAttributeAudio")
	proto.RegisterType((*DocumentAttributeVideo)(nil), "msg.DocumentAttributeVideo")
	proto.RegisterType((*DocumentAttributePhoto)(nil), "msg.DocumentAttributePhoto")
	proto.RegisterType((*DocumentAttributeFile)(nil), "msg.DocumentAttributeFile")
	proto.RegisterType((*DocumentAttribute)(nil), "msg.DocumentAttribute")
	proto.RegisterType((*Document)(nil), "msg.Document")
	proto.RegisterType((*InputMediaUploadedPhoto)(nil), "msg.InputMediaUploadedPhoto")
	proto.RegisterType((*InputMediaPhoto)(nil), "msg.InputMediaPhoto")
	proto.RegisterType((*InputMediaContact)(nil), "msg.InputMediaContact")
	proto.RegisterType((*InputMediaUploadedDocument)(nil), "msg.InputMediaUploadedDocument")
	proto.RegisterType((*InputMediaDocument)(nil), "msg.InputMediaDocument")
	proto.RegisterType((*MediaPhoto)(nil), "msg.MediaPhoto")
	proto.RegisterType((*MediaDocument)(nil), "msg.MediaDocument")
	proto.RegisterType((*MediaContact)(nil), "msg.MediaContact")
	proto.RegisterType((*MediaWebPage)(nil), "msg.MediaWebPage")
}

func init() { proto.RegisterFile("core.message.medias.proto", fileDescriptor_c3fb7b389bdbc716) }

var fileDescriptor_c3fb7b389bdbc716 = []byte{
	// 886 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x56, 0x4d, 0x6f, 0xdb, 0x46,
	0x10, 0x15, 0x3f, 0x24, 0xcb, 0x13, 0xd9, 0xa5, 0xb7, 0x88, 0xc3, 0x0a, 0x01, 0x23, 0xf0, 0x50,
	0x08, 0x41, 0xab, 0x14, 0x46, 0x51, 0xa0, 0x47, 0xd9, 0x42, 0x10, 0x03, 0x49, 0x60, 0xc8, 0x8a,
	0x7d, 0xe8, 0x69, 0x45, 0x6e, 0xa4, 0x45, 0x44, 0xae, 0x40, 0x2e, 0x5b, 0x24, 0xf7, 0xde, 0x7a,
	0x48, 0x6f, 0xfd, 0x01, 0xf9, 0x2b, 0x05, 0x72, 0xf4, 0xa1, 0x87, 0x9e, 0x8a, 0xd6, 0xfe, 0x23,
	0xc5, 0x0e, 0xbf, 0x4d, 0x35, 0x55, 0x7b, 0xca, 0x49, 0xe2, 0x9b, 0xb7, 0x33, 0xf3, 0x66, 0xde,
	0x52, 0x82, 0xcf, 0x3c, 0x11, 0xb1, 0x51, 0xc0, 0xe2, 0x98, 0x2e, 0xd4, 0xa7, 0xcf, 0x69, 0x3c,
	0x5a, 0x47, 0x42, 0x0a, 0x62, 0x04, 0xf1, 0xa2, 0x6f, 0x61, 0x5c, 0xbe, 0x5e, 0xb3, 0x0c, 0xee,
	0x7f, 0xb9, 0xe0, 0x72, 0x99, 0xcc, 0x47, 0x9e, 0x08, 0x1e, 0x2d, 0xc4, 0x42, 0x3c, 0x42, 0x78,
	0x9e, 0xbc, 0xc4, 0x27, 0x7c, 0xc0, 0x6f, 0x29, 0xdd, 0xfd, 0x4d, 0x83, 0xc3, 0x89, 0xf0, 0x92,
	0x80, 0x85, 0x72, 0x2c, 0x65, 0xc4, 0xe7, 0x89, 0x64, 0xe3, 0xc4, 0xe7, 0x82, 0xf4, 0xa1, 0x7d,
	0x21, 0xb8, 0xc7, 0x6c, 0x6d, 0xa0, 0x0f, 0xbb, 0xc7, 0xe6, 0xfb, 0x3f, 0x1e, 0xb4, 0xa6, 0x29,
	0x44, 0x06, 0xd0, 0x9d, 0x24, 0x11, 0x95, 0x5c, 0x84, 0xb6, 0x3e, 0xd0, 0x87, 0x7b, 0x59, 0xb8,
	0x40, 0xd5, 0xe9, 0x19, 0x97, 0x2b, 0x66, 0x1b, 0x03, 0x7d, 0xb8, 0x9b, 0x9f, 0x46, 0x88, 0xb8,
	0xb0, 0x7b, 0xc6, 0xa2, 0x97, 0x22, 0x0a, 0x58, 0x64, 0x9b, 0x95, 0x78, 0x09, 0xab, 0xf3, 0xe3,
	0xd5, 0x3c, 0x09, 0xec, 0x76, 0xf5, 0x3c, 0x42, 0xaa, 0xfa, 0x25, 0xfd, 0x9e, 0x29, 0xa6, 0xdd,
	0x19, 0x68, 0xc3, 0x5e, 0x5e, 0x3d, 0x47, 0xdd, 0xb7, 0x9b, 0x64, 0x5d, 0x70, 0x9f, 0xa1, 0xac,
	0x4b, 0xee, 0xcb, 0x25, 0xca, 0xca, 0xfb, 0x4e, 0x21, 0x72, 0x1f, 0x3a, 0x4f, 0x18, 0x5f, 0x2c,
	0x65, 0x4d, 0x54, 0x86, 0xd5, 0x44, 0x1b, 0xff, 0x24, 0x7a, 0x2a, 0x92, 0xd0, 0x47, 0x51, 0xc5,
	0xc8, 0x10, 0x72, 0xa7, 0x1b, 0x3a, 0x3a, 0x5b, 0xaa, 0x4d, 0xfe, 0xef, 0x8e, 0xdc, 0x6f, 0xe1,
	0x6e, 0x23, 0xe7, 0x63, 0xbe, 0xc2, 0xfd, 0xa8, 0xcf, 0x90, 0x06, 0xe9, 0xfa, 0xf2, 0x01, 0x16,
	0xa8, 0xeb, 0xc1, 0x41, 0xe3, 0x28, 0xf9, 0x1a, 0xcc, 0xd9, 0xeb, 0x75, 0x7a, 0x64, 0xff, 0xa8,
	0x3f, 0x0a, 0xe2, 0xc5, 0xa8, 0xc1, 0x52, 0x8c, 0x2c, 0x1d, 0xb2, 0x89, 0x0d, 0xe6, 0x84, 0x4a,
	0x6a, 0xeb, 0x95, 0x55, 0x20, 0xe2, 0xbe, 0xd3, 0xa1, 0x9b, 0x9f, 0x27, 0x87, 0xa0, 0x9f, 0x4e,
	0x30, 0xb5, 0x71, 0xdc, 0x51, 0xa4, 0xaf, 0xb4, 0xa9, 0x7e, 0x3a, 0x21, 0x9f, 0x03, 0x8c, 0x3d,
	0x8f, 0xc5, 0xf1, 0x13, 0x1a, 0x2f, 0x51, 0x66, 0xa7, 0x88, 0x57, 0x22, 0x59, 0x99, 0xd4, 0x50,
	0x46, 0xa5, 0x0c, 0xaa, 0x7d, 0xc6, 0x03, 0x6c, 0xac, 0x66, 0xa7, 0x02, 0xcd, 0xe7, 0x71, 0xce,
	0xdf, 0x30, 0x34, 0x54, 0xbb, 0x3a, 0x0f, 0x85, 0x12, 0x07, 0x76, 0x2e, 0x58, 0x14, 0xab, 0xdd,
	0x76, 0x2a, 0x84, 0x1c, 0x54, 0x9e, 0x3d, 0x59, 0x25, 0xb1, 0x64, 0xd1, 0xe9, 0xc4, 0xde, 0xa9,
	0x30, 0x4a, 0x98, 0x7c, 0x03, 0x50, 0x4c, 0x29, 0xb6, 0xbb, 0x03, 0x63, 0x78, 0xe7, 0xe8, 0x70,
	0xf3, 0x10, 0xa7, 0x15, 0xa6, 0xfb, 0xab, 0x06, 0xf7, 0x4e, 0xc3, 0x75, 0x22, 0x9f, 0xa9, 0x0b,
	0xfe, 0x62, 0xbd, 0x12, 0xd4, 0x67, 0x7e, 0x6a, 0x0e, 0x07, 0x76, 0x4e, 0xe8, 0x1a, 0x3d, 0x57,
	0x5d, 0x64, 0x0e, 0x92, 0x11, 0x74, 0xcf, 0x25, 0xf7, 0x5e, 0xb1, 0x28, 0xb6, 0x75, 0xac, 0x48,
	0xb0, 0x22, 0xe6, 0xcb, 0xcb, 0x4e, 0x0b, 0x0e, 0x71, 0xc1, 0x54, 0x9a, 0x71, 0x8a, 0x77, 0x8e,
	0xf6, 0x4b, 0xae, 0x42, 0xa7, 0x18, 0xbb, 0xa5, 0xc3, 0xdc, 0x5a, 0xc7, 0x77, 0xf0, 0x49, 0x29,
	0x63, 0xbb, 0xf6, 0x87, 0xd0, 0x46, 0x22, 0xee, 0x7d, 0x73, 0xef, 0x29, 0xc1, 0xfd, 0x59, 0x83,
	0x83, 0x32, 0xfb, 0x89, 0x08, 0x25, 0xf5, 0xa4, 0xba, 0x3b, 0x67, 0x4b, 0x11, 0xd6, 0x5d, 0x9e,
	0x42, 0x6a, 0x65, 0x8f, 0x79, 0x14, 0xcb, 0xe7, 0xea, 0x16, 0xe8, 0xd5, 0xd7, 0x4c, 0x01, 0x2b,
	0x63, 0x3c, 0xa5, 0x19, 0xa5, 0xfa, 0xa6, 0x2a, 0x50, 0x7c, 0x0d, 0x9e, 0xd0, 0x48, 0xdd, 0x69,
	0xad, 0xac, 0x80, 0x90, 0xfb, 0x8b, 0x0e, 0xfd, 0xe6, 0xe2, 0x0a, 0xc7, 0xe7, 0xb3, 0xd6, 0x3e,
	0x30, 0xeb, 0x2f, 0x60, 0x77, 0xb6, 0x4c, 0x82, 0x79, 0x48, 0xf9, 0x0a, 0x6f, 0x50, 0x93, 0x58,
	0x12, 0x6a, 0x4e, 0x37, 0x36, 0x3a, 0xbd, 0x32, 0x70, 0xf3, 0xdf, 0xfc, 0xd2, 0xde, 0xc2, 0x2f,
	0x75, 0x2f, 0x74, 0xb6, 0xf6, 0x82, 0x0f, 0xa4, 0x9c, 0x4c, 0x31, 0x91, 0x2d, 0xdc, 0x9c, 0x73,
	0x3f, 0xe0, 0x88, 0x82, 0xe3, 0xf6, 0x00, 0x4a, 0xb3, 0xb9, 0x6f, 0x60, 0xef, 0xbf, 0x95, 0x1b,
	0x42, 0x6f, 0x36, 0x7b, 0xca, 0xc3, 0x73, 0xe6, 0x89, 0xd0, 0x8f, 0xb1, 0x64, 0x7e, 0xaf, 0x6b,
	0x11, 0xf2, 0x00, 0x8c, 0x89, 0xf0, 0xb2, 0x5b, 0xb3, 0x57, 0xd3, 0x3f, 0x55, 0x11, 0xf7, 0x27,
	0x0d, 0x7a, 0x1f, 0x91, 0x33, 0xf7, 0xb3, 0x6e, 0x2e, 0xd9, 0xfc, 0x8c, 0x2e, 0xd8, 0xc3, 0x77,
	0xda, 0x86, 0x9f, 0x0a, 0x34, 0xcc, 0x5d, 0x38, 0xa8, 0x01, 0xcf, 0x45, 0xc8, 0xac, 0x16, 0x39,
	0x04, 0x52, 0x83, 0xf1, 0x3f, 0x81, 0xa5, 0x35, 0x70, 0xfc, 0x51, 0xb5, 0xf4, 0x06, 0x8e, 0x1b,
	0xb1, 0x8c, 0x46, 0x7a, 0xe5, 0x68, 0xcb, 0xac, 0xc1, 0xe3, 0x90, 0x07, 0x54, 0x32, 0xdf, 0x6a,
	0x3f, 0xfc, 0x51, 0x83, 0x5e, 0xde, 0x26, 0x76, 0x77, 0x0f, 0x3e, 0xad, 0x3e, 0xbf, 0x08, 0x5f,
	0x85, 0xe2, 0x87, 0xd0, 0x6a, 0xa9, 0x04, 0xd5, 0x40, 0x5a, 0x4e, 0xbb, 0x0d, 0xe3, 0xbf, 0x15,
	0x4b, 0x6f, 0xc0, 0xd8, 0xb4, 0x71, 0x3b, 0x7b, 0x36, 0x2c, 0xcb, 0x3c, 0xbe, 0x7f, 0xf5, 0x97,
	0xd3, 0x7a, 0x7f, 0xed, 0x68, 0x57, 0xd7, 0x8e, 0xf6, 0xe7, 0xb5, 0xa3, 0xbd, 0xbd, 0x71, 0x5a,
	0x57, 0x37, 0x4e, 0xeb, 0xf7, 0x1b, 0xa7, 0xf5, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf4, 0x0d,
	0xe1, 0x66, 0x96, 0x09, 0x00, 0x00,
}

func (m *DocumentAttributeAudio) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DocumentAttributeAudio) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.Voice {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x10
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(m.Duration))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(len(m.Title)))
	i += copy(dAtA[i:], m.Title)
	dAtA[i] = 0x22
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(len(m.Performer)))
	i += copy(dAtA[i:], m.Performer)
	dAtA[i] = 0x2a
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(len(m.Album)))
	i += copy(dAtA[i:], m.Album)
	if m.Waveform != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCoreMessageMedias(dAtA, i, uint64(len(m.Waveform)))
		i += copy(dAtA[i:], m.Waveform)
	}
	return i, nil
}

func (m *DocumentAttributeVideo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DocumentAttributeVideo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(m.Width))
	dAtA[i] = 0x10
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(m.Height))
	dAtA[i] = 0x18
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(m.Duration))
	dAtA[i] = 0x20
	i++
	if m.Round {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *DocumentAttributePhoto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DocumentAttributePhoto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(m.Width))
	dAtA[i] = 0x10
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(m.Height))
	return i, nil
}

func (m *DocumentAttributeFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DocumentAttributeFile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(len(m.Filename)))
	i += copy(dAtA[i:], m.Filename)
	return i, nil
}

func (m *DocumentAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DocumentAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(m.Type))
	if m.Data != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCoreMessageMedias(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *Document) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Document) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x11
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i += 8
	dAtA[i] = 0x18
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(m.Date))
	dAtA[i] = 0x22
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(len(m.MimeType)))
	i += copy(dAtA[i:], m.MimeType)
	dAtA[i] = 0x28
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(m.FileSize))
	dAtA[i] = 0x30
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(m.Version))
	dAtA[i] = 0x38
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(m.ClusterID))
	if len(m.Attributes) > 0 {
		for _, msg := range m.Attributes {
			dAtA[i] = 0x42
			i++
			i = encodeVarintCoreMessageMedias(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InputMediaUploadedPhoto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMediaUploadedPhoto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(len(m.Caption)))
	i += copy(dAtA[i:], m.Caption)
	if len(m.Stickers) > 0 {
		for _, msg := range m.Stickers {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCoreMessageMedias(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.File == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("File")
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCoreMessageMedias(dAtA, i, uint64(m.File.Size()))
		n1, err := m.File.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Attributes) > 0 {
		for _, msg := range m.Attributes {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCoreMessageMedias(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InputMediaPhoto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMediaPhoto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(len(m.Caption)))
	i += copy(dAtA[i:], m.Caption)
	if m.Photo == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("Photo")
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCoreMessageMedias(dAtA, i, uint64(m.Photo.Size()))
		n2, err := m.Photo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *InputMediaContact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMediaContact) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(len(m.Phone)))
	i += copy(dAtA[i:], m.Phone)
	dAtA[i] = 0x12
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(len(m.FirstName)))
	i += copy(dAtA[i:], m.FirstName)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(len(m.LastName)))
	i += copy(dAtA[i:], m.LastName)
	dAtA[i] = 0x22
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(len(m.VCard)))
	i += copy(dAtA[i:], m.VCard)
	return i, nil
}

func (m *InputMediaUploadedDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMediaUploadedDocument) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.File == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("File")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCoreMessageMedias(dAtA, i, uint64(m.File.Size()))
		n3, err := m.File.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Thumbnail != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCoreMessageMedias(dAtA, i, uint64(m.Thumbnail.Size()))
		n4, err := m.Thumbnail.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(len(m.MimeType)))
	i += copy(dAtA[i:], m.MimeType)
	dAtA[i] = 0x22
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(len(m.Caption)))
	i += copy(dAtA[i:], m.Caption)
	if len(m.Stickers) > 0 {
		for _, msg := range m.Stickers {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintCoreMessageMedias(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Attributes) > 0 {
		for _, msg := range m.Attributes {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCoreMessageMedias(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InputMediaDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMediaDocument) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(len(m.Caption)))
	i += copy(dAtA[i:], m.Caption)
	if m.Document == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("Document")
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCoreMessageMedias(dAtA, i, uint64(m.Document.Size()))
		n5, err := m.Document.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *MediaPhoto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MediaPhoto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MediaDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MediaDocument) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(len(m.Caption)))
	i += copy(dAtA[i:], m.Caption)
	dAtA[i] = 0x10
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(m.TTLinSeconds))
	if m.Doc == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("Doc")
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCoreMessageMedias(dAtA, i, uint64(m.Doc.Size()))
		n6, err := m.Doc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *MediaContact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MediaContact) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(len(m.Phone)))
	i += copy(dAtA[i:], m.Phone)
	dAtA[i] = 0x12
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(len(m.FirstName)))
	i += copy(dAtA[i:], m.FirstName)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(len(m.LastName)))
	i += copy(dAtA[i:], m.LastName)
	dAtA[i] = 0x22
	i++
	i = encodeVarintCoreMessageMedias(dAtA, i, uint64(len(m.VCard)))
	i += copy(dAtA[i:], m.VCard)
	return i, nil
}

func (m *MediaWebPage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MediaWebPage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintCoreMessageMedias(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *DocumentAttributeAudio) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	n += 1 + sovCoreMessageMedias(uint64(m.Duration))
	l = len(m.Title)
	n += 1 + l + sovCoreMessageMedias(uint64(l))
	l = len(m.Performer)
	n += 1 + l + sovCoreMessageMedias(uint64(l))
	l = len(m.Album)
	n += 1 + l + sovCoreMessageMedias(uint64(l))
	if m.Waveform != nil {
		l = len(m.Waveform)
		n += 1 + l + sovCoreMessageMedias(uint64(l))
	}
	return n
}

func (m *DocumentAttributeVideo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreMessageMedias(uint64(m.Width))
	n += 1 + sovCoreMessageMedias(uint64(m.Height))
	n += 1 + sovCoreMessageMedias(uint64(m.Duration))
	n += 2
	return n
}

func (m *DocumentAttributePhoto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreMessageMedias(uint64(m.Width))
	n += 1 + sovCoreMessageMedias(uint64(m.Height))
	return n
}

func (m *DocumentAttributeFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Filename)
	n += 1 + l + sovCoreMessageMedias(uint64(l))
	return n
}

func (m *DocumentAttribute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreMessageMedias(uint64(m.Type))
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovCoreMessageMedias(uint64(l))
	}
	return n
}

func (m *Document) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreMessageMedias(uint64(m.ID))
	n += 9
	n += 1 + sovCoreMessageMedias(uint64(m.Date))
	l = len(m.MimeType)
	n += 1 + l + sovCoreMessageMedias(uint64(l))
	n += 1 + sovCoreMessageMedias(uint64(m.FileSize))
	n += 1 + sovCoreMessageMedias(uint64(m.Version))
	n += 1 + sovCoreMessageMedias(uint64(m.ClusterID))
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovCoreMessageMedias(uint64(l))
		}
	}
	return n
}

func (m *InputMediaUploadedPhoto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Caption)
	n += 1 + l + sovCoreMessageMedias(uint64(l))
	if len(m.Stickers) > 0 {
		for _, e := range m.Stickers {
			l = e.Size()
			n += 1 + l + sovCoreMessageMedias(uint64(l))
		}
	}
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovCoreMessageMedias(uint64(l))
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovCoreMessageMedias(uint64(l))
		}
	}
	return n
}

func (m *InputMediaPhoto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Caption)
	n += 1 + l + sovCoreMessageMedias(uint64(l))
	if m.Photo != nil {
		l = m.Photo.Size()
		n += 1 + l + sovCoreMessageMedias(uint64(l))
	}
	return n
}

func (m *InputMediaContact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Phone)
	n += 1 + l + sovCoreMessageMedias(uint64(l))
	l = len(m.FirstName)
	n += 1 + l + sovCoreMessageMedias(uint64(l))
	l = len(m.LastName)
	n += 1 + l + sovCoreMessageMedias(uint64(l))
	l = len(m.VCard)
	n += 1 + l + sovCoreMessageMedias(uint64(l))
	return n
}

func (m *InputMediaUploadedDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovCoreMessageMedias(uint64(l))
	}
	if m.Thumbnail != nil {
		l = m.Thumbnail.Size()
		n += 1 + l + sovCoreMessageMedias(uint64(l))
	}
	l = len(m.MimeType)
	n += 1 + l + sovCoreMessageMedias(uint64(l))
	l = len(m.Caption)
	n += 1 + l + sovCoreMessageMedias(uint64(l))
	if len(m.Stickers) > 0 {
		for _, e := range m.Stickers {
			l = e.Size()
			n += 1 + l + sovCoreMessageMedias(uint64(l))
		}
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovCoreMessageMedias(uint64(l))
		}
	}
	return n
}

func (m *InputMediaDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Caption)
	n += 1 + l + sovCoreMessageMedias(uint64(l))
	if m.Document != nil {
		l = m.Document.Size()
		n += 1 + l + sovCoreMessageMedias(uint64(l))
	}
	return n
}

func (m *MediaPhoto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MediaDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Caption)
	n += 1 + l + sovCoreMessageMedias(uint64(l))
	n += 1 + sovCoreMessageMedias(uint64(m.TTLinSeconds))
	if m.Doc != nil {
		l = m.Doc.Size()
		n += 1 + l + sovCoreMessageMedias(uint64(l))
	}
	return n
}

func (m *MediaContact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Phone)
	n += 1 + l + sovCoreMessageMedias(uint64(l))
	l = len(m.FirstName)
	n += 1 + l + sovCoreMessageMedias(uint64(l))
	l = len(m.LastName)
	n += 1 + l + sovCoreMessageMedias(uint64(l))
	l = len(m.VCard)
	n += 1 + l + sovCoreMessageMedias(uint64(l))
	return n
}

func (m *MediaWebPage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovCoreMessageMedias(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCoreMessageMedias(x uint64) (n int) {
	return sovCoreMessageMedias(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DocumentAttributeAudio) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreMessageMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocumentAttributeAudio: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocumentAttributeAudio: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voice", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Voice = bool(v != 0)
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Performer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Performer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Album", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Album = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Waveform", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Waveform = append(m.Waveform[:0], dAtA[iNdEx:postIndex]...)
			if m.Waveform == nil {
				m.Waveform = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreMessageMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Voice")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Duration")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Title")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Performer")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Album")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentAttributeVideo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreMessageMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocumentAttributeVideo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocumentAttributeVideo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Round = bool(v != 0)
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreMessageMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Width")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Height")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Duration")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Round")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentAttributePhoto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreMessageMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocumentAttributePhoto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocumentAttributePhoto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreMessageMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Width")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Height")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentAttributeFile) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreMessageMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocumentAttributeFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocumentAttributeFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreMessageMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Filename")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentAttribute) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreMessageMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocumentAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocumentAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (DocumentAttributeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreMessageMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Type")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Document) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreMessageMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Document: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Document: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000040)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &DocumentAttribute{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreMessageMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Date")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MimeType")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FileSize")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Version")
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ClusterID")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMediaUploadedPhoto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreMessageMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMediaUploadedPhoto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMediaUploadedPhoto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stickers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stickers = append(m.Stickers, &InputDocument{})
			if err := m.Stickers[len(m.Stickers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &InputFile{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &DocumentAttribute{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreMessageMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Caption")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("File")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMediaPhoto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreMessageMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMediaPhoto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMediaPhoto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Photo == nil {
				m.Photo = &InputDocument{}
			}
			if err := m.Photo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreMessageMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Caption")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Photo")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMediaContact) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreMessageMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMediaContact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMediaContact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VCard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VCard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreMessageMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Phone")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FirstName")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("LastName")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMediaUploadedDocument) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreMessageMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMediaUploadedDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMediaUploadedDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &InputFile{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumbnail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Thumbnail == nil {
				m.Thumbnail = &InputFile{}
			}
			if err := m.Thumbnail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stickers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stickers = append(m.Stickers, &InputDocument{})
			if err := m.Stickers[len(m.Stickers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &DocumentAttribute{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreMessageMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("File")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MimeType")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Caption")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMediaDocument) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreMessageMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMediaDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMediaDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Document", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Document == nil {
				m.Document = &InputDocument{}
			}
			if err := m.Document.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreMessageMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Caption")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Document")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MediaPhoto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreMessageMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MediaPhoto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MediaPhoto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCoreMessageMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MediaDocument) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreMessageMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MediaDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MediaDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTLinSeconds", wireType)
			}
			m.TTLinSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTLinSeconds |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Doc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Doc == nil {
				m.Doc = &Document{}
			}
			if err := m.Doc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreMessageMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Caption")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("TTLinSeconds")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Doc")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MediaContact) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreMessageMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MediaContact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MediaContact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VCard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VCard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreMessageMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Phone")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FirstName")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("LastName")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MediaWebPage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreMessageMedias
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MediaWebPage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MediaWebPage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCoreMessageMedias(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreMessageMedias
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCoreMessageMedias(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCoreMessageMedias
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCoreMessageMedias
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCoreMessageMedias
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCoreMessageMedias
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCoreMessageMedias(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCoreMessageMedias = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCoreMessageMedias   = fmt.Errorf("proto: integer overflow")
)

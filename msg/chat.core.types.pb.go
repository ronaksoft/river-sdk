// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: chat.core.types.proto

package msg

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// TypingAction
type TypingAction int32

const (
	TypingActionTyping         TypingAction = 0
	TypingActionRecordingVoice TypingAction = 1
	TypingActionRecordingVideo TypingAction = 2
	TypingActionUploading      TypingAction = 3
	TypingActionCancel         TypingAction = 4
)

var TypingAction_name = map[int32]string{
	0: "TypingActionTyping",
	1: "TypingActionRecordingVoice",
	2: "TypingActionRecordingVideo",
	3: "TypingActionUploading",
	4: "TypingActionCancel",
}

var TypingAction_value = map[string]int32{
	"TypingActionTyping":         0,
	"TypingActionRecordingVoice": 1,
	"TypingActionRecordingVideo": 2,
	"TypingActionUploading":      3,
	"TypingActionCancel":         4,
}

func (x TypingAction) Enum() *TypingAction {
	p := new(TypingAction)
	*p = x
	return p
}

func (x TypingAction) String() string {
	return proto.EnumName(TypingAction_name, int32(x))
}

func (x *TypingAction) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TypingAction_value, data, "TypingAction")
	if err != nil {
		return err
	}
	*x = TypingAction(value)
	return nil
}

func (TypingAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{0}
}

// PeerType
type PeerType int32

const (
	PeerSelf       PeerType = 0
	PeerUser       PeerType = 1
	PeerGroup      PeerType = 2
	PeerSuperGroup PeerType = 3
	PeerChannel    PeerType = 4
)

var PeerType_name = map[int32]string{
	0: "PeerSelf",
	1: "PeerUser",
	2: "PeerGroup",
	3: "PeerSuperGroup",
	4: "PeerChannel",
}

var PeerType_value = map[string]int32{
	"PeerSelf":       0,
	"PeerUser":       1,
	"PeerGroup":      2,
	"PeerSuperGroup": 3,
	"PeerChannel":    4,
}

func (x PeerType) Enum() *PeerType {
	p := new(PeerType)
	*p = x
	return p
}

func (x PeerType) String() string {
	return proto.EnumName(PeerType_name, int32(x))
}

func (x *PeerType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PeerType_value, data, "PeerType")
	if err != nil {
		return err
	}
	*x = PeerType(value)
	return nil
}

func (PeerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{1}
}

// UserStatus
type UserStatus int32

const (
	UserStatusOffline   UserStatus = 0
	UserStatusOnline    UserStatus = 1
	UserStatusRecently  UserStatus = 2
	UserStatusLastWeek  UserStatus = 3
	UserStatusLastMonth UserStatus = 4
)

var UserStatus_name = map[int32]string{
	0: "UserStatusOffline",
	1: "UserStatusOnline",
	2: "UserStatusRecently",
	3: "UserStatusLastWeek",
	4: "UserStatusLastMonth",
}

var UserStatus_value = map[string]int32{
	"UserStatusOffline":   0,
	"UserStatusOnline":    1,
	"UserStatusRecently":  2,
	"UserStatusLastWeek":  3,
	"UserStatusLastMonth": 4,
}

func (x UserStatus) Enum() *UserStatus {
	p := new(UserStatus)
	*p = x
	return p
}

func (x UserStatus) String() string {
	return proto.EnumName(UserStatus_name, int32(x))
}

func (x *UserStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(UserStatus_value, data, "UserStatus")
	if err != nil {
		return err
	}
	*x = UserStatus(value)
	return nil
}

func (UserStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{2}
}

// MediaType
type MediaType int32

const (
	MediaTypeEmpty       MediaType = 0
	MediaTypePhoto       MediaType = 1
	MediaTypeDocument    MediaType = 2
	MediaTypeContact     MediaType = 3
	MediaTypeGeoLocation MediaType = 4
)

var MediaType_name = map[int32]string{
	0: "MediaTypeEmpty",
	1: "MediaTypePhoto",
	2: "MediaTypeDocument",
	3: "MediaTypeContact",
	4: "MediaTypeGeoLocation",
}

var MediaType_value = map[string]int32{
	"MediaTypeEmpty":       0,
	"MediaTypePhoto":       1,
	"MediaTypeDocument":    2,
	"MediaTypeContact":     3,
	"MediaTypeGeoLocation": 4,
}

func (x MediaType) Enum() *MediaType {
	p := new(MediaType)
	*p = x
	return p
}

func (x MediaType) String() string {
	return proto.EnumName(MediaType_name, int32(x))
}

func (x *MediaType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MediaType_value, data, "MediaType")
	if err != nil {
		return err
	}
	*x = MediaType(value)
	return nil
}

func (MediaType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{3}
}

// MessageEntityType
type MessageEntityType int32

const (
	MessageEntityTypeBold    MessageEntityType = 0
	MessageEntityTypeItalic  MessageEntityType = 1
	MessageEntityTypeMention MessageEntityType = 2
	MessageEntityTypeUrl     MessageEntityType = 3
	MessageEntityTypeEmail   MessageEntityType = 4
	MessageEntityTypeHashtag MessageEntityType = 5
)

var MessageEntityType_name = map[int32]string{
	0: "MessageEntityTypeBold",
	1: "MessageEntityTypeItalic",
	2: "MessageEntityTypeMention",
	3: "MessageEntityTypeUrl",
	4: "MessageEntityTypeEmail",
	5: "MessageEntityTypeHashtag",
}

var MessageEntityType_value = map[string]int32{
	"MessageEntityTypeBold":    0,
	"MessageEntityTypeItalic":  1,
	"MessageEntityTypeMention": 2,
	"MessageEntityTypeUrl":     3,
	"MessageEntityTypeEmail":   4,
	"MessageEntityTypeHashtag": 5,
}

func (x MessageEntityType) Enum() *MessageEntityType {
	p := new(MessageEntityType)
	*p = x
	return p
}

func (x MessageEntityType) String() string {
	return proto.EnumName(MessageEntityType_name, int32(x))
}

func (x *MessageEntityType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MessageEntityType_value, data, "MessageEntityType")
	if err != nil {
		return err
	}
	*x = MessageEntityType(value)
	return nil
}

func (MessageEntityType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{4}
}

// GroupFlags
type GroupFlags int32

const (
	GroupFlagsEmpty          GroupFlags = 0
	GroupFlagsCreator        GroupFlags = 1
	GroupFlagsNonParticipant GroupFlags = 2
	GroupFlagsAdmin          GroupFlags = 3
	GroupFlagsAdminsEnabled  GroupFlags = 4
	GroupFlagsDeactivated    GroupFlags = 5
)

var GroupFlags_name = map[int32]string{
	0: "GroupFlagsEmpty",
	1: "GroupFlagsCreator",
	2: "GroupFlagsNonParticipant",
	3: "GroupFlagsAdmin",
	4: "GroupFlagsAdminsEnabled",
	5: "GroupFlagsDeactivated",
}

var GroupFlags_value = map[string]int32{
	"GroupFlagsEmpty":          0,
	"GroupFlagsCreator":        1,
	"GroupFlagsNonParticipant": 2,
	"GroupFlagsAdmin":          3,
	"GroupFlagsAdminsEnabled":  4,
	"GroupFlagsDeactivated":    5,
}

func (x GroupFlags) Enum() *GroupFlags {
	p := new(GroupFlags)
	*p = x
	return p
}

func (x GroupFlags) String() string {
	return proto.EnumName(GroupFlags_name, int32(x))
}

func (x *GroupFlags) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GroupFlags_value, data, "GroupFlags")
	if err != nil {
		return err
	}
	*x = GroupFlags(value)
	return nil
}

func (GroupFlags) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{5}
}

// ParticipantType
type ParticipantType int32

const (
	ParticipantTypeMember  ParticipantType = 0
	ParticipantTypeAdmin   ParticipantType = 1
	ParticipantTypeCreator ParticipantType = 2
)

var ParticipantType_name = map[int32]string{
	0: "ParticipantTypeMember",
	1: "ParticipantTypeAdmin",
	2: "ParticipantTypeCreator",
}

var ParticipantType_value = map[string]int32{
	"ParticipantTypeMember":  0,
	"ParticipantTypeAdmin":   1,
	"ParticipantTypeCreator": 2,
}

func (x ParticipantType) Enum() *ParticipantType {
	p := new(ParticipantType)
	*p = x
	return p
}

func (x ParticipantType) String() string {
	return proto.EnumName(ParticipantType_name, int32(x))
}

func (x *ParticipantType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ParticipantType_value, data, "ParticipantType")
	if err != nil {
		return err
	}
	*x = ParticipantType(value)
	return nil
}

func (ParticipantType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{6}
}

// MessageEnvelope
// This type of message will be used to contain another ProtoBuffer Message inside
type MessageEnvelope struct {
	Constructor int64  `protobuf:"varint,1,req,name=Constructor" json:"Constructor"`
	RequestID   uint64 `protobuf:"fixed64,2,req,name=RequestID" json:"RequestID"`
	Message     []byte `protobuf:"bytes,4,req,name=Message" json:"Message"`
}

func (m *MessageEnvelope) Reset()         { *m = MessageEnvelope{} }
func (m *MessageEnvelope) String() string { return proto.CompactTextString(m) }
func (*MessageEnvelope) ProtoMessage()    {}
func (*MessageEnvelope) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{0}
}
func (m *MessageEnvelope) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageEnvelope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageEnvelope.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageEnvelope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageEnvelope.Merge(m, src)
}
func (m *MessageEnvelope) XXX_Size() int {
	return m.Size()
}
func (m *MessageEnvelope) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageEnvelope.DiscardUnknown(m)
}

var xxx_messageInfo_MessageEnvelope proto.InternalMessageInfo

func (m *MessageEnvelope) GetConstructor() int64 {
	if m != nil {
		return m.Constructor
	}
	return 0
}

func (m *MessageEnvelope) GetRequestID() uint64 {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *MessageEnvelope) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

// MessageContainer
// This type of message will be used to send multi messages inside a single container message
type MessageContainer struct {
	Length    int32              `protobuf:"varint,1,req,name=Length" json:"Length"`
	Envelopes []*MessageEnvelope `protobuf:"bytes,2,rep,name=Envelopes" json:"Envelopes,omitempty"`
}

func (m *MessageContainer) Reset()         { *m = MessageContainer{} }
func (m *MessageContainer) String() string { return proto.CompactTextString(m) }
func (*MessageContainer) ProtoMessage()    {}
func (*MessageContainer) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{1}
}
func (m *MessageContainer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageContainer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageContainer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageContainer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageContainer.Merge(m, src)
}
func (m *MessageContainer) XXX_Size() int {
	return m.Size()
}
func (m *MessageContainer) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageContainer.DiscardUnknown(m)
}

var xxx_messageInfo_MessageContainer proto.InternalMessageInfo

func (m *MessageContainer) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *MessageContainer) GetEnvelopes() []*MessageEnvelope {
	if m != nil {
		return m.Envelopes
	}
	return nil
}

// UpdateEnvelope
type UpdateEnvelope struct {
	Constructor int64  `protobuf:"varint,1,req,name=Constructor" json:"Constructor"`
	Update      []byte `protobuf:"bytes,2,req,name=Update" json:"Update"`
	UCount      int32  `protobuf:"varint,3,req,name=UCount" json:"UCount"`
	UpdateID    int64  `protobuf:"varint,4,req,name=UpdateID" json:"UpdateID"`
	Timestamp   int64  `protobuf:"varint,5,req,name=Timestamp" json:"Timestamp"`
}

func (m *UpdateEnvelope) Reset()         { *m = UpdateEnvelope{} }
func (m *UpdateEnvelope) String() string { return proto.CompactTextString(m) }
func (*UpdateEnvelope) ProtoMessage()    {}
func (*UpdateEnvelope) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{2}
}
func (m *UpdateEnvelope) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateEnvelope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateEnvelope.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateEnvelope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateEnvelope.Merge(m, src)
}
func (m *UpdateEnvelope) XXX_Size() int {
	return m.Size()
}
func (m *UpdateEnvelope) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateEnvelope.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateEnvelope proto.InternalMessageInfo

func (m *UpdateEnvelope) GetConstructor() int64 {
	if m != nil {
		return m.Constructor
	}
	return 0
}

func (m *UpdateEnvelope) GetUpdate() []byte {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *UpdateEnvelope) GetUCount() int32 {
	if m != nil {
		return m.UCount
	}
	return 0
}

func (m *UpdateEnvelope) GetUpdateID() int64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

func (m *UpdateEnvelope) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

// UpdateContainer
// It is very similar to MessageContainer but holding a list of Updates
type UpdateContainer struct {
	Length      int32             `protobuf:"varint,1,req,name=Length" json:"Length"`
	Updates     []*UpdateEnvelope `protobuf:"bytes,2,rep,name=Updates" json:"Updates,omitempty"`
	MinUpdateID int64             `protobuf:"varint,3,req,name=MinUpdateID" json:"MinUpdateID"`
	MaxUpdateID int64             `protobuf:"varint,4,req,name=MaxUpdateID" json:"MaxUpdateID"`
	Users       []*User           `protobuf:"bytes,5,rep,name=Users" json:"Users,omitempty"`
	Groups      []*Group          `protobuf:"bytes,6,rep,name=Groups" json:"Groups,omitempty"`
}

func (m *UpdateContainer) Reset()         { *m = UpdateContainer{} }
func (m *UpdateContainer) String() string { return proto.CompactTextString(m) }
func (*UpdateContainer) ProtoMessage()    {}
func (*UpdateContainer) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{3}
}
func (m *UpdateContainer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateContainer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateContainer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateContainer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateContainer.Merge(m, src)
}
func (m *UpdateContainer) XXX_Size() int {
	return m.Size()
}
func (m *UpdateContainer) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateContainer.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateContainer proto.InternalMessageInfo

func (m *UpdateContainer) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *UpdateContainer) GetUpdates() []*UpdateEnvelope {
	if m != nil {
		return m.Updates
	}
	return nil
}

func (m *UpdateContainer) GetMinUpdateID() int64 {
	if m != nil {
		return m.MinUpdateID
	}
	return 0
}

func (m *UpdateContainer) GetMaxUpdateID() int64 {
	if m != nil {
		return m.MaxUpdateID
	}
	return 0
}

func (m *UpdateContainer) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *UpdateContainer) GetGroups() []*Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

// ProtoMessage
// If AuthID == 0 then Payload is a MessageEnvelop otherwise Payload is a ProtoEncryptedPayload
type ProtoMessage struct {
	AuthID     int64  `protobuf:"varint,1,req,name=AuthID" json:"AuthID"`
	MessageKey []byte `protobuf:"bytes,2,req,name=MessageKey" json:"MessageKey"`
	Payload    []byte `protobuf:"bytes,3,req,name=Payload" json:"Payload"`
}

func (m *ProtoMessage) Reset()         { *m = ProtoMessage{} }
func (m *ProtoMessage) String() string { return proto.CompactTextString(m) }
func (*ProtoMessage) ProtoMessage()    {}
func (*ProtoMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{4}
}
func (m *ProtoMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtoMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtoMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtoMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtoMessage.Merge(m, src)
}
func (m *ProtoMessage) XXX_Size() int {
	return m.Size()
}
func (m *ProtoMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtoMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ProtoMessage proto.InternalMessageInfo

func (m *ProtoMessage) GetAuthID() int64 {
	if m != nil {
		return m.AuthID
	}
	return 0
}

func (m *ProtoMessage) GetMessageKey() []byte {
	if m != nil {
		return m.MessageKey
	}
	return nil
}

func (m *ProtoMessage) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

// ProtoMessageEncryptedPayload
type ProtoEncryptedPayload struct {
	ServerSalt int64            `protobuf:"varint,1,req,name=ServerSalt" json:"ServerSalt"`
	MessageID  uint64           `protobuf:"varint,2,req,name=MessageID" json:"MessageID"`
	SessionID  int64            `protobuf:"varint,3,req,name=SessionID" json:"SessionID"`
	Envelope   *MessageEnvelope `protobuf:"bytes,4,req,name=Envelope" json:"Envelope,omitempty"`
}

func (m *ProtoEncryptedPayload) Reset()         { *m = ProtoEncryptedPayload{} }
func (m *ProtoEncryptedPayload) String() string { return proto.CompactTextString(m) }
func (*ProtoEncryptedPayload) ProtoMessage()    {}
func (*ProtoEncryptedPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{5}
}
func (m *ProtoEncryptedPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtoEncryptedPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtoEncryptedPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtoEncryptedPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtoEncryptedPayload.Merge(m, src)
}
func (m *ProtoEncryptedPayload) XXX_Size() int {
	return m.Size()
}
func (m *ProtoEncryptedPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtoEncryptedPayload.DiscardUnknown(m)
}

var xxx_messageInfo_ProtoEncryptedPayload proto.InternalMessageInfo

func (m *ProtoEncryptedPayload) GetServerSalt() int64 {
	if m != nil {
		return m.ServerSalt
	}
	return 0
}

func (m *ProtoEncryptedPayload) GetMessageID() uint64 {
	if m != nil {
		return m.MessageID
	}
	return 0
}

func (m *ProtoEncryptedPayload) GetSessionID() int64 {
	if m != nil {
		return m.SessionID
	}
	return 0
}

func (m *ProtoEncryptedPayload) GetEnvelope() *MessageEnvelope {
	if m != nil {
		return m.Envelope
	}
	return nil
}

// Error
type Error struct {
	Code  string `protobuf:"bytes,1,req,name=Code" json:"Code"`
	Items string `protobuf:"bytes,2,req,name=Items" json:"Items"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{6}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(m, src)
}
func (m *Error) XXX_Size() int {
	return m.Size()
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

func (m *Error) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *Error) GetItems() string {
	if m != nil {
		return m.Items
	}
	return ""
}

// Ack
type Ack struct {
}

func (m *Ack) Reset()         { *m = Ack{} }
func (m *Ack) String() string { return proto.CompactTextString(m) }
func (*Ack) ProtoMessage()    {}
func (*Ack) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{7}
}
func (m *Ack) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ack) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ack.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ack) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ack.Merge(m, src)
}
func (m *Ack) XXX_Size() int {
	return m.Size()
}
func (m *Ack) XXX_DiscardUnknown() {
	xxx_messageInfo_Ack.DiscardUnknown(m)
}

var xxx_messageInfo_Ack proto.InternalMessageInfo

// Bool
type Bool struct {
	Result bool `protobuf:"varint,1,req,name=Result" json:"Result"`
}

func (m *Bool) Reset()         { *m = Bool{} }
func (m *Bool) String() string { return proto.CompactTextString(m) }
func (*Bool) ProtoMessage()    {}
func (*Bool) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{8}
}
func (m *Bool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Bool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Bool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Bool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Bool.Merge(m, src)
}
func (m *Bool) XXX_Size() int {
	return m.Size()
}
func (m *Bool) XXX_DiscardUnknown() {
	xxx_messageInfo_Bool.DiscardUnknown(m)
}

var xxx_messageInfo_Bool proto.InternalMessageInfo

func (m *Bool) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

// Dialog
type Dialog struct {
	PeerID          int64               `protobuf:"varint,1,req,name=PeerID" json:"PeerID"`
	PeerType        int32               `protobuf:"varint,2,req,name=PeerType" json:"PeerType"`
	TopMessageID    int64               `protobuf:"varint,3,req,name=TopMessageID" json:"TopMessageID"`
	ReadInboxMaxID  int64               `protobuf:"varint,4,req,name=ReadInboxMaxID" json:"ReadInboxMaxID"`
	ReadOutboxMaxID int64               `protobuf:"varint,5,req,name=ReadOutboxMaxID" json:"ReadOutboxMaxID"`
	UnreadCount     int32               `protobuf:"varint,6,req,name=UnreadCount" json:"UnreadCount"`
	AccessHash      uint64              `protobuf:"fixed64,7,req,name=AccessHash" json:"AccessHash"`
	NotifySettings  *PeerNotifySettings `protobuf:"bytes,8,opt,name=NotifySettings" json:"NotifySettings,omitempty"`
	MentionedCount  int32               `protobuf:"varint,9,opt,name=MentionedCount" json:"MentionedCount"`
}

func (m *Dialog) Reset()         { *m = Dialog{} }
func (m *Dialog) String() string { return proto.CompactTextString(m) }
func (*Dialog) ProtoMessage()    {}
func (*Dialog) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{9}
}
func (m *Dialog) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dialog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dialog.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Dialog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dialog.Merge(m, src)
}
func (m *Dialog) XXX_Size() int {
	return m.Size()
}
func (m *Dialog) XXX_DiscardUnknown() {
	xxx_messageInfo_Dialog.DiscardUnknown(m)
}

var xxx_messageInfo_Dialog proto.InternalMessageInfo

func (m *Dialog) GetPeerID() int64 {
	if m != nil {
		return m.PeerID
	}
	return 0
}

func (m *Dialog) GetPeerType() int32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *Dialog) GetTopMessageID() int64 {
	if m != nil {
		return m.TopMessageID
	}
	return 0
}

func (m *Dialog) GetReadInboxMaxID() int64 {
	if m != nil {
		return m.ReadInboxMaxID
	}
	return 0
}

func (m *Dialog) GetReadOutboxMaxID() int64 {
	if m != nil {
		return m.ReadOutboxMaxID
	}
	return 0
}

func (m *Dialog) GetUnreadCount() int32 {
	if m != nil {
		return m.UnreadCount
	}
	return 0
}

func (m *Dialog) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *Dialog) GetNotifySettings() *PeerNotifySettings {
	if m != nil {
		return m.NotifySettings
	}
	return nil
}

func (m *Dialog) GetMentionedCount() int32 {
	if m != nil {
		return m.MentionedCount
	}
	return 0
}

// Peer
type Peer struct {
	ID         int64  `protobuf:"varint,1,req,name=ID" json:"ID"`
	Type       int32  `protobuf:"varint,2,req,name=Type" json:"Type"`
	AccessHash uint64 `protobuf:"fixed64,3,req,name=AccessHash" json:"AccessHash"`
}

func (m *Peer) Reset()         { *m = Peer{} }
func (m *Peer) String() string { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()    {}
func (*Peer) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{10}
}
func (m *Peer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Peer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Peer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Peer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Peer.Merge(m, src)
}
func (m *Peer) XXX_Size() int {
	return m.Size()
}
func (m *Peer) XXX_DiscardUnknown() {
	xxx_messageInfo_Peer.DiscardUnknown(m)
}

var xxx_messageInfo_Peer proto.InternalMessageInfo

func (m *Peer) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Peer) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Peer) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// InputPeer
type InputPeer struct {
	ID         int64    `protobuf:"varint,1,req,name=ID" json:"ID"`
	Type       PeerType `protobuf:"varint,2,req,name=Type,enum=msg.PeerType" json:"Type"`
	AccessHash uint64   `protobuf:"fixed64,3,req,name=AccessHash" json:"AccessHash"`
}

func (m *InputPeer) Reset()         { *m = InputPeer{} }
func (m *InputPeer) String() string { return proto.CompactTextString(m) }
func (*InputPeer) ProtoMessage()    {}
func (*InputPeer) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{11}
}
func (m *InputPeer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputPeer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputPeer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputPeer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputPeer.Merge(m, src)
}
func (m *InputPeer) XXX_Size() int {
	return m.Size()
}
func (m *InputPeer) XXX_DiscardUnknown() {
	xxx_messageInfo_InputPeer.DiscardUnknown(m)
}

var xxx_messageInfo_InputPeer proto.InternalMessageInfo

func (m *InputPeer) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *InputPeer) GetType() PeerType {
	if m != nil {
		return m.Type
	}
	return PeerSelf
}

func (m *InputPeer) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// InputUser
type InputUser struct {
	UserID     int64  `protobuf:"varint,1,req,name=UserID" json:"UserID"`
	AccessHash uint64 `protobuf:"fixed64,2,req,name=AccessHash" json:"AccessHash"`
}

func (m *InputUser) Reset()         { *m = InputUser{} }
func (m *InputUser) String() string { return proto.CompactTextString(m) }
func (*InputUser) ProtoMessage()    {}
func (*InputUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{12}
}
func (m *InputUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputUser.Merge(m, src)
}
func (m *InputUser) XXX_Size() int {
	return m.Size()
}
func (m *InputUser) XXX_DiscardUnknown() {
	xxx_messageInfo_InputUser.DiscardUnknown(m)
}

var xxx_messageInfo_InputUser proto.InternalMessageInfo

func (m *InputUser) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *InputUser) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// InputFileLocation
type InputFileLocation struct {
	ClusterID  int32  `protobuf:"varint,1,req,name=ClusterID" json:"ClusterID"`
	FileID     int64  `protobuf:"varint,2,req,name=FileID" json:"FileID"`
	AccessHash uint64 `protobuf:"fixed64,3,req,name=AccessHash" json:"AccessHash"`
	Version    int32  `protobuf:"varint,4,opt,name=Version" json:"Version"`
}

func (m *InputFileLocation) Reset()         { *m = InputFileLocation{} }
func (m *InputFileLocation) String() string { return proto.CompactTextString(m) }
func (*InputFileLocation) ProtoMessage()    {}
func (*InputFileLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{13}
}
func (m *InputFileLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputFileLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputFileLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputFileLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputFileLocation.Merge(m, src)
}
func (m *InputFileLocation) XXX_Size() int {
	return m.Size()
}
func (m *InputFileLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_InputFileLocation.DiscardUnknown(m)
}

var xxx_messageInfo_InputFileLocation proto.InternalMessageInfo

func (m *InputFileLocation) GetClusterID() int32 {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

func (m *InputFileLocation) GetFileID() int64 {
	if m != nil {
		return m.FileID
	}
	return 0
}

func (m *InputFileLocation) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *InputFileLocation) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

// FileLocation
type FileLocation struct {
	ClusterID  int32  `protobuf:"varint,1,req,name=ClusterID" json:"ClusterID"`
	FileID     int64  `protobuf:"varint,2,req,name=FileID" json:"FileID"`
	AccessHash uint64 `protobuf:"fixed64,3,req,name=AccessHash" json:"AccessHash"`
}

func (m *FileLocation) Reset()         { *m = FileLocation{} }
func (m *FileLocation) String() string { return proto.CompactTextString(m) }
func (*FileLocation) ProtoMessage()    {}
func (*FileLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{14}
}
func (m *FileLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileLocation.Merge(m, src)
}
func (m *FileLocation) XXX_Size() int {
	return m.Size()
}
func (m *FileLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_FileLocation.DiscardUnknown(m)
}

var xxx_messageInfo_FileLocation proto.InternalMessageInfo

func (m *FileLocation) GetClusterID() int32 {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

func (m *FileLocation) GetFileID() int64 {
	if m != nil {
		return m.FileID
	}
	return 0
}

func (m *FileLocation) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// UserPhoto
type UserPhoto struct {
	PhotoBig   *FileLocation `protobuf:"bytes,1,req,name=PhotoBig" json:"PhotoBig,omitempty"`
	PhotoSmall *FileLocation `protobuf:"bytes,2,req,name=PhotoSmall" json:"PhotoSmall,omitempty"`
	PhotoID    int64         `protobuf:"varint,3,req,name=PhotoID" json:"PhotoID"`
}

func (m *UserPhoto) Reset()         { *m = UserPhoto{} }
func (m *UserPhoto) String() string { return proto.CompactTextString(m) }
func (*UserPhoto) ProtoMessage()    {}
func (*UserPhoto) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{15}
}
func (m *UserPhoto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserPhoto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserPhoto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserPhoto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserPhoto.Merge(m, src)
}
func (m *UserPhoto) XXX_Size() int {
	return m.Size()
}
func (m *UserPhoto) XXX_DiscardUnknown() {
	xxx_messageInfo_UserPhoto.DiscardUnknown(m)
}

var xxx_messageInfo_UserPhoto proto.InternalMessageInfo

func (m *UserPhoto) GetPhotoBig() *FileLocation {
	if m != nil {
		return m.PhotoBig
	}
	return nil
}

func (m *UserPhoto) GetPhotoSmall() *FileLocation {
	if m != nil {
		return m.PhotoSmall
	}
	return nil
}

func (m *UserPhoto) GetPhotoID() int64 {
	if m != nil {
		return m.PhotoID
	}
	return 0
}

// User
type User struct {
	ID         int64      `protobuf:"varint,1,req,name=ID" json:"ID"`
	FirstName  string     `protobuf:"bytes,2,req,name=FirstName" json:"FirstName"`
	LastName   string     `protobuf:"bytes,3,req,name=LastName" json:"LastName"`
	Username   string     `protobuf:"bytes,4,opt,name=Username" json:"Username"`
	Status     UserStatus `protobuf:"varint,5,req,name=Status,enum=msg.UserStatus" json:"Status"`
	Restricted bool       `protobuf:"varint,6,req,name=Restricted" json:"Restricted"`
	AccessHash uint64     `protobuf:"fixed64,7,req,name=AccessHash" json:"AccessHash"`
	Photo      *UserPhoto `protobuf:"bytes,8,opt,name=Photo" json:"Photo,omitempty"`
	Bio        string     `protobuf:"bytes,9,opt,name=Bio" json:"Bio"`
}

func (m *User) Reset()         { *m = User{} }
func (m *User) String() string { return proto.CompactTextString(m) }
func (*User) ProtoMessage()    {}
func (*User) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{16}
}
func (m *User) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *User) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_User.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *User) XXX_Merge(src proto.Message) {
	xxx_messageInfo_User.Merge(m, src)
}
func (m *User) XXX_Size() int {
	return m.Size()
}
func (m *User) XXX_DiscardUnknown() {
	xxx_messageInfo_User.DiscardUnknown(m)
}

var xxx_messageInfo_User proto.InternalMessageInfo

func (m *User) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *User) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *User) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *User) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *User) GetStatus() UserStatus {
	if m != nil {
		return m.Status
	}
	return UserStatusOffline
}

func (m *User) GetRestricted() bool {
	if m != nil {
		return m.Restricted
	}
	return false
}

func (m *User) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *User) GetPhoto() *UserPhoto {
	if m != nil {
		return m.Photo
	}
	return nil
}

func (m *User) GetBio() string {
	if m != nil {
		return m.Bio
	}
	return ""
}

// ContactUser
type ContactUser struct {
	ID         int64      `protobuf:"varint,1,req,name=ID" json:"ID"`
	FirstName  string     `protobuf:"bytes,2,req,name=FirstName" json:"FirstName"`
	LastName   string     `protobuf:"bytes,3,req,name=LastName" json:"LastName"`
	AccessHash uint64     `protobuf:"fixed64,4,req,name=AccessHash" json:"AccessHash"`
	Phone      string     `protobuf:"bytes,5,req,name=Phone" json:"Phone"`
	Username   string     `protobuf:"bytes,6,req,name=Username" json:"Username"`
	ClientID   int64      `protobuf:"varint,7,req,name=ClientID" json:"ClientID"`
	Photo      *UserPhoto `protobuf:"bytes,8,opt,name=Photo" json:"Photo,omitempty"`
}

func (m *ContactUser) Reset()         { *m = ContactUser{} }
func (m *ContactUser) String() string { return proto.CompactTextString(m) }
func (*ContactUser) ProtoMessage()    {}
func (*ContactUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{17}
}
func (m *ContactUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContactUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContactUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContactUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContactUser.Merge(m, src)
}
func (m *ContactUser) XXX_Size() int {
	return m.Size()
}
func (m *ContactUser) XXX_DiscardUnknown() {
	xxx_messageInfo_ContactUser.DiscardUnknown(m)
}

var xxx_messageInfo_ContactUser proto.InternalMessageInfo

func (m *ContactUser) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ContactUser) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *ContactUser) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *ContactUser) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *ContactUser) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *ContactUser) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *ContactUser) GetClientID() int64 {
	if m != nil {
		return m.ClientID
	}
	return 0
}

func (m *ContactUser) GetPhoto() *UserPhoto {
	if m != nil {
		return m.Photo
	}
	return nil
}

// UserMessage
type UserMessage struct {
	ID                  int64            `protobuf:"varint,1,req,name=ID" json:"ID"`
	PeerID              int64            `protobuf:"varint,2,req,name=PeerID" json:"PeerID"`
	PeerType            int32            `protobuf:"varint,3,req,name=PeerType" json:"PeerType"`
	CreatedOn           int64            `protobuf:"varint,4,req,name=CreatedOn" json:"CreatedOn"`
	EditedOn            int64            `protobuf:"varint,5,req,name=EditedOn" json:"EditedOn"`
	FwdSenderID         int64            `protobuf:"varint,6,req,name=FwdSenderID" json:"FwdSenderID"`
	FwdChannelID        int64            `protobuf:"varint,7,req,name=FwdChannelID" json:"FwdChannelID"`
	FwdChannelMessageID int64            `protobuf:"varint,8,req,name=FwdChannelMessageID" json:"FwdChannelMessageID"`
	Flags               int32            `protobuf:"varint,9,req,name=Flags" json:"Flags"`
	MessageType         int64            `protobuf:"varint,10,req,name=MessageType" json:"MessageType"`
	Body                string           `protobuf:"bytes,11,req,name=Body" json:"Body"`
	SenderID            int64            `protobuf:"varint,12,req,name=SenderID" json:"SenderID"`
	ContentRead         bool             `protobuf:"varint,13,req,name=ContentRead" json:"ContentRead"`
	Inbox               bool             `protobuf:"varint,14,req,name=Inbox" json:"Inbox"`
	ReplyTo             int64            `protobuf:"varint,15,req,name=ReplyTo" json:"ReplyTo"`
	MessageAction       int32            `protobuf:"varint,16,opt,name=MessageAction" json:"MessageAction"`
	MessageActionData   []byte           `protobuf:"bytes,17,opt,name=MessageActionData" json:"MessageActionData"`
	Entities            []*MessageEntity `protobuf:"bytes,18,rep,name=Entities" json:"Entities,omitempty"`
	MediaType           MediaType        `protobuf:"varint,19,opt,name=MediaType,enum=msg.MediaType" json:"MediaType"`
	Media               []byte           `protobuf:"bytes,20,opt,name=Media" json:"Media"`
}

func (m *UserMessage) Reset()         { *m = UserMessage{} }
func (m *UserMessage) String() string { return proto.CompactTextString(m) }
func (*UserMessage) ProtoMessage()    {}
func (*UserMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{18}
}
func (m *UserMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserMessage.Merge(m, src)
}
func (m *UserMessage) XXX_Size() int {
	return m.Size()
}
func (m *UserMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_UserMessage.DiscardUnknown(m)
}

var xxx_messageInfo_UserMessage proto.InternalMessageInfo

func (m *UserMessage) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UserMessage) GetPeerID() int64 {
	if m != nil {
		return m.PeerID
	}
	return 0
}

func (m *UserMessage) GetPeerType() int32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *UserMessage) GetCreatedOn() int64 {
	if m != nil {
		return m.CreatedOn
	}
	return 0
}

func (m *UserMessage) GetEditedOn() int64 {
	if m != nil {
		return m.EditedOn
	}
	return 0
}

func (m *UserMessage) GetFwdSenderID() int64 {
	if m != nil {
		return m.FwdSenderID
	}
	return 0
}

func (m *UserMessage) GetFwdChannelID() int64 {
	if m != nil {
		return m.FwdChannelID
	}
	return 0
}

func (m *UserMessage) GetFwdChannelMessageID() int64 {
	if m != nil {
		return m.FwdChannelMessageID
	}
	return 0
}

func (m *UserMessage) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *UserMessage) GetMessageType() int64 {
	if m != nil {
		return m.MessageType
	}
	return 0
}

func (m *UserMessage) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

func (m *UserMessage) GetSenderID() int64 {
	if m != nil {
		return m.SenderID
	}
	return 0
}

func (m *UserMessage) GetContentRead() bool {
	if m != nil {
		return m.ContentRead
	}
	return false
}

func (m *UserMessage) GetInbox() bool {
	if m != nil {
		return m.Inbox
	}
	return false
}

func (m *UserMessage) GetReplyTo() int64 {
	if m != nil {
		return m.ReplyTo
	}
	return 0
}

func (m *UserMessage) GetMessageAction() int32 {
	if m != nil {
		return m.MessageAction
	}
	return 0
}

func (m *UserMessage) GetMessageActionData() []byte {
	if m != nil {
		return m.MessageActionData
	}
	return nil
}

func (m *UserMessage) GetEntities() []*MessageEntity {
	if m != nil {
		return m.Entities
	}
	return nil
}

func (m *UserMessage) GetMediaType() MediaType {
	if m != nil {
		return m.MediaType
	}
	return MediaTypeEmpty
}

func (m *UserMessage) GetMedia() []byte {
	if m != nil {
		return m.Media
	}
	return nil
}

// MessageEntity
type MessageEntity struct {
	Type   MessageEntityType `protobuf:"varint,1,req,name=Type,enum=msg.MessageEntityType" json:"Type"`
	Offset int32             `protobuf:"varint,2,req,name=Offset" json:"Offset"`
	Length int32             `protobuf:"varint,3,req,name=Length" json:"Length"`
	UserID int64             `protobuf:"varint,4,opt,name=UserID" json:"UserID"`
}

func (m *MessageEntity) Reset()         { *m = MessageEntity{} }
func (m *MessageEntity) String() string { return proto.CompactTextString(m) }
func (*MessageEntity) ProtoMessage()    {}
func (*MessageEntity) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{19}
}
func (m *MessageEntity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageEntity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageEntity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageEntity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageEntity.Merge(m, src)
}
func (m *MessageEntity) XXX_Size() int {
	return m.Size()
}
func (m *MessageEntity) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageEntity.DiscardUnknown(m)
}

var xxx_messageInfo_MessageEntity proto.InternalMessageInfo

func (m *MessageEntity) GetType() MessageEntityType {
	if m != nil {
		return m.Type
	}
	return MessageEntityTypeBold
}

func (m *MessageEntity) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *MessageEntity) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *MessageEntity) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

// RSAPublicKey
type RSAPublicKey struct {
	FingerPrint int64  `protobuf:"varint,1,req,name=FingerPrint" json:"FingerPrint"`
	N           string `protobuf:"bytes,2,req,name=N" json:"N"`
	E           uint32 `protobuf:"varint,3,req,name=E" json:"E"`
}

func (m *RSAPublicKey) Reset()         { *m = RSAPublicKey{} }
func (m *RSAPublicKey) String() string { return proto.CompactTextString(m) }
func (*RSAPublicKey) ProtoMessage()    {}
func (*RSAPublicKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{20}
}
func (m *RSAPublicKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RSAPublicKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RSAPublicKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RSAPublicKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RSAPublicKey.Merge(m, src)
}
func (m *RSAPublicKey) XXX_Size() int {
	return m.Size()
}
func (m *RSAPublicKey) XXX_DiscardUnknown() {
	xxx_messageInfo_RSAPublicKey.DiscardUnknown(m)
}

var xxx_messageInfo_RSAPublicKey proto.InternalMessageInfo

func (m *RSAPublicKey) GetFingerPrint() int64 {
	if m != nil {
		return m.FingerPrint
	}
	return 0
}

func (m *RSAPublicKey) GetN() string {
	if m != nil {
		return m.N
	}
	return ""
}

func (m *RSAPublicKey) GetE() uint32 {
	if m != nil {
		return m.E
	}
	return 0
}

// DHGroup
type DHGroup struct {
	FingerPrint int64  `protobuf:"varint,1,req,name=FingerPrint" json:"FingerPrint"`
	Prime       string `protobuf:"bytes,2,req,name=Prime" json:"Prime"`
	Gen         int32  `protobuf:"varint,3,req,name=Gen" json:"Gen"`
}

func (m *DHGroup) Reset()         { *m = DHGroup{} }
func (m *DHGroup) String() string { return proto.CompactTextString(m) }
func (*DHGroup) ProtoMessage()    {}
func (*DHGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{21}
}
func (m *DHGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DHGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DHGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHGroup.Merge(m, src)
}
func (m *DHGroup) XXX_Size() int {
	return m.Size()
}
func (m *DHGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_DHGroup.DiscardUnknown(m)
}

var xxx_messageInfo_DHGroup proto.InternalMessageInfo

func (m *DHGroup) GetFingerPrint() int64 {
	if m != nil {
		return m.FingerPrint
	}
	return 0
}

func (m *DHGroup) GetPrime() string {
	if m != nil {
		return m.Prime
	}
	return ""
}

func (m *DHGroup) GetGen() int32 {
	if m != nil {
		return m.Gen
	}
	return 0
}

// PhoneContact
type PhoneContact struct {
	ClientID  int64  `protobuf:"varint,1,req,name=ClientID" json:"ClientID"`
	FirstName string `protobuf:"bytes,2,req,name=FirstName" json:"FirstName"`
	LastName  string `protobuf:"bytes,3,req,name=LastName" json:"LastName"`
	Phone     string `protobuf:"bytes,4,req,name=Phone" json:"Phone"`
}

func (m *PhoneContact) Reset()         { *m = PhoneContact{} }
func (m *PhoneContact) String() string { return proto.CompactTextString(m) }
func (*PhoneContact) ProtoMessage()    {}
func (*PhoneContact) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{22}
}
func (m *PhoneContact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhoneContact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhoneContact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhoneContact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhoneContact.Merge(m, src)
}
func (m *PhoneContact) XXX_Size() int {
	return m.Size()
}
func (m *PhoneContact) XXX_DiscardUnknown() {
	xxx_messageInfo_PhoneContact.DiscardUnknown(m)
}

var xxx_messageInfo_PhoneContact proto.InternalMessageInfo

func (m *PhoneContact) GetClientID() int64 {
	if m != nil {
		return m.ClientID
	}
	return 0
}

func (m *PhoneContact) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *PhoneContact) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *PhoneContact) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

// PeerNotifySettings
type PeerNotifySettings struct {
	Flags     int32  `protobuf:"varint,1,req,name=Flags" json:"Flags"`
	MuteUntil int64  `protobuf:"varint,2,opt,name=MuteUntil" json:"MuteUntil"`
	Sound     string `protobuf:"bytes,3,opt,name=Sound" json:"Sound"`
}

func (m *PeerNotifySettings) Reset()         { *m = PeerNotifySettings{} }
func (m *PeerNotifySettings) String() string { return proto.CompactTextString(m) }
func (*PeerNotifySettings) ProtoMessage()    {}
func (*PeerNotifySettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{23}
}
func (m *PeerNotifySettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerNotifySettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerNotifySettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerNotifySettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerNotifySettings.Merge(m, src)
}
func (m *PeerNotifySettings) XXX_Size() int {
	return m.Size()
}
func (m *PeerNotifySettings) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerNotifySettings.DiscardUnknown(m)
}

var xxx_messageInfo_PeerNotifySettings proto.InternalMessageInfo

func (m *PeerNotifySettings) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *PeerNotifySettings) GetMuteUntil() int64 {
	if m != nil {
		return m.MuteUntil
	}
	return 0
}

func (m *PeerNotifySettings) GetSound() string {
	if m != nil {
		return m.Sound
	}
	return ""
}

// InputFile
type InputFile struct {
	FileID      int64  `protobuf:"varint,1,req,name=FileID" json:"FileID"`
	TotalParts  int32  `protobuf:"varint,2,req,name=TotalParts" json:"TotalParts"`
	FileName    string `protobuf:"bytes,3,req,name=FileName" json:"FileName"`
	MD5Checksum string `protobuf:"bytes,4,req,name=MD5Checksum" json:"MD5Checksum"`
}

func (m *InputFile) Reset()         { *m = InputFile{} }
func (m *InputFile) String() string { return proto.CompactTextString(m) }
func (*InputFile) ProtoMessage()    {}
func (*InputFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{24}
}
func (m *InputFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputFile.Merge(m, src)
}
func (m *InputFile) XXX_Size() int {
	return m.Size()
}
func (m *InputFile) XXX_DiscardUnknown() {
	xxx_messageInfo_InputFile.DiscardUnknown(m)
}

var xxx_messageInfo_InputFile proto.InternalMessageInfo

func (m *InputFile) GetFileID() int64 {
	if m != nil {
		return m.FileID
	}
	return 0
}

func (m *InputFile) GetTotalParts() int32 {
	if m != nil {
		return m.TotalParts
	}
	return 0
}

func (m *InputFile) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *InputFile) GetMD5Checksum() string {
	if m != nil {
		return m.MD5Checksum
	}
	return ""
}

// GroupPhoto
type GroupPhoto struct {
	PhotoBig   *FileLocation `protobuf:"bytes,1,req,name=PhotoBig" json:"PhotoBig,omitempty"`
	PhotoSmall *FileLocation `protobuf:"bytes,2,req,name=PhotoSmall" json:"PhotoSmall,omitempty"`
}

func (m *GroupPhoto) Reset()         { *m = GroupPhoto{} }
func (m *GroupPhoto) String() string { return proto.CompactTextString(m) }
func (*GroupPhoto) ProtoMessage()    {}
func (*GroupPhoto) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{25}
}
func (m *GroupPhoto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupPhoto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupPhoto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupPhoto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupPhoto.Merge(m, src)
}
func (m *GroupPhoto) XXX_Size() int {
	return m.Size()
}
func (m *GroupPhoto) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupPhoto.DiscardUnknown(m)
}

var xxx_messageInfo_GroupPhoto proto.InternalMessageInfo

func (m *GroupPhoto) GetPhotoBig() *FileLocation {
	if m != nil {
		return m.PhotoBig
	}
	return nil
}

func (m *GroupPhoto) GetPhotoSmall() *FileLocation {
	if m != nil {
		return m.PhotoSmall
	}
	return nil
}

// Group
type Group struct {
	ID           int64        `protobuf:"varint,1,req,name=ID" json:"ID"`
	Title        string       `protobuf:"bytes,2,req,name=Title" json:"Title"`
	CreatedOn    int64        `protobuf:"varint,3,req,name=CreatedOn" json:"CreatedOn"`
	Participants int32        `protobuf:"varint,4,req,name=Participants" json:"Participants"`
	EditedOn     int64        `protobuf:"varint,5,opt,name=EditedOn" json:"EditedOn"`
	Flags        []GroupFlags `protobuf:"varint,6,rep,name=Flags,enum=msg.GroupFlags" json:"Flags,omitempty"`
	Photo        *GroupPhoto  `protobuf:"bytes,7,opt,name=Photo" json:"Photo,omitempty"`
}

func (m *Group) Reset()         { *m = Group{} }
func (m *Group) String() string { return proto.CompactTextString(m) }
func (*Group) ProtoMessage()    {}
func (*Group) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{26}
}
func (m *Group) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Group) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Group.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Group) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Group.Merge(m, src)
}
func (m *Group) XXX_Size() int {
	return m.Size()
}
func (m *Group) XXX_DiscardUnknown() {
	xxx_messageInfo_Group.DiscardUnknown(m)
}

var xxx_messageInfo_Group proto.InternalMessageInfo

func (m *Group) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Group) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Group) GetCreatedOn() int64 {
	if m != nil {
		return m.CreatedOn
	}
	return 0
}

func (m *Group) GetParticipants() int32 {
	if m != nil {
		return m.Participants
	}
	return 0
}

func (m *Group) GetEditedOn() int64 {
	if m != nil {
		return m.EditedOn
	}
	return 0
}

func (m *Group) GetFlags() []GroupFlags {
	if m != nil {
		return m.Flags
	}
	return nil
}

func (m *Group) GetPhoto() *GroupPhoto {
	if m != nil {
		return m.Photo
	}
	return nil
}

// GroupFull
type GroupFull struct {
	Group          *Group              `protobuf:"bytes,1,req,name=Group" json:"Group,omitempty"`
	Users          []*User             `protobuf:"bytes,2,rep,name=Users" json:"Users,omitempty"`
	Participants   []*GroupParticipant `protobuf:"bytes,3,rep,name=Participants" json:"Participants,omitempty"`
	NotifySettings *PeerNotifySettings `protobuf:"bytes,4,req,name=NotifySettings" json:"NotifySettings,omitempty"`
}

func (m *GroupFull) Reset()         { *m = GroupFull{} }
func (m *GroupFull) String() string { return proto.CompactTextString(m) }
func (*GroupFull) ProtoMessage()    {}
func (*GroupFull) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{27}
}
func (m *GroupFull) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupFull) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupFull.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupFull) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupFull.Merge(m, src)
}
func (m *GroupFull) XXX_Size() int {
	return m.Size()
}
func (m *GroupFull) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupFull.DiscardUnknown(m)
}

var xxx_messageInfo_GroupFull proto.InternalMessageInfo

func (m *GroupFull) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *GroupFull) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *GroupFull) GetParticipants() []*GroupParticipant {
	if m != nil {
		return m.Participants
	}
	return nil
}

func (m *GroupFull) GetNotifySettings() *PeerNotifySettings {
	if m != nil {
		return m.NotifySettings
	}
	return nil
}

// GroupParticipant
type GroupParticipant struct {
	UserID     int64           `protobuf:"varint,1,req,name=UserID" json:"UserID"`
	FirstName  string          `protobuf:"bytes,2,req,name=FirstName" json:"FirstName"`
	LastName   string          `protobuf:"bytes,3,req,name=LastName" json:"LastName"`
	Type       ParticipantType `protobuf:"varint,4,req,name=Type,enum=msg.ParticipantType" json:"Type"`
	AccessHash uint64          `protobuf:"varint,5,req,name=AccessHash" json:"AccessHash"`
	Username   string          `protobuf:"bytes,6,req,name=Username" json:"Username"`
	Photo      *UserPhoto      `protobuf:"bytes,8,opt,name=Photo" json:"Photo,omitempty"`
}

func (m *GroupParticipant) Reset()         { *m = GroupParticipant{} }
func (m *GroupParticipant) String() string { return proto.CompactTextString(m) }
func (*GroupParticipant) ProtoMessage()    {}
func (*GroupParticipant) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{28}
}
func (m *GroupParticipant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupParticipant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupParticipant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupParticipant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupParticipant.Merge(m, src)
}
func (m *GroupParticipant) XXX_Size() int {
	return m.Size()
}
func (m *GroupParticipant) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupParticipant.DiscardUnknown(m)
}

var xxx_messageInfo_GroupParticipant proto.InternalMessageInfo

func (m *GroupParticipant) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *GroupParticipant) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *GroupParticipant) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *GroupParticipant) GetType() ParticipantType {
	if m != nil {
		return m.Type
	}
	return ParticipantTypeMember
}

func (m *GroupParticipant) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *GroupParticipant) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *GroupParticipant) GetPhoto() *UserPhoto {
	if m != nil {
		return m.Photo
	}
	return nil
}

// InputDocument
type InputDocument struct {
	ID         int64  `protobuf:"varint,1,req,name=ID" json:"ID"`
	AccessHash uint64 `protobuf:"fixed64,2,req,name=AccessHash" json:"AccessHash"`
	ClusterID  int32  `protobuf:"varint,3,req,name=ClusterID" json:"ClusterID"`
}

func (m *InputDocument) Reset()         { *m = InputDocument{} }
func (m *InputDocument) String() string { return proto.CompactTextString(m) }
func (*InputDocument) ProtoMessage()    {}
func (*InputDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{29}
}
func (m *InputDocument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputDocument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputDocument.Merge(m, src)
}
func (m *InputDocument) XXX_Size() int {
	return m.Size()
}
func (m *InputDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_InputDocument.DiscardUnknown(m)
}

var xxx_messageInfo_InputDocument proto.InternalMessageInfo

func (m *InputDocument) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *InputDocument) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *InputDocument) GetClusterID() int32 {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

// ActiveSession
type ActiveSession struct {
	AuthID        string `protobuf:"bytes,100,req,name=AuthID" json:"AuthID"`
	Model         string `protobuf:"bytes,1,req,name=Model" json:"Model"`
	AppVersion    string `protobuf:"bytes,2,req,name=AppVersion" json:"AppVersion"`
	SystemVersion string `protobuf:"bytes,3,req,name=SystemVersion" json:"SystemVersion"`
	LangCode      string `protobuf:"bytes,4,req,name=LangCode" json:"LangCode"`
	CreatedAt     int64  `protobuf:"varint,5,req,name=CreatedAt" json:"CreatedAt"`
	ActiveAt      int64  `protobuf:"varint,6,req,name=ActiveAt" json:"ActiveAt"`
	ClientIP      string `protobuf:"bytes,7,req,name=ClientIP" json:"ClientIP"`
}

func (m *ActiveSession) Reset()         { *m = ActiveSession{} }
func (m *ActiveSession) String() string { return proto.CompactTextString(m) }
func (*ActiveSession) ProtoMessage()    {}
func (*ActiveSession) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa76a373a8c28436, []int{30}
}
func (m *ActiveSession) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActiveSession) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActiveSession.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActiveSession) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActiveSession.Merge(m, src)
}
func (m *ActiveSession) XXX_Size() int {
	return m.Size()
}
func (m *ActiveSession) XXX_DiscardUnknown() {
	xxx_messageInfo_ActiveSession.DiscardUnknown(m)
}

var xxx_messageInfo_ActiveSession proto.InternalMessageInfo

func (m *ActiveSession) GetAuthID() string {
	if m != nil {
		return m.AuthID
	}
	return ""
}

func (m *ActiveSession) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *ActiveSession) GetAppVersion() string {
	if m != nil {
		return m.AppVersion
	}
	return ""
}

func (m *ActiveSession) GetSystemVersion() string {
	if m != nil {
		return m.SystemVersion
	}
	return ""
}

func (m *ActiveSession) GetLangCode() string {
	if m != nil {
		return m.LangCode
	}
	return ""
}

func (m *ActiveSession) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *ActiveSession) GetActiveAt() int64 {
	if m != nil {
		return m.ActiveAt
	}
	return 0
}

func (m *ActiveSession) GetClientIP() string {
	if m != nil {
		return m.ClientIP
	}
	return ""
}

func init() {
	proto.RegisterEnum("msg.TypingAction", TypingAction_name, TypingAction_value)
	proto.RegisterEnum("msg.PeerType", PeerType_name, PeerType_value)
	proto.RegisterEnum("msg.UserStatus", UserStatus_name, UserStatus_value)
	proto.RegisterEnum("msg.MediaType", MediaType_name, MediaType_value)
	proto.RegisterEnum("msg.MessageEntityType", MessageEntityType_name, MessageEntityType_value)
	proto.RegisterEnum("msg.GroupFlags", GroupFlags_name, GroupFlags_value)
	proto.RegisterEnum("msg.ParticipantType", ParticipantType_name, ParticipantType_value)
	proto.RegisterType((*MessageEnvelope)(nil), "msg.MessageEnvelope")
	proto.RegisterType((*MessageContainer)(nil), "msg.MessageContainer")
	proto.RegisterType((*UpdateEnvelope)(nil), "msg.UpdateEnvelope")
	proto.RegisterType((*UpdateContainer)(nil), "msg.UpdateContainer")
	proto.RegisterType((*ProtoMessage)(nil), "msg.ProtoMessage")
	proto.RegisterType((*ProtoEncryptedPayload)(nil), "msg.ProtoEncryptedPayload")
	proto.RegisterType((*Error)(nil), "msg.Error")
	proto.RegisterType((*Ack)(nil), "msg.Ack")
	proto.RegisterType((*Bool)(nil), "msg.Bool")
	proto.RegisterType((*Dialog)(nil), "msg.Dialog")
	proto.RegisterType((*Peer)(nil), "msg.Peer")
	proto.RegisterType((*InputPeer)(nil), "msg.InputPeer")
	proto.RegisterType((*InputUser)(nil), "msg.InputUser")
	proto.RegisterType((*InputFileLocation)(nil), "msg.InputFileLocation")
	proto.RegisterType((*FileLocation)(nil), "msg.FileLocation")
	proto.RegisterType((*UserPhoto)(nil), "msg.UserPhoto")
	proto.RegisterType((*User)(nil), "msg.User")
	proto.RegisterType((*ContactUser)(nil), "msg.ContactUser")
	proto.RegisterType((*UserMessage)(nil), "msg.UserMessage")
	proto.RegisterType((*MessageEntity)(nil), "msg.MessageEntity")
	proto.RegisterType((*RSAPublicKey)(nil), "msg.RSAPublicKey")
	proto.RegisterType((*DHGroup)(nil), "msg.DHGroup")
	proto.RegisterType((*PhoneContact)(nil), "msg.PhoneContact")
	proto.RegisterType((*PeerNotifySettings)(nil), "msg.PeerNotifySettings")
	proto.RegisterType((*InputFile)(nil), "msg.InputFile")
	proto.RegisterType((*GroupPhoto)(nil), "msg.GroupPhoto")
	proto.RegisterType((*Group)(nil), "msg.Group")
	proto.RegisterType((*GroupFull)(nil), "msg.GroupFull")
	proto.RegisterType((*GroupParticipant)(nil), "msg.GroupParticipant")
	proto.RegisterType((*InputDocument)(nil), "msg.InputDocument")
	proto.RegisterType((*ActiveSession)(nil), "msg.ActiveSession")
}

func init() { proto.RegisterFile("chat.core.types.proto", fileDescriptor_fa76a373a8c28436) }

var fileDescriptor_fa76a373a8c28436 = []byte{
	// 2213 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0xcd, 0x6f, 0x1c, 0x49,
	0x15, 0x9f, 0xee, 0x9e, 0x19, 0x7b, 0x9e, 0xc7, 0x76, 0xbb, 0x12, 0x27, 0x8d, 0x89, 0xbc, 0x56,
	0x2b, 0x1b, 0x2c, 0x8b, 0x78, 0x83, 0x25, 0x24, 0x38, 0x20, 0xe4, 0xcf, 0xac, 0x45, 0xec, 0x58,
	0x33, 0xf6, 0x22, 0x71, 0x40, 0xb4, 0xbb, 0xcb, 0xe3, 0x56, 0x7a, 0xaa, 0x86, 0xee, 0x9a, 0x6c,
	0x66, 0x25, 0x0e, 0x70, 0x47, 0x02, 0x89, 0x03, 0x68, 0x85, 0x38, 0x20, 0xfe, 0x06, 0x24, 0x24,
	0x0e, 0xdc, 0x56, 0x9c, 0x72, 0xe4, 0x84, 0x20, 0xf9, 0x13, 0x38, 0x71, 0x43, 0xaf, 0xaa, 0xba,
	0xbb, 0xba, 0x67, 0x4c, 0x0c, 0x5a, 0xed, 0x9e, 0x66, 0xea, 0xf7, 0x5e, 0xd7, 0xfb, 0xaa, 0xf7,
	0x51, 0x05, 0xab, 0xe1, 0x75, 0x20, 0xb6, 0x43, 0x9e, 0xd2, 0x6d, 0x31, 0x19, 0xd1, 0x6c, 0x7b,
	0x94, 0x72, 0xc1, 0x89, 0x33, 0xcc, 0x06, 0x6b, 0x8f, 0x07, 0xb1, 0xb8, 0x1e, 0x5f, 0x6e, 0x87,
	0x7c, 0xf8, 0xc1, 0x80, 0x0f, 0xf8, 0x07, 0x92, 0x76, 0x39, 0xbe, 0x92, 0x2b, 0xb9, 0x90, 0xff,
	0xd4, 0x37, 0xfe, 0x4f, 0x60, 0xf9, 0x84, 0x66, 0x59, 0x30, 0xa0, 0x87, 0xec, 0x25, 0x4d, 0xf8,
	0x88, 0x92, 0x47, 0xb0, 0xb0, 0xcf, 0x59, 0x26, 0xd2, 0x71, 0x28, 0x78, 0xea, 0x59, 0x1b, 0xf6,
	0xa6, 0xb3, 0xd7, 0xfc, 0xec, 0xef, 0xef, 0x35, 0x7a, 0x26, 0x81, 0xf8, 0xd0, 0xe9, 0xd1, 0x1f,
	0x8f, 0x69, 0x26, 0x8e, 0x0f, 0x3c, 0x7b, 0xc3, 0xde, 0x6c, 0x6b, 0xae, 0x12, 0x26, 0xeb, 0x30,
	0xa7, 0xb7, 0xf7, 0x9a, 0x1b, 0xf6, 0x66, 0x57, 0x73, 0xe4, 0xa0, 0x1f, 0x81, 0xab, 0xff, 0xee,
	0x73, 0x26, 0x82, 0x98, 0xd1, 0x94, 0x3c, 0x80, 0xf6, 0x33, 0xca, 0x06, 0xe2, 0x5a, 0x8a, 0x6e,
	0xe9, 0x4f, 0x34, 0x46, 0x76, 0xa0, 0x93, 0x6b, 0x9a, 0x79, 0xf6, 0x86, 0xb3, 0xb9, 0xb0, 0x73,
	0x77, 0x7b, 0x98, 0x0d, 0xb6, 0x6b, 0x66, 0xf4, 0x4a, 0x36, 0xff, 0x4f, 0x16, 0x2c, 0x5d, 0x8c,
	0xa2, 0x40, 0xfc, 0xef, 0x46, 0x3e, 0x80, 0xb6, 0xfa, 0x52, 0x5a, 0x98, 0xeb, 0xaf, 0x31, 0x49,
	0xdd, 0xe7, 0x63, 0x26, 0x3c, 0xc7, 0x54, 0x55, 0x61, 0x64, 0x03, 0xe6, 0x15, 0xdf, 0xf1, 0x81,
	0xb4, 0x3e, 0x17, 0x50, 0xa0, 0xe8, 0xc2, 0xf3, 0x78, 0x48, 0x33, 0x11, 0x0c, 0x47, 0x5e, 0xcb,
	0x60, 0x29, 0x61, 0xff, 0x5f, 0x16, 0x2c, 0xab, 0x0f, 0x6e, 0xeb, 0xa2, 0xc7, 0x30, 0xa7, 0x3e,
	0xc8, 0x1d, 0x74, 0x47, 0x3a, 0xa8, 0xea, 0x81, 0x5e, 0xce, 0x83, 0xae, 0x38, 0x89, 0x59, 0xa1,
	0xa9, 0x63, 0xba, 0xc2, 0x20, 0x48, 0xbe, 0xe0, 0xd5, 0x4c, 0x8b, 0x4c, 0x02, 0x79, 0x0f, 0x5a,
	0x17, 0x19, 0x4d, 0x33, 0xaf, 0x25, 0x85, 0x77, 0x94, 0xf0, 0x8c, 0xa6, 0x3d, 0x85, 0x13, 0x1f,
	0xda, 0x4f, 0x53, 0x3e, 0x1e, 0x65, 0x5e, 0x5b, 0x72, 0x80, 0xe4, 0x90, 0x50, 0x4f, 0x53, 0xfc,
	0x14, 0xba, 0x67, 0x78, 0x40, 0x75, 0x54, 0xd1, 0xe2, 0xdd, 0xb1, 0xb8, 0x3e, 0x3e, 0xa8, 0x84,
	0x4a, 0x63, 0xe4, 0x21, 0x80, 0x66, 0xfc, 0x1e, 0x9d, 0x54, 0x22, 0x65, 0xe0, 0x78, 0x18, 0xcf,
	0x82, 0x49, 0xc2, 0x83, 0x48, 0x1a, 0x59, 0x1c, 0x46, 0x0d, 0xfa, 0x7f, 0xb4, 0x60, 0x55, 0x0a,
	0x3d, 0x64, 0x61, 0x3a, 0x19, 0x09, 0x1a, 0x69, 0x0a, 0xee, 0xdf, 0xa7, 0xe9, 0x4b, 0x9a, 0xf6,
	0x83, 0x44, 0x54, 0x34, 0x30, 0x70, 0x8c, 0xa6, 0x96, 0xa6, 0x13, 0xa2, 0x99, 0x47, 0xb3, 0x80,
	0x91, 0xa7, 0x4f, 0xb3, 0x2c, 0xe6, 0xac, 0xe6, 0xea, 0x12, 0x26, 0x4f, 0x60, 0x3e, 0x8f, 0x92,
	0xf4, 0xf2, 0x4d, 0x27, 0xbc, 0xe0, 0xf2, 0xbf, 0x03, 0xad, 0xc3, 0x34, 0xe5, 0x29, 0xf1, 0xa0,
	0xb9, 0xcf, 0x23, 0x2a, 0x55, 0xec, 0xe8, 0x9d, 0x25, 0x42, 0xd6, 0xa0, 0x75, 0x2c, 0xe8, 0x30,
	0x93, 0x8a, 0xe5, 0x24, 0x05, 0xf9, 0x2d, 0x70, 0x76, 0xc3, 0x17, 0xfe, 0x43, 0x68, 0xee, 0x71,
	0x9e, 0xa0, 0xaf, 0x7b, 0x34, 0x1b, 0x6b, 0x4b, 0xe7, 0x73, 0x5f, 0x2b, 0xcc, 0xff, 0xa5, 0x03,
	0xed, 0x83, 0x38, 0x48, 0xf8, 0x80, 0xac, 0x43, 0xfb, 0x8c, 0xd2, 0xb4, 0x08, 0x4a, 0x1b, 0x19,
	0x9f, 0x58, 0x3d, 0x8d, 0x62, 0x02, 0xe0, 0xbf, 0xf3, 0xc9, 0x48, 0xa5, 0x4f, 0x7e, 0x50, 0x0b,
	0x94, 0x6c, 0x42, 0xf7, 0x9c, 0x8f, 0x4a, 0xaf, 0x99, 0x1e, 0xa9, 0x50, 0xc8, 0xd7, 0x61, 0xa9,
	0x47, 0x83, 0xe8, 0x98, 0x5d, 0xf2, 0x57, 0x27, 0xc1, 0xab, 0xda, 0x01, 0xac, 0xd1, 0xc8, 0x36,
	0x2c, 0x23, 0xf2, 0x7c, 0x2c, 0x0a, 0x76, 0x33, 0xbd, 0xea, 0x44, 0x3c, 0xdb, 0x17, 0x2c, 0xa5,
	0x41, 0xa4, 0xb2, 0xb9, 0x6d, 0x28, 0x6b, 0x12, 0xc8, 0x23, 0x80, 0xdd, 0x30, 0xa4, 0x59, 0xf6,
	0x61, 0x90, 0x5d, 0x7b, 0x73, 0xb2, 0xe8, 0xe5, 0x56, 0x1b, 0x14, 0xf2, 0x5d, 0x58, 0x3a, 0xe5,
	0x22, 0xbe, 0x9a, 0xf4, 0xa9, 0x10, 0x31, 0x1b, 0x64, 0xde, 0xfc, 0x86, 0xb5, 0xb9, 0xb0, 0x73,
	0x5f, 0x06, 0x12, 0xcd, 0xaf, 0x92, 0x7b, 0x35, 0x76, 0x34, 0xf7, 0x84, 0x32, 0x11, 0x73, 0x46,
	0xb5, 0x4e, 0x9d, 0x0d, 0xab, 0xd0, 0xa9, 0x46, 0xf3, 0x7f, 0x04, 0x4d, 0xdc, 0x93, 0xdc, 0x03,
	0x7b, 0x2a, 0x18, 0xf6, 0xf1, 0x01, 0x1e, 0x8b, 0xa9, 0x20, 0x48, 0xa4, 0x66, 0x90, 0x73, 0x93,
	0x41, 0xbe, 0x80, 0xce, 0x31, 0x1b, 0x8d, 0xc5, 0x7f, 0x15, 0xf3, 0x35, 0x43, 0xcc, 0xd2, 0xce,
	0x62, 0x61, 0x2b, 0x82, 0xff, 0x97, 0xd4, 0xbe, 0x96, 0x8a, 0x75, 0x03, 0x4f, 0x1b, 0xfe, 0x4e,
	0x9f, 0x36, 0x85, 0xd6, 0x36, 0xb5, 0x6f, 0xdc, 0xf4, 0x77, 0x16, 0xac, 0xc8, 0x5d, 0x8f, 0xe2,
	0x84, 0x3e, 0xe3, 0x61, 0x80, 0x9e, 0xc4, 0xc4, 0xdc, 0x4f, 0xc6, 0x99, 0x28, 0x04, 0xe4, 0x7e,
	0x2a, 0x61, 0xd4, 0x00, 0xbf, 0xd1, 0xd9, 0x6d, 0x68, 0xa0, 0xd0, 0xdb, 0x9a, 0x85, 0x85, 0xe8,
	0x23, 0x9a, 0x62, 0xb6, 0x7b, 0x4d, 0x23, 0xaa, 0x39, 0xe8, 0x7f, 0x02, 0xdd, 0x2f, 0x4b, 0x37,
	0xff, 0xe7, 0x16, 0x74, 0xd0, 0xa1, 0x67, 0xd7, 0x38, 0x52, 0x3c, 0x86, 0x79, 0xf9, 0x67, 0x2f,
	0x1e, 0x48, 0xc1, 0x0b, 0x3b, 0x2b, 0x32, 0xaa, 0xa6, 0x7a, 0xbd, 0x82, 0x85, 0x7c, 0x03, 0x40,
	0xfe, 0xef, 0x0f, 0x83, 0x24, 0x91, 0x8a, 0xcc, 0xfc, 0xc0, 0x60, 0x92, 0x45, 0x19, 0x57, 0xb5,
	0xe4, 0xcf, 0x41, 0xff, 0x2f, 0x36, 0x34, 0x65, 0xf8, 0x6f, 0x3a, 0x74, 0x3e, 0x74, 0x8e, 0xe2,
	0x34, 0x13, 0xa7, 0xc1, 0x90, 0x56, 0x8a, 0x5b, 0x09, 0x63, 0x21, 0x7a, 0x16, 0x68, 0x16, 0xc7,
	0x60, 0x29, 0x50, 0xd9, 0xab, 0x33, 0x9a, 0x32, 0xe4, 0xc0, 0x98, 0x14, 0x1c, 0x39, 0x4a, 0x1e,
	0x43, 0xbb, 0x2f, 0x02, 0x31, 0xce, 0x64, 0x25, 0x59, 0xda, 0x59, 0x2e, 0xfa, 0x9a, 0x82, 0xf3,
	0x32, 0xa9, 0x56, 0xd8, 0x32, 0x7a, 0x34, 0x13, 0x69, 0x1c, 0x0a, 0x1a, 0xc9, 0x82, 0x92, 0x17,
	0x52, 0x03, 0xbf, 0x75, 0x3d, 0x79, 0x08, 0x2d, 0xe9, 0x10, 0x5d, 0x46, 0x96, 0x0a, 0xd9, 0x12,
	0xed, 0x29, 0x22, 0xb9, 0x07, 0xce, 0x5e, 0xcc, 0x65, 0xa5, 0xc8, 0xf5, 0x47, 0xc0, 0xff, 0xd4,
	0x96, 0xd3, 0x8e, 0x08, 0x42, 0xf1, 0x05, 0xb8, 0xb2, 0x6a, 0x53, 0xf3, 0x46, 0x9b, 0xd6, 0xa4,
	0x4d, 0x8c, 0x4a, 0x7f, 0x16, 0x1d, 0x49, 0x42, 0x95, 0x70, 0xb4, 0x4d, 0x29, 0x45, 0x38, 0x7c,
	0x98, 0xdf, 0x4f, 0x62, 0xca, 0x70, 0xf8, 0x9c, 0xab, 0x58, 0x52, 0xe0, 0xb7, 0xf3, 0x9a, 0xff,
	0xd3, 0x36, 0x2c, 0x20, 0x98, 0x8f, 0x1a, 0x77, 0x0d, 0xef, 0x28, 0xa9, 0xb6, 0xca, 0x2f, 0xdd,
	0xeb, 0xec, 0x77, 0xf6, 0x3a, 0x67, 0x66, 0xaf, 0xc3, 0x2c, 0x4e, 0x69, 0x20, 0x68, 0xf4, 0x9c,
	0x55, 0x9a, 0x57, 0x09, 0xe3, 0x2e, 0x87, 0x51, 0xac, 0x58, 0xcc, 0x86, 0x55, 0xa0, 0x64, 0x13,
	0x16, 0x8e, 0x3e, 0x8e, 0xfa, 0x94, 0x45, 0x52, 0x99, 0x76, 0x45, 0x19, 0x93, 0x44, 0xb6, 0xa0,
	0x7b, 0xf4, 0x71, 0xb4, 0x7f, 0x1d, 0x30, 0x46, 0x93, 0x29, 0x2f, 0x55, 0x68, 0xe4, 0x5b, 0x70,
	0xa7, 0x5c, 0x97, 0xed, 0x78, 0xbe, 0xf2, 0xc9, 0x2c, 0x16, 0x8c, 0xe2, 0x51, 0x12, 0x0c, 0x32,
	0xaf, 0x63, 0x18, 0xad, 0x20, 0x39, 0x31, 0x2a, 0x46, 0xe9, 0x16, 0xa8, 0x4c, 0x8c, 0x25, 0x01,
	0xdb, 0xd3, 0x1e, 0x8f, 0x26, 0xde, 0x82, 0x39, 0xb5, 0x20, 0x82, 0x51, 0x2e, 0x4c, 0xed, 0x56,
	0xa3, 0x5c, 0xd8, 0xa9, 0x46, 0x79, 0x41, 0x99, 0xc0, 0xae, 0xee, 0x2d, 0x1a, 0xa9, 0x66, 0x12,
	0xe4, 0x04, 0x84, 0x13, 0x82, 0xb7, 0x64, 0x70, 0x28, 0x08, 0xab, 0x50, 0x8f, 0x8e, 0x92, 0xc9,
	0x39, 0xf7, 0x96, 0xcd, 0x2a, 0xa4, 0x41, 0xb2, 0x05, 0x8b, 0x5a, 0xe1, 0xdd, 0x10, 0x4b, 0x98,
	0xe7, 0x1a, 0x75, 0xbb, 0x4a, 0x22, 0x3b, 0xb0, 0x52, 0x01, 0x0e, 0x02, 0x11, 0x78, 0x2b, 0x1b,
	0x56, 0x31, 0x70, 0x4e, 0x93, 0xc9, 0x36, 0x8e, 0x7c, 0x22, 0x16, 0x31, 0xcd, 0x3c, 0x22, 0x87,
	0x62, 0x52, 0x1d, 0xf9, 0x44, 0x2c, 0x26, 0xbd, 0x82, 0x07, 0x6f, 0x41, 0x27, 0x34, 0x8a, 0x03,
	0xe9, 0xd7, 0x3b, 0x1b, 0xd6, 0xe6, 0x92, 0x3e, 0xdd, 0x05, 0x5a, 0x8e, 0x9e, 0x1a, 0x40, 0xfb,
	0xe5, 0xc2, 0xbb, 0x6b, 0xe8, 0xa2, 0x20, 0xff, 0xb7, 0x56, 0x61, 0xa0, 0x92, 0x45, 0x9e, 0xe8,
	0x5e, 0x6e, 0xc9, 0x62, 0x77, 0x6f, 0x5a, 0x9b, 0xa9, 0xa6, 0xfe, 0x00, 0xda, 0xcf, 0xaf, 0xae,
	0x32, 0x2a, 0x2a, 0x63, 0x86, 0xc6, 0x8c, 0x2b, 0x8b, 0x33, 0xe3, 0xca, 0x52, 0xf6, 0x76, 0x2c,
	0xbe, 0x53, 0xbd, 0xdd, 0xff, 0x21, 0x74, 0x7b, 0xfd, 0xdd, 0xb3, 0xf1, 0x65, 0x12, 0x87, 0x38,
	0xca, 0x3f, 0x82, 0x85, 0xa3, 0x98, 0x0d, 0x68, 0x7a, 0x96, 0xc6, 0xac, 0x3a, 0x91, 0x9b, 0x04,
	0x42, 0xc0, 0x3a, 0xad, 0x54, 0x32, 0xeb, 0x14, 0xb1, 0x43, 0xa9, 0xc4, 0x62, 0x8e, 0x1d, 0xfa,
	0x14, 0xe6, 0x0e, 0x3e, 0x94, 0x57, 0x8f, 0x5b, 0x6f, 0x8d, 0xe5, 0x2b, 0x8d, 0x6b, 0x85, 0x52,
	0x41, 0x58, 0x88, 0x9f, 0x52, 0x56, 0xb1, 0x14, 0x01, 0xff, 0x57, 0x16, 0x74, 0x65, 0x81, 0xd3,
	0xd5, 0xb8, 0x52, 0xc5, 0xac, 0x1b, 0xaa, 0xd8, 0xe7, 0x53, 0x95, 0x8b, 0x6a, 0xdb, 0x9c, 0xaa,
	0xb6, 0xfe, 0x08, 0xc8, 0xf4, 0x48, 0x5a, 0x66, 0xb6, 0x35, 0x9d, 0xd9, 0x78, 0xd5, 0x19, 0x0b,
	0x7a, 0xc1, 0x44, 0x8c, 0x7d, 0xde, 0x2a, 0x6b, 0x59, 0x01, 0xe3, 0xf7, 0x7d, 0x3e, 0x66, 0x78,
	0xd9, 0x2a, 0xfb, 0x91, 0x82, 0xfc, 0x4f, 0x2d, 0x3d, 0xd9, 0xe1, 0x5c, 0x60, 0xcc, 0x2e, 0xd6,
	0xcc, 0xd9, 0xe5, 0x21, 0xc0, 0x39, 0x17, 0x41, 0x72, 0x16, 0xa4, 0x22, 0xab, 0x9c, 0x2e, 0x03,
	0x47, 0x1f, 0x20, 0xff, 0xb4, 0x0f, 0x72, 0x54, 0xd6, 0xa3, 0x83, 0x6f, 0xee, 0x5f, 0xd3, 0xf0,
	0x45, 0x36, 0x1e, 0x56, 0x3c, 0x61, 0x12, 0x7c, 0x06, 0x20, 0xcf, 0xc2, 0x17, 0x34, 0x03, 0xf9,
	0xff, 0xb6, 0xa0, 0xa5, 0x0e, 0xdf, 0x4d, 0x9d, 0x79, 0x0d, 0x5a, 0xe7, 0xb1, 0x48, 0x6a, 0x87,
	0x4d, 0x42, 0xd5, 0xbe, 0xe2, 0xcc, 0xee, 0x2b, 0x9b, 0xd0, 0x45, 0x27, 0xc5, 0x61, 0x3c, 0x0a,
	0x98, 0xc8, 0xa4, 0xe9, 0xb9, 0x0f, 0x2b, 0x94, 0x5a, 0x07, 0xb2, 0x66, 0x74, 0xa0, 0xf7, 0xf3,
	0x73, 0x81, 0xb7, 0xf7, 0x7c, 0x0e, 0x92, 0xea, 0x4b, 0x38, 0x3f, 0x22, 0xef, 0xe7, 0xcd, 0x77,
	0x4e, 0x36, 0x5f, 0x83, 0xad, 0xd2, 0x7d, 0xff, 0x6a, 0x41, 0x47, 0x7d, 0x3c, 0x4e, 0x12, 0xb2,
	0xa1, 0x1d, 0xa1, 0x1d, 0x6d, 0xbe, 0x0c, 0x68, 0x0f, 0x15, 0xaf, 0x0b, 0xf6, 0x0d, 0xaf, 0x0b,
	0xdf, 0xae, 0x99, 0xea, 0x48, 0xbe, 0x55, 0x43, 0x7c, 0x49, 0xad, 0xd9, 0x3e, 0x7d, 0x6b, 0x53,
	0xd7, 0xef, 0xdb, 0xde, 0xda, 0xfc, 0x5f, 0xdb, 0xe0, 0xd6, 0x65, 0xbc, 0xf3, 0xde, 0xf2, 0xf9,
	0xe4, 0xf7, 0xb6, 0xae, 0xd7, 0x4d, 0x59, 0xaf, 0xd5, 0x83, 0x81, 0xa1, 0xc5, 0x3b, 0xae, 0x60,
	0x2d, 0xf9, 0x5a, 0x31, 0x6b, 0x4a, 0x7b, 0xf7, 0x24, 0x76, 0xbb, 0x29, 0x2b, 0x83, 0x45, 0x99,
	0xf0, 0x07, 0x3c, 0x1c, 0x0f, 0x29, 0x13, 0x37, 0x1e, 0xf5, 0x5b, 0x5e, 0xe3, 0xaa, 0x97, 0x22,
	0x67, 0xe6, 0xa5, 0xc8, 0xff, 0x83, 0x0d, 0x8b, 0xd8, 0x65, 0x5f, 0x52, 0xfd, 0xba, 0x62, 0xbc,
	0x23, 0x45, 0x86, 0x31, 0xf9, 0x3b, 0x12, 0xb6, 0x48, 0x1e, 0xd1, 0xa4, 0xf2, 0x7e, 0xa2, 0x20,
	0x2c, 0x42, 0xbb, 0xa3, 0x51, 0x7e, 0x6f, 0x33, 0xe3, 0x64, 0xe0, 0x38, 0x28, 0xf4, 0x27, 0x99,
	0xa0, 0xc3, 0x9c, 0xd1, 0x8c, 0x56, 0x95, 0xa4, 0x82, 0xca, 0x06, 0xf2, 0xc1, 0xa6, 0x59, 0x0d,
	0xaa, 0x42, 0x8d, 0xd4, 0xde, 0x15, 0xd5, 0xf7, 0xc1, 0x02, 0xc6, 0x5d, 0x94, 0x89, 0xbb, 0x42,
	0x4f, 0x83, 0x7a, 0x97, 0x1c, 0x45, 0x0e, 0xdd, 0x4c, 0xce, 0xe4, 0x10, 0x58, 0xc8, 0xc9, 0xd1,
	0xad, 0xdf, 0x58, 0xd0, 0x3d, 0x9f, 0x8c, 0x62, 0x36, 0xd0, 0x33, 0xcc, 0x3d, 0x20, 0xe6, 0x5a,
	0xfd, 0x77, 0x1b, 0x64, 0x1d, 0xd6, 0x4c, 0xbc, 0x47, 0x43, 0x9e, 0x46, 0x31, 0x1b, 0x7c, 0xc4,
	0xe3, 0x90, 0xba, 0xd6, 0xcd, 0xf4, 0x38, 0xa2, 0xdc, 0xb5, 0xc9, 0x57, 0x60, 0xd5, 0xa4, 0x5f,
	0x8c, 0x12, 0x1e, 0x20, 0xdd, 0x75, 0xea, 0x22, 0xf7, 0x03, 0x16, 0xd2, 0xc4, 0x6d, 0x6e, 0xfd,
	0xa0, 0x1c, 0xac, 0x49, 0x57, 0xfd, 0xef, 0xd3, 0xe4, 0xca, 0x6d, 0xe4, 0x2b, 0x3c, 0x6a, 0xae,
	0x45, 0x16, 0xa1, 0x83, 0x2b, 0x99, 0x7e, 0xae, 0x4d, 0x08, 0x2c, 0x49, 0xd6, 0xf1, 0x28, 0xc7,
	0x1c, 0xb2, 0x0c, 0x0b, 0x88, 0xe9, 0x19, 0xd6, 0x6d, 0x6e, 0xfd, 0xcc, 0x02, 0x28, 0x6f, 0x70,
	0x64, 0x15, 0x56, 0xca, 0xd5, 0xf3, 0xab, 0xab, 0x24, 0x66, 0xd4, 0x6d, 0x90, 0xbb, 0xe0, 0x1a,
	0x30, 0x93, 0xa8, 0x85, 0xfa, 0x96, 0x68, 0x8f, 0x86, 0x94, 0x89, 0x64, 0xe2, 0xda, 0x55, 0x1c,
	0xd3, 0xf3, 0xfb, 0x94, 0xbe, 0x70, 0x1d, 0x72, 0x1f, 0xee, 0x54, 0xf1, 0x13, 0xce, 0xc4, 0xb5,
	0xdb, 0xdc, 0xfa, 0xc4, 0x98, 0xe5, 0x50, 0xed, 0x62, 0x71, 0x38, 0x1c, 0x89, 0x89, 0xdb, 0xa8,
	0x60, 0x32, 0x99, 0x5c, 0x0b, 0x55, 0x2d, 0xb0, 0x3c, 0xa5, 0x5c, 0x1b, 0x55, 0x2d, 0x60, 0x3d,
	0x63, 0xb8, 0x0e, 0xf1, 0xe0, 0x6e, 0x81, 0x3e, 0xa5, 0x3c, 0xef, 0x41, 0x6e, 0x73, 0xeb, 0xcf,
	0x56, 0x31, 0xac, 0x96, 0x53, 0x1d, 0x46, 0x69, 0x7a, 0xd4, 0xe3, 0x49, 0xe4, 0x36, 0xc8, 0x57,
	0xe1, 0xfe, 0x14, 0xe9, 0x58, 0x04, 0x49, 0x1c, 0xba, 0x16, 0x79, 0x00, 0xde, 0x14, 0x51, 0xbf,
	0x54, 0xb9, 0xb6, 0xd2, 0xa2, 0x46, 0xbd, 0x48, 0x13, 0xd7, 0x21, 0x6b, 0x70, 0x6f, 0x8a, 0x72,
	0x38, 0x0c, 0xe2, 0xc4, 0x6d, 0xce, 0xdc, 0x13, 0xf3, 0x5f, 0x04, 0x03, 0xb7, 0xb5, 0xf5, 0x7b,
	0x4b, 0xb7, 0x6a, 0xd5, 0x73, 0xee, 0xc0, 0x72, 0xb9, 0xca, 0xdd, 0xb7, 0x0a, 0x2b, 0x25, 0x28,
	0xf3, 0x86, 0xa7, 0x4a, 0xd9, 0x12, 0x3e, 0xe5, 0xcc, 0x28, 0x96, 0xae, 0x5d, 0xdd, 0x69, 0x37,
	0x1a, 0xc6, 0xcc, 0x75, 0xd0, 0xf8, 0x1a, 0x98, 0x1d, 0xb2, 0xe0, 0x32, 0xa1, 0x91, 0xdb, 0x44,
	0xa7, 0x95, 0xc4, 0x03, 0x1a, 0x60, 0xf6, 0x61, 0x8a, 0xba, 0xad, 0xad, 0x4b, 0x58, 0xae, 0x95,
	0x62, 0xe4, 0xae, 0x41, 0x27, 0x74, 0x78, 0x49, 0x53, 0xb7, 0x81, 0x7e, 0xaa, 0x91, 0x94, 0x7c,
	0x0b, 0xfd, 0x54, 0xa3, 0xe4, 0xe6, 0xd8, 0x7b, 0x0f, 0x5e, 0xff, 0x73, 0xbd, 0xf1, 0xd9, 0x9b,
	0x75, 0xeb, 0xf5, 0x9b, 0x75, 0xeb, 0x1f, 0x6f, 0xd6, 0xad, 0x5f, 0xbc, 0x5d, 0x6f, 0xbc, 0x7e,
	0xbb, 0xde, 0xf8, 0xdb, 0xdb, 0xf5, 0xc6, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xd2, 0xb0, 0xf9,
	0x54, 0x32, 0x1a, 0x00, 0x00,
}

func (m *MessageEnvelope) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageEnvelope) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Constructor))
	dAtA[i] = 0x11
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.RequestID))
	i += 8
	if m.Message != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *MessageContainer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageContainer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Length))
	if len(m.Envelopes) > 0 {
		for _, msg := range m.Envelopes {
			dAtA[i] = 0x12
			i++
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UpdateEnvelope) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateEnvelope) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Constructor))
	if m.Update != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Update)))
		i += copy(dAtA[i:], m.Update)
	}
	dAtA[i] = 0x18
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.UCount))
	dAtA[i] = 0x20
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.UpdateID))
	dAtA[i] = 0x28
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Timestamp))
	return i, nil
}

func (m *UpdateContainer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateContainer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Length))
	if len(m.Updates) > 0 {
		for _, msg := range m.Updates {
			dAtA[i] = 0x12
			i++
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x18
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.MinUpdateID))
	dAtA[i] = 0x20
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.MaxUpdateID))
	if len(m.Users) > 0 {
		for _, msg := range m.Users {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Groups) > 0 {
		for _, msg := range m.Groups {
			dAtA[i] = 0x32
			i++
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ProtoMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtoMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.AuthID))
	if m.MessageKey != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.MessageKey)))
		i += copy(dAtA[i:], m.MessageKey)
	}
	if m.Payload != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	return i, nil
}

func (m *ProtoEncryptedPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtoEncryptedPayload) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ServerSalt))
	dAtA[i] = 0x10
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.MessageID))
	dAtA[i] = 0x18
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.SessionID))
	if m.Envelope == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("Envelope")
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Envelope.Size()))
		n1, err := m.Envelope.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Code)))
	i += copy(dAtA[i:], m.Code)
	dAtA[i] = 0x12
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Items)))
	i += copy(dAtA[i:], m.Items)
	return i, nil
}

func (m *Ack) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ack) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Bool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bool) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.Result {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *Dialog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dialog) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.PeerID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.PeerType))
	dAtA[i] = 0x18
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.TopMessageID))
	dAtA[i] = 0x20
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ReadInboxMaxID))
	dAtA[i] = 0x28
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ReadOutboxMaxID))
	dAtA[i] = 0x30
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.UnreadCount))
	dAtA[i] = 0x39
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i += 8
	if m.NotifySettings != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.NotifySettings.Size()))
		n2, err := m.NotifySettings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	dAtA[i] = 0x48
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.MentionedCount))
	return i, nil
}

func (m *Peer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Peer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x19
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i += 8
	return i, nil
}

func (m *InputPeer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputPeer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x19
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i += 8
	return i, nil
}

func (m *InputUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.UserID))
	dAtA[i] = 0x11
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i += 8
	return i, nil
}

func (m *InputFileLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputFileLocation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ClusterID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.FileID))
	dAtA[i] = 0x19
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i += 8
	dAtA[i] = 0x20
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Version))
	return i, nil
}

func (m *FileLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileLocation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ClusterID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.FileID))
	dAtA[i] = 0x19
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i += 8
	return i, nil
}

func (m *UserPhoto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserPhoto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PhotoBig == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("PhotoBig")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.PhotoBig.Size()))
		n3, err := m.PhotoBig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.PhotoSmall == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("PhotoSmall")
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.PhotoSmall.Size()))
		n4, err := m.PhotoSmall.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	dAtA[i] = 0x18
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.PhotoID))
	return i, nil
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.FirstName)))
	i += copy(dAtA[i:], m.FirstName)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.LastName)))
	i += copy(dAtA[i:], m.LastName)
	dAtA[i] = 0x22
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Username)))
	i += copy(dAtA[i:], m.Username)
	dAtA[i] = 0x28
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Status))
	dAtA[i] = 0x30
	i++
	if m.Restricted {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x39
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i += 8
	if m.Photo != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Photo.Size()))
		n5, err := m.Photo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	dAtA[i] = 0x4a
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Bio)))
	i += copy(dAtA[i:], m.Bio)
	return i, nil
}

func (m *ContactUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContactUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.FirstName)))
	i += copy(dAtA[i:], m.FirstName)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.LastName)))
	i += copy(dAtA[i:], m.LastName)
	dAtA[i] = 0x21
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i += 8
	dAtA[i] = 0x2a
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Phone)))
	i += copy(dAtA[i:], m.Phone)
	dAtA[i] = 0x32
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Username)))
	i += copy(dAtA[i:], m.Username)
	dAtA[i] = 0x38
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ClientID))
	if m.Photo != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Photo.Size()))
		n6, err := m.Photo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *UserMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.PeerID))
	dAtA[i] = 0x18
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.PeerType))
	dAtA[i] = 0x20
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.CreatedOn))
	dAtA[i] = 0x28
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.EditedOn))
	dAtA[i] = 0x30
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.FwdSenderID))
	dAtA[i] = 0x38
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.FwdChannelID))
	dAtA[i] = 0x40
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.FwdChannelMessageID))
	dAtA[i] = 0x48
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Flags))
	dAtA[i] = 0x50
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.MessageType))
	dAtA[i] = 0x5a
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Body)))
	i += copy(dAtA[i:], m.Body)
	dAtA[i] = 0x60
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.SenderID))
	dAtA[i] = 0x68
	i++
	if m.ContentRead {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x70
	i++
	if m.Inbox {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x78
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ReplyTo))
	dAtA[i] = 0x80
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.MessageAction))
	if m.MessageActionData != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.MessageActionData)))
		i += copy(dAtA[i:], m.MessageActionData)
	}
	if len(m.Entities) > 0 {
		for _, msg := range m.Entities {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x98
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.MediaType))
	if m.Media != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Media)))
		i += copy(dAtA[i:], m.Media)
	}
	return i, nil
}

func (m *MessageEntity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageEntity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x10
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Offset))
	dAtA[i] = 0x18
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Length))
	dAtA[i] = 0x20
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.UserID))
	return i, nil
}

func (m *RSAPublicKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RSAPublicKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.FingerPrint))
	dAtA[i] = 0x12
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.N)))
	i += copy(dAtA[i:], m.N)
	dAtA[i] = 0x18
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.E))
	return i, nil
}

func (m *DHGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.FingerPrint))
	dAtA[i] = 0x12
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Prime)))
	i += copy(dAtA[i:], m.Prime)
	dAtA[i] = 0x18
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Gen))
	return i, nil
}

func (m *PhoneContact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhoneContact) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ClientID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.FirstName)))
	i += copy(dAtA[i:], m.FirstName)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.LastName)))
	i += copy(dAtA[i:], m.LastName)
	dAtA[i] = 0x22
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Phone)))
	i += copy(dAtA[i:], m.Phone)
	return i, nil
}

func (m *PeerNotifySettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerNotifySettings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Flags))
	dAtA[i] = 0x10
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.MuteUntil))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Sound)))
	i += copy(dAtA[i:], m.Sound)
	return i, nil
}

func (m *InputFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputFile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.FileID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.TotalParts))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.FileName)))
	i += copy(dAtA[i:], m.FileName)
	dAtA[i] = 0x22
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.MD5Checksum)))
	i += copy(dAtA[i:], m.MD5Checksum)
	return i, nil
}

func (m *GroupPhoto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupPhoto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PhotoBig == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("PhotoBig")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.PhotoBig.Size()))
		n7, err := m.PhotoBig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.PhotoSmall == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("PhotoSmall")
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.PhotoSmall.Size()))
		n8, err := m.PhotoSmall.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *Group) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Group) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Title)))
	i += copy(dAtA[i:], m.Title)
	dAtA[i] = 0x18
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.CreatedOn))
	dAtA[i] = 0x20
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Participants))
	dAtA[i] = 0x28
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.EditedOn))
	if len(m.Flags) > 0 {
		for _, num := range m.Flags {
			dAtA[i] = 0x30
			i++
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(num))
		}
	}
	if m.Photo != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Photo.Size()))
		n9, err := m.Photo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *GroupFull) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupFull) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Group == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("Group")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Group.Size()))
		n10, err := m.Group.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.Users) > 0 {
		for _, msg := range m.Users {
			dAtA[i] = 0x12
			i++
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Participants) > 0 {
		for _, msg := range m.Participants {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintChatCoreTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.NotifySettings == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("NotifySettings")
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.NotifySettings.Size()))
		n11, err := m.NotifySettings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *GroupParticipant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupParticipant) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.UserID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.FirstName)))
	i += copy(dAtA[i:], m.FirstName)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.LastName)))
	i += copy(dAtA[i:], m.LastName)
	dAtA[i] = 0x20
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x28
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.AccessHash))
	dAtA[i] = 0x32
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Username)))
	i += copy(dAtA[i:], m.Username)
	if m.Photo != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.Photo.Size()))
		n12, err := m.Photo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *InputDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputDocument) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x11
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i += 8
	dAtA[i] = 0x18
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ClusterID))
	return i, nil
}

func (m *ActiveSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActiveSession) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.Model)))
	i += copy(dAtA[i:], m.Model)
	dAtA[i] = 0x12
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.AppVersion)))
	i += copy(dAtA[i:], m.AppVersion)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.SystemVersion)))
	i += copy(dAtA[i:], m.SystemVersion)
	dAtA[i] = 0x22
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.LangCode)))
	i += copy(dAtA[i:], m.LangCode)
	dAtA[i] = 0x28
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.CreatedAt))
	dAtA[i] = 0x30
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(m.ActiveAt))
	dAtA[i] = 0x3a
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.ClientIP)))
	i += copy(dAtA[i:], m.ClientIP)
	dAtA[i] = 0xa2
	i++
	dAtA[i] = 0x6
	i++
	i = encodeVarintChatCoreTypes(dAtA, i, uint64(len(m.AuthID)))
	i += copy(dAtA[i:], m.AuthID)
	return i, nil
}

func encodeVarintChatCoreTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *MessageEnvelope) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.Constructor))
	n += 9
	if m.Message != nil {
		l = len(m.Message)
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	return n
}

func (m *MessageContainer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.Length))
	if len(m.Envelopes) > 0 {
		for _, e := range m.Envelopes {
			l = e.Size()
			n += 1 + l + sovChatCoreTypes(uint64(l))
		}
	}
	return n
}

func (m *UpdateEnvelope) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.Constructor))
	if m.Update != nil {
		l = len(m.Update)
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	n += 1 + sovChatCoreTypes(uint64(m.UCount))
	n += 1 + sovChatCoreTypes(uint64(m.UpdateID))
	n += 1 + sovChatCoreTypes(uint64(m.Timestamp))
	return n
}

func (m *UpdateContainer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.Length))
	if len(m.Updates) > 0 {
		for _, e := range m.Updates {
			l = e.Size()
			n += 1 + l + sovChatCoreTypes(uint64(l))
		}
	}
	n += 1 + sovChatCoreTypes(uint64(m.MinUpdateID))
	n += 1 + sovChatCoreTypes(uint64(m.MaxUpdateID))
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovChatCoreTypes(uint64(l))
		}
	}
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovChatCoreTypes(uint64(l))
		}
	}
	return n
}

func (m *ProtoMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.AuthID))
	if m.MessageKey != nil {
		l = len(m.MessageKey)
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	if m.Payload != nil {
		l = len(m.Payload)
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	return n
}

func (m *ProtoEncryptedPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.ServerSalt))
	n += 1 + sovChatCoreTypes(uint64(m.MessageID))
	n += 1 + sovChatCoreTypes(uint64(m.SessionID))
	if m.Envelope != nil {
		l = m.Envelope.Size()
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	return n
}

func (m *Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Code)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.Items)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	return n
}

func (m *Ack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Bool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}

func (m *Dialog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.PeerID))
	n += 1 + sovChatCoreTypes(uint64(m.PeerType))
	n += 1 + sovChatCoreTypes(uint64(m.TopMessageID))
	n += 1 + sovChatCoreTypes(uint64(m.ReadInboxMaxID))
	n += 1 + sovChatCoreTypes(uint64(m.ReadOutboxMaxID))
	n += 1 + sovChatCoreTypes(uint64(m.UnreadCount))
	n += 9
	if m.NotifySettings != nil {
		l = m.NotifySettings.Size()
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	n += 1 + sovChatCoreTypes(uint64(m.MentionedCount))
	return n
}

func (m *Peer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.ID))
	n += 1 + sovChatCoreTypes(uint64(m.Type))
	n += 9
	return n
}

func (m *InputPeer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.ID))
	n += 1 + sovChatCoreTypes(uint64(m.Type))
	n += 9
	return n
}

func (m *InputUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.UserID))
	n += 9
	return n
}

func (m *InputFileLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.ClusterID))
	n += 1 + sovChatCoreTypes(uint64(m.FileID))
	n += 9
	n += 1 + sovChatCoreTypes(uint64(m.Version))
	return n
}

func (m *FileLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.ClusterID))
	n += 1 + sovChatCoreTypes(uint64(m.FileID))
	n += 9
	return n
}

func (m *UserPhoto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PhotoBig != nil {
		l = m.PhotoBig.Size()
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	if m.PhotoSmall != nil {
		l = m.PhotoSmall.Size()
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	n += 1 + sovChatCoreTypes(uint64(m.PhotoID))
	return n
}

func (m *User) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.ID))
	l = len(m.FirstName)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.LastName)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.Username)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	n += 1 + sovChatCoreTypes(uint64(m.Status))
	n += 2
	n += 9
	if m.Photo != nil {
		l = m.Photo.Size()
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	l = len(m.Bio)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	return n
}

func (m *ContactUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.ID))
	l = len(m.FirstName)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.LastName)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	n += 9
	l = len(m.Phone)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.Username)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	n += 1 + sovChatCoreTypes(uint64(m.ClientID))
	if m.Photo != nil {
		l = m.Photo.Size()
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	return n
}

func (m *UserMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.ID))
	n += 1 + sovChatCoreTypes(uint64(m.PeerID))
	n += 1 + sovChatCoreTypes(uint64(m.PeerType))
	n += 1 + sovChatCoreTypes(uint64(m.CreatedOn))
	n += 1 + sovChatCoreTypes(uint64(m.EditedOn))
	n += 1 + sovChatCoreTypes(uint64(m.FwdSenderID))
	n += 1 + sovChatCoreTypes(uint64(m.FwdChannelID))
	n += 1 + sovChatCoreTypes(uint64(m.FwdChannelMessageID))
	n += 1 + sovChatCoreTypes(uint64(m.Flags))
	n += 1 + sovChatCoreTypes(uint64(m.MessageType))
	l = len(m.Body)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	n += 1 + sovChatCoreTypes(uint64(m.SenderID))
	n += 2
	n += 2
	n += 1 + sovChatCoreTypes(uint64(m.ReplyTo))
	n += 2 + sovChatCoreTypes(uint64(m.MessageAction))
	if m.MessageActionData != nil {
		l = len(m.MessageActionData)
		n += 2 + l + sovChatCoreTypes(uint64(l))
	}
	if len(m.Entities) > 0 {
		for _, e := range m.Entities {
			l = e.Size()
			n += 2 + l + sovChatCoreTypes(uint64(l))
		}
	}
	n += 2 + sovChatCoreTypes(uint64(m.MediaType))
	if m.Media != nil {
		l = len(m.Media)
		n += 2 + l + sovChatCoreTypes(uint64(l))
	}
	return n
}

func (m *MessageEntity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.Type))
	n += 1 + sovChatCoreTypes(uint64(m.Offset))
	n += 1 + sovChatCoreTypes(uint64(m.Length))
	n += 1 + sovChatCoreTypes(uint64(m.UserID))
	return n
}

func (m *RSAPublicKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.FingerPrint))
	l = len(m.N)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	n += 1 + sovChatCoreTypes(uint64(m.E))
	return n
}

func (m *DHGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.FingerPrint))
	l = len(m.Prime)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	n += 1 + sovChatCoreTypes(uint64(m.Gen))
	return n
}

func (m *PhoneContact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.ClientID))
	l = len(m.FirstName)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.LastName)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.Phone)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	return n
}

func (m *PeerNotifySettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.Flags))
	n += 1 + sovChatCoreTypes(uint64(m.MuteUntil))
	l = len(m.Sound)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	return n
}

func (m *InputFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.FileID))
	n += 1 + sovChatCoreTypes(uint64(m.TotalParts))
	l = len(m.FileName)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.MD5Checksum)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	return n
}

func (m *GroupPhoto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PhotoBig != nil {
		l = m.PhotoBig.Size()
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	if m.PhotoSmall != nil {
		l = m.PhotoSmall.Size()
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	return n
}

func (m *Group) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.ID))
	l = len(m.Title)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	n += 1 + sovChatCoreTypes(uint64(m.CreatedOn))
	n += 1 + sovChatCoreTypes(uint64(m.Participants))
	n += 1 + sovChatCoreTypes(uint64(m.EditedOn))
	if len(m.Flags) > 0 {
		for _, e := range m.Flags {
			n += 1 + sovChatCoreTypes(uint64(e))
		}
	}
	if m.Photo != nil {
		l = m.Photo.Size()
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	return n
}

func (m *GroupFull) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovChatCoreTypes(uint64(l))
		}
	}
	if len(m.Participants) > 0 {
		for _, e := range m.Participants {
			l = e.Size()
			n += 1 + l + sovChatCoreTypes(uint64(l))
		}
	}
	if m.NotifySettings != nil {
		l = m.NotifySettings.Size()
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	return n
}

func (m *GroupParticipant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.UserID))
	l = len(m.FirstName)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.LastName)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	n += 1 + sovChatCoreTypes(uint64(m.Type))
	n += 1 + sovChatCoreTypes(uint64(m.AccessHash))
	l = len(m.Username)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	if m.Photo != nil {
		l = m.Photo.Size()
		n += 1 + l + sovChatCoreTypes(uint64(l))
	}
	return n
}

func (m *InputDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatCoreTypes(uint64(m.ID))
	n += 9
	n += 1 + sovChatCoreTypes(uint64(m.ClusterID))
	return n
}

func (m *ActiveSession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Model)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.AppVersion)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.SystemVersion)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.LangCode)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	n += 1 + sovChatCoreTypes(uint64(m.CreatedAt))
	n += 1 + sovChatCoreTypes(uint64(m.ActiveAt))
	l = len(m.ClientIP)
	n += 1 + l + sovChatCoreTypes(uint64(l))
	l = len(m.AuthID)
	n += 2 + l + sovChatCoreTypes(uint64(l))
	return n
}

func sovChatCoreTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozChatCoreTypes(x uint64) (n int) {
	return sovChatCoreTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MessageEnvelope) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageEnvelope: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageEnvelope: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = append(m.Message[:0], dAtA[iNdEx:postIndex]...)
			if m.Message == nil {
				m.Message = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Constructor")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("RequestID")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Message")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageContainer) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageContainer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageContainer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Envelopes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Envelopes = append(m.Envelopes, &MessageEnvelope{})
			if err := m.Envelopes[len(m.Envelopes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Length")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateEnvelope) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateEnvelope: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateEnvelope: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Update = append(m.Update[:0], dAtA[iNdEx:postIndex]...)
			if m.Update == nil {
				m.Update = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UCount", wireType)
			}
			m.UCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateID", wireType)
			}
			m.UpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000010)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Constructor")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Update")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UCount")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UpdateID")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Timestamp")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateContainer) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateContainer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateContainer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Updates = append(m.Updates, &UpdateEnvelope{})
			if err := m.Updates[len(m.Updates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinUpdateID", wireType)
			}
			m.MinUpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinUpdateID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUpdateID", wireType)
			}
			m.MaxUpdateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxUpdateID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &User{})
			if err := m.Users[len(m.Users)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &Group{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Length")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MinUpdateID")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MaxUpdateID")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtoMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtoMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtoMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthID", wireType)
			}
			m.AuthID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageKey = append(m.MessageKey[:0], dAtA[iNdEx:postIndex]...)
			if m.MessageKey == nil {
				m.MessageKey = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AuthID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MessageKey")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Payload")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtoEncryptedPayload) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtoEncryptedPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtoEncryptedPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSalt", wireType)
			}
			m.ServerSalt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerSalt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageID", wireType)
			}
			m.MessageID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			m.SessionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Envelope", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Envelope == nil {
				m.Envelope = &MessageEnvelope{}
			}
			if err := m.Envelope.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ServerSalt")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MessageID")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("SessionID")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Envelope")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Code")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Items")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ack) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Bool) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Result")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dialog) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dialog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dialog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerID", wireType)
			}
			m.PeerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopMessageID", wireType)
			}
			m.TopMessageID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopMessageID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadInboxMaxID", wireType)
			}
			m.ReadInboxMaxID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadInboxMaxID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOutboxMaxID", wireType)
			}
			m.ReadOutboxMaxID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadOutboxMaxID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnreadCount", wireType)
			}
			m.UnreadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnreadCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000040)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifySettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NotifySettings == nil {
				m.NotifySettings = &PeerNotifySettings{}
			}
			if err := m.NotifySettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MentionedCount", wireType)
			}
			m.MentionedCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MentionedCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PeerID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PeerType")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("TopMessageID")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ReadInboxMaxID")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ReadOutboxMaxID")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UnreadCount")
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Peer) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Peer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Peer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Type")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputPeer) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputPeer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputPeer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (PeerType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Type")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputUser) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UserID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputFileLocation) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputFileLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputFileLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileID", wireType)
			}
			m.FileID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ClusterID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FileID")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileLocation) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileID", wireType)
			}
			m.FileID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ClusterID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FileID")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserPhoto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPhoto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPhoto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoBig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PhotoBig == nil {
				m.PhotoBig = &FileLocation{}
			}
			if err := m.PhotoBig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoSmall", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PhotoSmall == nil {
				m.PhotoSmall = &FileLocation{}
			}
			if err := m.PhotoSmall.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoID", wireType)
			}
			m.PhotoID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhotoID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PhotoBig")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PhotoSmall")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PhotoID")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (UserStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Restricted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Restricted = bool(v != 0)
			hasFields[0] |= uint64(0x00000010)
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000020)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Photo == nil {
				m.Photo = &UserPhoto{}
			}
			if err := m.Photo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FirstName")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("LastName")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Status")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Restricted")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContactUser) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContactUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContactUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			m.ClientID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000040)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Photo == nil {
				m.Photo = &UserPhoto{}
			}
			if err := m.Photo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FirstName")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("LastName")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Phone")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Username")
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ClientID")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerID", wireType)
			}
			m.PeerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedOn", wireType)
			}
			m.CreatedOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedOn |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditedOn", wireType)
			}
			m.EditedOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EditedOn |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwdSenderID", wireType)
			}
			m.FwdSenderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FwdSenderID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwdChannelID", wireType)
			}
			m.FwdChannelID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FwdChannelID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000040)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwdChannelMessageID", wireType)
			}
			m.FwdChannelMessageID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FwdChannelMessageID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000080)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000100)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageType", wireType)
			}
			m.MessageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000200)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000400)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderID", wireType)
			}
			m.SenderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SenderID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000800)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentRead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContentRead = bool(v != 0)
			hasFields[0] |= uint64(0x00001000)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inbox", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Inbox = bool(v != 0)
			hasFields[0] |= uint64(0x00002000)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyTo", wireType)
			}
			m.ReplyTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyTo |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00004000)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageAction", wireType)
			}
			m.MessageAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageAction |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageActionData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageActionData = append(m.MessageActionData[:0], dAtA[iNdEx:postIndex]...)
			if m.MessageActionData == nil {
				m.MessageActionData = []byte{}
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, &MessageEntity{})
			if err := m.Entities[len(m.Entities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaType", wireType)
			}
			m.MediaType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MediaType |= (MediaType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Media = append(m.Media[:0], dAtA[iNdEx:postIndex]...)
			if m.Media == nil {
				m.Media = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PeerID")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PeerType")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("CreatedOn")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("EditedOn")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FwdSenderID")
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FwdChannelID")
	}
	if hasFields[0]&uint64(0x00000080) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FwdChannelMessageID")
	}
	if hasFields[0]&uint64(0x00000100) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Flags")
	}
	if hasFields[0]&uint64(0x00000200) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MessageType")
	}
	if hasFields[0]&uint64(0x00000400) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Body")
	}
	if hasFields[0]&uint64(0x00000800) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("SenderID")
	}
	if hasFields[0]&uint64(0x00001000) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ContentRead")
	}
	if hasFields[0]&uint64(0x00002000) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Inbox")
	}
	if hasFields[0]&uint64(0x00004000) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ReplyTo")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageEntity) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageEntity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageEntity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (MessageEntityType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Type")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Offset")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Length")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RSAPublicKey) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RSAPublicKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RSAPublicKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FingerPrint", wireType)
			}
			m.FingerPrint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FingerPrint |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.N = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field E", wireType)
			}
			m.E = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.E |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FingerPrint")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("N")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("E")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHGroup) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FingerPrint", wireType)
			}
			m.FingerPrint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FingerPrint |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gen", wireType)
			}
			m.Gen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FingerPrint")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Prime")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Gen")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhoneContact) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhoneContact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhoneContact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			m.ClientID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ClientID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FirstName")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("LastName")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Phone")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerNotifySettings) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerNotifySettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerNotifySettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MuteUntil", wireType)
			}
			m.MuteUntil = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MuteUntil |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sound", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sound = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Flags")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputFile) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileID", wireType)
			}
			m.FileID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalParts", wireType)
			}
			m.TotalParts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalParts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MD5Checksum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MD5Checksum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FileID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("TotalParts")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FileName")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MD5Checksum")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupPhoto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupPhoto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupPhoto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoBig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PhotoBig == nil {
				m.PhotoBig = &FileLocation{}
			}
			if err := m.PhotoBig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoSmall", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PhotoSmall == nil {
				m.PhotoSmall = &FileLocation{}
			}
			if err := m.PhotoSmall.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PhotoBig")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PhotoSmall")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Group) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedOn", wireType)
			}
			m.CreatedOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedOn |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Participants", wireType)
			}
			m.Participants = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Participants |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditedOn", wireType)
			}
			m.EditedOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EditedOn |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v GroupFlags
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChatCoreTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (GroupFlags(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Flags = append(m.Flags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChatCoreTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthChatCoreTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Flags) == 0 {
					m.Flags = make([]GroupFlags, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v GroupFlags
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChatCoreTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (GroupFlags(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Flags = append(m.Flags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Photo == nil {
				m.Photo = &GroupPhoto{}
			}
			if err := m.Photo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Title")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("CreatedOn")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Participants")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupFull) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupFull: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupFull: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &Group{}
			}
			if err := m.Group.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &User{})
			if err := m.Users[len(m.Users)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Participants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Participants = append(m.Participants, &GroupParticipant{})
			if err := m.Participants[len(m.Participants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifySettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NotifySettings == nil {
				m.NotifySettings = &PeerNotifySettings{}
			}
			if err := m.NotifySettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Group")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("NotifySettings")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupParticipant) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupParticipant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupParticipant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (ParticipantType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000020)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Photo == nil {
				m.Photo = &UserPhoto{}
			}
			if err := m.Photo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UserID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FirstName")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("LastName")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Type")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Username")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputDocument) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ClusterID")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActiveSession) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActiveSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActiveSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LangCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveAt", wireType)
			}
			m.ActiveAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000040)
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000080)
		default:
			iNdEx = preIndex
			skippy, err := skipChatCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Model")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AppVersion")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("SystemVersion")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("LangCode")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("CreatedAt")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ActiveAt")
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ClientIP")
	}
	if hasFields[0]&uint64(0x00000080) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AuthID")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipChatCoreTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowChatCoreTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChatCoreTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthChatCoreTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowChatCoreTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipChatCoreTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthChatCoreTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowChatCoreTypes   = fmt.Errorf("proto: integer overflow")
)

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: core.types.proto

package msg

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// TypingAction
type TypingAction int32

const (
	TypingActionTyping         TypingAction = 0
	TypingActionRecordingVoice TypingAction = 1
	TypingActionRecordingVideo TypingAction = 2
	TypingActionUploading      TypingAction = 3
	TypingActionCancel         TypingAction = 4
)

var TypingAction_name = map[int32]string{
	0: "TypingActionTyping",
	1: "TypingActionRecordingVoice",
	2: "TypingActionRecordingVideo",
	3: "TypingActionUploading",
	4: "TypingActionCancel",
}
var TypingAction_value = map[string]int32{
	"TypingActionTyping":         0,
	"TypingActionRecordingVoice": 1,
	"TypingActionRecordingVideo": 2,
	"TypingActionUploading":      3,
	"TypingActionCancel":         4,
}

func (x TypingAction) Enum() *TypingAction {
	p := new(TypingAction)
	*p = x
	return p
}
func (x TypingAction) String() string {
	return proto.EnumName(TypingAction_name, int32(x))
}
func (x *TypingAction) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TypingAction_value, data, "TypingAction")
	if err != nil {
		return err
	}
	*x = TypingAction(value)
	return nil
}
func (TypingAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_core_types_d4fac55f94c1174d, []int{0}
}

// PeerType
type PeerType int32

const (
	PeerSelf       PeerType = 0
	PeerUser       PeerType = 1
	PeerGroup      PeerType = 2
	PeerSuperGroup PeerType = 3
	PeerChannel    PeerType = 4
)

var PeerType_name = map[int32]string{
	0: "PeerSelf",
	1: "PeerUser",
	2: "PeerGroup",
	3: "PeerSuperGroup",
	4: "PeerChannel",
}
var PeerType_value = map[string]int32{
	"PeerSelf":       0,
	"PeerUser":       1,
	"PeerGroup":      2,
	"PeerSuperGroup": 3,
	"PeerChannel":    4,
}

func (x PeerType) Enum() *PeerType {
	p := new(PeerType)
	*p = x
	return p
}
func (x PeerType) String() string {
	return proto.EnumName(PeerType_name, int32(x))
}
func (x *PeerType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PeerType_value, data, "PeerType")
	if err != nil {
		return err
	}
	*x = PeerType(value)
	return nil
}
func (PeerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_core_types_d4fac55f94c1174d, []int{1}
}

// UserStatus
type UserStatus int32

const (
	UserStatusOffline   UserStatus = 0
	UserStatusOnline    UserStatus = 1
	UserStatusRecently  UserStatus = 2
	UserStatusLastWeek  UserStatus = 3
	UserStatusLastMonth UserStatus = 4
)

var UserStatus_name = map[int32]string{
	0: "UserStatusOffline",
	1: "UserStatusOnline",
	2: "UserStatusRecently",
	3: "UserStatusLastWeek",
	4: "UserStatusLastMonth",
}
var UserStatus_value = map[string]int32{
	"UserStatusOffline":   0,
	"UserStatusOnline":    1,
	"UserStatusRecently":  2,
	"UserStatusLastWeek":  3,
	"UserStatusLastMonth": 4,
}

func (x UserStatus) Enum() *UserStatus {
	p := new(UserStatus)
	*p = x
	return p
}
func (x UserStatus) String() string {
	return proto.EnumName(UserStatus_name, int32(x))
}
func (x *UserStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(UserStatus_value, data, "UserStatus")
	if err != nil {
		return err
	}
	*x = UserStatus(value)
	return nil
}
func (UserStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_core_types_d4fac55f94c1174d, []int{2}
}

// MediaType
type MediaType int32

const (
	MediaTypeEmpty    MediaType = 0
	MediaTypePhoto    MediaType = 1
	MediaTypeDocument MediaType = 2
	MediaTypeContact  MediaType = 3
)

var MediaType_name = map[int32]string{
	0: "MediaTypeEmpty",
	1: "MediaTypePhoto",
	2: "MediaTypeDocument",
	3: "MediaTypeContact",
}
var MediaType_value = map[string]int32{
	"MediaTypeEmpty":    0,
	"MediaTypePhoto":    1,
	"MediaTypeDocument": 2,
	"MediaTypeContact":  3,
}

func (x MediaType) Enum() *MediaType {
	p := new(MediaType)
	*p = x
	return p
}
func (x MediaType) String() string {
	return proto.EnumName(MediaType_name, int32(x))
}
func (x *MediaType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MediaType_value, data, "MediaType")
	if err != nil {
		return err
	}
	*x = MediaType(value)
	return nil
}
func (MediaType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_core_types_d4fac55f94c1174d, []int{3}
}

// MessageEntityType
type MessageEntityType int32

const (
	MessageEntityTypeBold    MessageEntityType = 0
	MessageEntityTypeItalic  MessageEntityType = 1
	MessageEntityTypeMention MessageEntityType = 2
	MessageEntityTypeUrl     MessageEntityType = 3
	MessageEntityTypeEmail   MessageEntityType = 4
	MessageEntityTypeHashtag MessageEntityType = 5
)

var MessageEntityType_name = map[int32]string{
	0: "MessageEntityTypeBold",
	1: "MessageEntityTypeItalic",
	2: "MessageEntityTypeMention",
	3: "MessageEntityTypeUrl",
	4: "MessageEntityTypeEmail",
	5: "MessageEntityTypeHashtag",
}
var MessageEntityType_value = map[string]int32{
	"MessageEntityTypeBold":    0,
	"MessageEntityTypeItalic":  1,
	"MessageEntityTypeMention": 2,
	"MessageEntityTypeUrl":     3,
	"MessageEntityTypeEmail":   4,
	"MessageEntityTypeHashtag": 5,
}

func (x MessageEntityType) Enum() *MessageEntityType {
	p := new(MessageEntityType)
	*p = x
	return p
}
func (x MessageEntityType) String() string {
	return proto.EnumName(MessageEntityType_name, int32(x))
}
func (x *MessageEntityType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MessageEntityType_value, data, "MessageEntityType")
	if err != nil {
		return err
	}
	*x = MessageEntityType(value)
	return nil
}
func (MessageEntityType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_core_types_d4fac55f94c1174d, []int{4}
}

// GroupFlags
type GroupFlags int32

const (
	GroupFlagsEmpty          GroupFlags = 0
	GroupFlagsCreator        GroupFlags = 1
	GroupFlagsNonParticipant GroupFlags = 2
	GroupFlagsAdmin          GroupFlags = 3
	GroupFlagsAdminsEnabled  GroupFlags = 4
	GroupFlagsDeactivated    GroupFlags = 5
)

var GroupFlags_name = map[int32]string{
	0: "GroupFlagsEmpty",
	1: "GroupFlagsCreator",
	2: "GroupFlagsNonParticipant",
	3: "GroupFlagsAdmin",
	4: "GroupFlagsAdminsEnabled",
	5: "GroupFlagsDeactivated",
}
var GroupFlags_value = map[string]int32{
	"GroupFlagsEmpty":          0,
	"GroupFlagsCreator":        1,
	"GroupFlagsNonParticipant": 2,
	"GroupFlagsAdmin":          3,
	"GroupFlagsAdminsEnabled":  4,
	"GroupFlagsDeactivated":    5,
}

func (x GroupFlags) Enum() *GroupFlags {
	p := new(GroupFlags)
	*p = x
	return p
}
func (x GroupFlags) String() string {
	return proto.EnumName(GroupFlags_name, int32(x))
}
func (x *GroupFlags) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GroupFlags_value, data, "GroupFlags")
	if err != nil {
		return err
	}
	*x = GroupFlags(value)
	return nil
}
func (GroupFlags) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_core_types_d4fac55f94c1174d, []int{5}
}

// ParticipantType
type ParticipantType int32

const (
	ParticipantTypeMember  ParticipantType = 0
	ParticipantTypeAdmin   ParticipantType = 1
	ParticipantTypeCreator ParticipantType = 2
)

var ParticipantType_name = map[int32]string{
	0: "ParticipantTypeMember",
	1: "ParticipantTypeAdmin",
	2: "ParticipantTypeCreator",
}
var ParticipantType_value = map[string]int32{
	"ParticipantTypeMember":  0,
	"ParticipantTypeAdmin":   1,
	"ParticipantTypeCreator": 2,
}

func (x ParticipantType) Enum() *ParticipantType {
	p := new(ParticipantType)
	*p = x
	return p
}
func (x ParticipantType) String() string {
	return proto.EnumName(ParticipantType_name, int32(x))
}
func (x *ParticipantType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ParticipantType_value, data, "ParticipantType")
	if err != nil {
		return err
	}
	*x = ParticipantType(value)
	return nil
}
func (ParticipantType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_core_types_d4fac55f94c1174d, []int{6}
}

// Dialog
type Dialog struct {
	PeerID          int64               `protobuf:"varint,1,req,name=PeerID" json:"PeerID"`
	PeerType        int32               `protobuf:"varint,2,req,name=PeerType" json:"PeerType"`
	TopMessageID    int64               `protobuf:"varint,3,req,name=TopMessageID" json:"TopMessageID"`
	ReadInboxMaxID  int64               `protobuf:"varint,4,req,name=ReadInboxMaxID" json:"ReadInboxMaxID"`
	ReadOutboxMaxID int64               `protobuf:"varint,5,req,name=ReadOutboxMaxID" json:"ReadOutboxMaxID"`
	UnreadCount     int32               `protobuf:"varint,6,req,name=UnreadCount" json:"UnreadCount"`
	AccessHash      uint64              `protobuf:"fixed64,7,req,name=AccessHash" json:"AccessHash"`
	NotifySettings  *PeerNotifySettings `protobuf:"bytes,8,opt,name=NotifySettings" json:"NotifySettings,omitempty"`
	MentionedCount  int32               `protobuf:"varint,9,opt,name=MentionedCount" json:"MentionedCount"`
}

func (m *Dialog) Reset()         { *m = Dialog{} }
func (m *Dialog) String() string { return proto.CompactTextString(m) }
func (*Dialog) ProtoMessage()    {}
func (*Dialog) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_d4fac55f94c1174d, []int{0}
}
func (m *Dialog) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dialog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dialog.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Dialog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dialog.Merge(dst, src)
}
func (m *Dialog) XXX_Size() int {
	return m.Size()
}
func (m *Dialog) XXX_DiscardUnknown() {
	xxx_messageInfo_Dialog.DiscardUnknown(m)
}

var xxx_messageInfo_Dialog proto.InternalMessageInfo

func (m *Dialog) GetPeerID() int64 {
	if m != nil {
		return m.PeerID
	}
	return 0
}

func (m *Dialog) GetPeerType() int32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *Dialog) GetTopMessageID() int64 {
	if m != nil {
		return m.TopMessageID
	}
	return 0
}

func (m *Dialog) GetReadInboxMaxID() int64 {
	if m != nil {
		return m.ReadInboxMaxID
	}
	return 0
}

func (m *Dialog) GetReadOutboxMaxID() int64 {
	if m != nil {
		return m.ReadOutboxMaxID
	}
	return 0
}

func (m *Dialog) GetUnreadCount() int32 {
	if m != nil {
		return m.UnreadCount
	}
	return 0
}

func (m *Dialog) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *Dialog) GetNotifySettings() *PeerNotifySettings {
	if m != nil {
		return m.NotifySettings
	}
	return nil
}

func (m *Dialog) GetMentionedCount() int32 {
	if m != nil {
		return m.MentionedCount
	}
	return 0
}

// Peer
type Peer struct {
	ID         int64  `protobuf:"varint,1,req,name=ID" json:"ID"`
	Type       int32  `protobuf:"varint,2,req,name=Type" json:"Type"`
	AccessHash uint64 `protobuf:"fixed64,3,req,name=AccessHash" json:"AccessHash"`
}

func (m *Peer) Reset()         { *m = Peer{} }
func (m *Peer) String() string { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()    {}
func (*Peer) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_d4fac55f94c1174d, []int{1}
}
func (m *Peer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Peer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Peer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Peer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Peer.Merge(dst, src)
}
func (m *Peer) XXX_Size() int {
	return m.Size()
}
func (m *Peer) XXX_DiscardUnknown() {
	xxx_messageInfo_Peer.DiscardUnknown(m)
}

var xxx_messageInfo_Peer proto.InternalMessageInfo

func (m *Peer) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Peer) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Peer) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// InputPeer
type InputPeer struct {
	ID         int64    `protobuf:"varint,1,req,name=ID" json:"ID"`
	Type       PeerType `protobuf:"varint,2,req,name=Type,enum=msg.PeerType" json:"Type"`
	AccessHash uint64   `protobuf:"fixed64,3,req,name=AccessHash" json:"AccessHash"`
}

func (m *InputPeer) Reset()         { *m = InputPeer{} }
func (m *InputPeer) String() string { return proto.CompactTextString(m) }
func (*InputPeer) ProtoMessage()    {}
func (*InputPeer) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_d4fac55f94c1174d, []int{2}
}
func (m *InputPeer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputPeer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputPeer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InputPeer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputPeer.Merge(dst, src)
}
func (m *InputPeer) XXX_Size() int {
	return m.Size()
}
func (m *InputPeer) XXX_DiscardUnknown() {
	xxx_messageInfo_InputPeer.DiscardUnknown(m)
}

var xxx_messageInfo_InputPeer proto.InternalMessageInfo

func (m *InputPeer) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *InputPeer) GetType() PeerType {
	if m != nil {
		return m.Type
	}
	return PeerSelf
}

func (m *InputPeer) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// InputPeer
type InputUser struct {
	UserID     int64  `protobuf:"varint,1,req,name=UserID" json:"UserID"`
	AccessHash uint64 `protobuf:"fixed64,2,req,name=AccessHash" json:"AccessHash"`
}

func (m *InputUser) Reset()         { *m = InputUser{} }
func (m *InputUser) String() string { return proto.CompactTextString(m) }
func (*InputUser) ProtoMessage()    {}
func (*InputUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_d4fac55f94c1174d, []int{3}
}
func (m *InputUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InputUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputUser.Merge(dst, src)
}
func (m *InputUser) XXX_Size() int {
	return m.Size()
}
func (m *InputUser) XXX_DiscardUnknown() {
	xxx_messageInfo_InputUser.DiscardUnknown(m)
}

var xxx_messageInfo_InputUser proto.InternalMessageInfo

func (m *InputUser) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *InputUser) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// User
type User struct {
	ID         int64      `protobuf:"varint,1,req,name=ID" json:"ID"`
	FirstName  string     `protobuf:"bytes,2,req,name=FirstName" json:"FirstName"`
	LastName   string     `protobuf:"bytes,3,req,name=LastName" json:"LastName"`
	Username   string     `protobuf:"bytes,4,req,name=Username" json:"Username"`
	Status     UserStatus `protobuf:"varint,5,req,name=Status,enum=msg.UserStatus" json:"Status"`
	Restricted bool       `protobuf:"varint,6,req,name=Restricted" json:"Restricted"`
	AccessHash uint64     `protobuf:"fixed64,7,req,name=AccessHash" json:"AccessHash"`
}

func (m *User) Reset()         { *m = User{} }
func (m *User) String() string { return proto.CompactTextString(m) }
func (*User) ProtoMessage()    {}
func (*User) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_d4fac55f94c1174d, []int{4}
}
func (m *User) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *User) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_User.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *User) XXX_Merge(src proto.Message) {
	xxx_messageInfo_User.Merge(dst, src)
}
func (m *User) XXX_Size() int {
	return m.Size()
}
func (m *User) XXX_DiscardUnknown() {
	xxx_messageInfo_User.DiscardUnknown(m)
}

var xxx_messageInfo_User proto.InternalMessageInfo

func (m *User) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *User) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *User) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *User) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *User) GetStatus() UserStatus {
	if m != nil {
		return m.Status
	}
	return UserStatusOffline
}

func (m *User) GetRestricted() bool {
	if m != nil {
		return m.Restricted
	}
	return false
}

func (m *User) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// ContactUser
type ContactUser struct {
	ID         int64  `protobuf:"varint,1,req,name=ID" json:"ID"`
	FirstName  string `protobuf:"bytes,2,req,name=FirstName" json:"FirstName"`
	LastName   string `protobuf:"bytes,3,req,name=LastName" json:"LastName"`
	AccessHash uint64 `protobuf:"fixed64,4,req,name=AccessHash" json:"AccessHash"`
	Phone      string `protobuf:"bytes,5,req,name=Phone" json:"Phone"`
	Username   string `protobuf:"bytes,6,req,name=Username" json:"Username"`
	ClientID   int64  `protobuf:"varint,7,req,name=ClientID" json:"ClientID"`
}

func (m *ContactUser) Reset()         { *m = ContactUser{} }
func (m *ContactUser) String() string { return proto.CompactTextString(m) }
func (*ContactUser) ProtoMessage()    {}
func (*ContactUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_d4fac55f94c1174d, []int{5}
}
func (m *ContactUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContactUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContactUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ContactUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContactUser.Merge(dst, src)
}
func (m *ContactUser) XXX_Size() int {
	return m.Size()
}
func (m *ContactUser) XXX_DiscardUnknown() {
	xxx_messageInfo_ContactUser.DiscardUnknown(m)
}

var xxx_messageInfo_ContactUser proto.InternalMessageInfo

func (m *ContactUser) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ContactUser) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *ContactUser) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *ContactUser) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *ContactUser) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *ContactUser) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *ContactUser) GetClientID() int64 {
	if m != nil {
		return m.ClientID
	}
	return 0
}

// UserMessage
type UserMessage struct {
	ID                  int64            `protobuf:"varint,1,req,name=ID" json:"ID"`
	PeerID              int64            `protobuf:"varint,2,req,name=PeerID" json:"PeerID"`
	PeerType            int32            `protobuf:"varint,3,req,name=PeerType" json:"PeerType"`
	CreatedOn           int64            `protobuf:"varint,4,req,name=CreatedOn" json:"CreatedOn"`
	EditedOn            int64            `protobuf:"varint,5,req,name=EditedOn" json:"EditedOn"`
	FwdSenderID         int64            `protobuf:"varint,6,req,name=FwdSenderID" json:"FwdSenderID"`
	FwdChannelID        int64            `protobuf:"varint,7,req,name=FwdChannelID" json:"FwdChannelID"`
	FwdChannelMessageID int64            `protobuf:"varint,8,req,name=FwdChannelMessageID" json:"FwdChannelMessageID"`
	Flags               int32            `protobuf:"varint,9,req,name=Flags" json:"Flags"`
	MessageType         int64            `protobuf:"varint,10,req,name=MessageType" json:"MessageType"`
	Body                string           `protobuf:"bytes,11,req,name=Body" json:"Body"`
	SenderID            int64            `protobuf:"varint,12,req,name=SenderID" json:"SenderID"`
	ContentRead         bool             `protobuf:"varint,13,req,name=ContentRead" json:"ContentRead"`
	Inbox               bool             `protobuf:"varint,14,req,name=Inbox" json:"Inbox"`
	ReplyTo             int64            `protobuf:"varint,15,req,name=ReplyTo" json:"ReplyTo"`
	MessageAction       int32            `protobuf:"varint,16,opt,name=MessageAction" json:"MessageAction"`
	MessageActionData   []byte           `protobuf:"bytes,17,opt,name=MessageActionData" json:"MessageActionData"`
	Entities            []*MessageEntity `protobuf:"bytes,18,rep,name=Entities" json:"Entities,omitempty"`
	MediaType           MediaType        `protobuf:"varint,19,opt,name=MediaType,enum=msg.MediaType" json:"MediaType"`
	Media               []byte           `protobuf:"bytes,20,opt,name=Media" json:"Media"`
}

func (m *UserMessage) Reset()         { *m = UserMessage{} }
func (m *UserMessage) String() string { return proto.CompactTextString(m) }
func (*UserMessage) ProtoMessage()    {}
func (*UserMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_d4fac55f94c1174d, []int{6}
}
func (m *UserMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UserMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserMessage.Merge(dst, src)
}
func (m *UserMessage) XXX_Size() int {
	return m.Size()
}
func (m *UserMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_UserMessage.DiscardUnknown(m)
}

var xxx_messageInfo_UserMessage proto.InternalMessageInfo

func (m *UserMessage) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UserMessage) GetPeerID() int64 {
	if m != nil {
		return m.PeerID
	}
	return 0
}

func (m *UserMessage) GetPeerType() int32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *UserMessage) GetCreatedOn() int64 {
	if m != nil {
		return m.CreatedOn
	}
	return 0
}

func (m *UserMessage) GetEditedOn() int64 {
	if m != nil {
		return m.EditedOn
	}
	return 0
}

func (m *UserMessage) GetFwdSenderID() int64 {
	if m != nil {
		return m.FwdSenderID
	}
	return 0
}

func (m *UserMessage) GetFwdChannelID() int64 {
	if m != nil {
		return m.FwdChannelID
	}
	return 0
}

func (m *UserMessage) GetFwdChannelMessageID() int64 {
	if m != nil {
		return m.FwdChannelMessageID
	}
	return 0
}

func (m *UserMessage) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *UserMessage) GetMessageType() int64 {
	if m != nil {
		return m.MessageType
	}
	return 0
}

func (m *UserMessage) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

func (m *UserMessage) GetSenderID() int64 {
	if m != nil {
		return m.SenderID
	}
	return 0
}

func (m *UserMessage) GetContentRead() bool {
	if m != nil {
		return m.ContentRead
	}
	return false
}

func (m *UserMessage) GetInbox() bool {
	if m != nil {
		return m.Inbox
	}
	return false
}

func (m *UserMessage) GetReplyTo() int64 {
	if m != nil {
		return m.ReplyTo
	}
	return 0
}

func (m *UserMessage) GetMessageAction() int32 {
	if m != nil {
		return m.MessageAction
	}
	return 0
}

func (m *UserMessage) GetMessageActionData() []byte {
	if m != nil {
		return m.MessageActionData
	}
	return nil
}

func (m *UserMessage) GetEntities() []*MessageEntity {
	if m != nil {
		return m.Entities
	}
	return nil
}

func (m *UserMessage) GetMediaType() MediaType {
	if m != nil {
		return m.MediaType
	}
	return MediaTypeEmpty
}

func (m *UserMessage) GetMedia() []byte {
	if m != nil {
		return m.Media
	}
	return nil
}

// MessageEntity
type MessageEntity struct {
	Type   MessageEntityType `protobuf:"varint,1,req,name=Type,enum=msg.MessageEntityType" json:"Type"`
	Offset int32             `protobuf:"varint,2,req,name=Offset" json:"Offset"`
	Length int32             `protobuf:"varint,3,req,name=Length" json:"Length"`
	UserID int64             `protobuf:"varint,4,opt,name=UserID" json:"UserID"`
}

func (m *MessageEntity) Reset()         { *m = MessageEntity{} }
func (m *MessageEntity) String() string { return proto.CompactTextString(m) }
func (*MessageEntity) ProtoMessage()    {}
func (*MessageEntity) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_d4fac55f94c1174d, []int{7}
}
func (m *MessageEntity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageEntity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageEntity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MessageEntity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageEntity.Merge(dst, src)
}
func (m *MessageEntity) XXX_Size() int {
	return m.Size()
}
func (m *MessageEntity) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageEntity.DiscardUnknown(m)
}

var xxx_messageInfo_MessageEntity proto.InternalMessageInfo

func (m *MessageEntity) GetType() MessageEntityType {
	if m != nil {
		return m.Type
	}
	return MessageEntityTypeBold
}

func (m *MessageEntity) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *MessageEntity) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *MessageEntity) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

// RSAPublicKey
type RSAPublicKey struct {
	FingerPrint int64  `protobuf:"varint,1,req,name=FingerPrint" json:"FingerPrint"`
	N           string `protobuf:"bytes,2,req,name=N" json:"N"`
	E           uint32 `protobuf:"varint,3,req,name=E" json:"E"`
}

func (m *RSAPublicKey) Reset()         { *m = RSAPublicKey{} }
func (m *RSAPublicKey) String() string { return proto.CompactTextString(m) }
func (*RSAPublicKey) ProtoMessage()    {}
func (*RSAPublicKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_d4fac55f94c1174d, []int{8}
}
func (m *RSAPublicKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RSAPublicKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RSAPublicKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RSAPublicKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RSAPublicKey.Merge(dst, src)
}
func (m *RSAPublicKey) XXX_Size() int {
	return m.Size()
}
func (m *RSAPublicKey) XXX_DiscardUnknown() {
	xxx_messageInfo_RSAPublicKey.DiscardUnknown(m)
}

var xxx_messageInfo_RSAPublicKey proto.InternalMessageInfo

func (m *RSAPublicKey) GetFingerPrint() int64 {
	if m != nil {
		return m.FingerPrint
	}
	return 0
}

func (m *RSAPublicKey) GetN() string {
	if m != nil {
		return m.N
	}
	return ""
}

func (m *RSAPublicKey) GetE() uint32 {
	if m != nil {
		return m.E
	}
	return 0
}

// DHGroup
type DHGroup struct {
	FingerPrint int64  `protobuf:"varint,1,req,name=FingerPrint" json:"FingerPrint"`
	Prime       string `protobuf:"bytes,2,req,name=Prime" json:"Prime"`
	Gen         int32  `protobuf:"varint,3,req,name=Gen" json:"Gen"`
}

func (m *DHGroup) Reset()         { *m = DHGroup{} }
func (m *DHGroup) String() string { return proto.CompactTextString(m) }
func (*DHGroup) ProtoMessage()    {}
func (*DHGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_d4fac55f94c1174d, []int{9}
}
func (m *DHGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DHGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DHGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHGroup.Merge(dst, src)
}
func (m *DHGroup) XXX_Size() int {
	return m.Size()
}
func (m *DHGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_DHGroup.DiscardUnknown(m)
}

var xxx_messageInfo_DHGroup proto.InternalMessageInfo

func (m *DHGroup) GetFingerPrint() int64 {
	if m != nil {
		return m.FingerPrint
	}
	return 0
}

func (m *DHGroup) GetPrime() string {
	if m != nil {
		return m.Prime
	}
	return ""
}

func (m *DHGroup) GetGen() int32 {
	if m != nil {
		return m.Gen
	}
	return 0
}

// PhoneContact
type PhoneContact struct {
	ClientID  int64  `protobuf:"varint,1,req,name=ClientID" json:"ClientID"`
	FirstName string `protobuf:"bytes,2,req,name=FirstName" json:"FirstName"`
	LastName  string `protobuf:"bytes,3,req,name=LastName" json:"LastName"`
	Phone     string `protobuf:"bytes,4,req,name=Phone" json:"Phone"`
}

func (m *PhoneContact) Reset()         { *m = PhoneContact{} }
func (m *PhoneContact) String() string { return proto.CompactTextString(m) }
func (*PhoneContact) ProtoMessage()    {}
func (*PhoneContact) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_d4fac55f94c1174d, []int{10}
}
func (m *PhoneContact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhoneContact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhoneContact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PhoneContact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhoneContact.Merge(dst, src)
}
func (m *PhoneContact) XXX_Size() int {
	return m.Size()
}
func (m *PhoneContact) XXX_DiscardUnknown() {
	xxx_messageInfo_PhoneContact.DiscardUnknown(m)
}

var xxx_messageInfo_PhoneContact proto.InternalMessageInfo

func (m *PhoneContact) GetClientID() int64 {
	if m != nil {
		return m.ClientID
	}
	return 0
}

func (m *PhoneContact) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *PhoneContact) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *PhoneContact) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

// PeerNotifySettings
type PeerNotifySettings struct {
	Flags     int32  `protobuf:"varint,1,req,name=Flags" json:"Flags"`
	MuteUntil int64  `protobuf:"varint,2,opt,name=MuteUntil" json:"MuteUntil"`
	Sound     string `protobuf:"bytes,3,opt,name=Sound" json:"Sound"`
}

func (m *PeerNotifySettings) Reset()         { *m = PeerNotifySettings{} }
func (m *PeerNotifySettings) String() string { return proto.CompactTextString(m) }
func (*PeerNotifySettings) ProtoMessage()    {}
func (*PeerNotifySettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_d4fac55f94c1174d, []int{11}
}
func (m *PeerNotifySettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerNotifySettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerNotifySettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PeerNotifySettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerNotifySettings.Merge(dst, src)
}
func (m *PeerNotifySettings) XXX_Size() int {
	return m.Size()
}
func (m *PeerNotifySettings) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerNotifySettings.DiscardUnknown(m)
}

var xxx_messageInfo_PeerNotifySettings proto.InternalMessageInfo

func (m *PeerNotifySettings) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *PeerNotifySettings) GetMuteUntil() int64 {
	if m != nil {
		return m.MuteUntil
	}
	return 0
}

func (m *PeerNotifySettings) GetSound() string {
	if m != nil {
		return m.Sound
	}
	return ""
}

// InputFile
type InputFile struct {
	FileID      int64  `protobuf:"varint,1,req,name=FileID" json:"FileID"`
	TotalParts  int32  `protobuf:"varint,2,req,name=TotalParts" json:"TotalParts"`
	FileName    string `protobuf:"bytes,3,req,name=FileName" json:"FileName"`
	MD5Checksum string `protobuf:"bytes,4,req,name=MD5Checksum" json:"MD5Checksum"`
	ClusterID   int32  `protobuf:"varint,5,req,name=ClusterID" json:"ClusterID"`
}

func (m *InputFile) Reset()         { *m = InputFile{} }
func (m *InputFile) String() string { return proto.CompactTextString(m) }
func (*InputFile) ProtoMessage()    {}
func (*InputFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_d4fac55f94c1174d, []int{12}
}
func (m *InputFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InputFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputFile.Merge(dst, src)
}
func (m *InputFile) XXX_Size() int {
	return m.Size()
}
func (m *InputFile) XXX_DiscardUnknown() {
	xxx_messageInfo_InputFile.DiscardUnknown(m)
}

var xxx_messageInfo_InputFile proto.InternalMessageInfo

func (m *InputFile) GetFileID() int64 {
	if m != nil {
		return m.FileID
	}
	return 0
}

func (m *InputFile) GetTotalParts() int32 {
	if m != nil {
		return m.TotalParts
	}
	return 0
}

func (m *InputFile) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *InputFile) GetMD5Checksum() string {
	if m != nil {
		return m.MD5Checksum
	}
	return ""
}

func (m *InputFile) GetClusterID() int32 {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

// Group
type Group struct {
	ID           int64        `protobuf:"varint,1,req,name=ID" json:"ID"`
	Title        string       `protobuf:"bytes,2,req,name=Title" json:"Title"`
	CreatedOn    int64        `protobuf:"varint,3,req,name=CreatedOn" json:"CreatedOn"`
	Participants int32        `protobuf:"varint,4,req,name=Participants" json:"Participants"`
	EditedOn     int64        `protobuf:"varint,5,opt,name=EditedOn" json:"EditedOn"`
	Flags        []GroupFlags `protobuf:"varint,6,rep,name=Flags,enum=msg.GroupFlags" json:"Flags,omitempty"`
}

func (m *Group) Reset()         { *m = Group{} }
func (m *Group) String() string { return proto.CompactTextString(m) }
func (*Group) ProtoMessage()    {}
func (*Group) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_d4fac55f94c1174d, []int{13}
}
func (m *Group) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Group) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Group.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Group) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Group.Merge(dst, src)
}
func (m *Group) XXX_Size() int {
	return m.Size()
}
func (m *Group) XXX_DiscardUnknown() {
	xxx_messageInfo_Group.DiscardUnknown(m)
}

var xxx_messageInfo_Group proto.InternalMessageInfo

func (m *Group) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Group) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Group) GetCreatedOn() int64 {
	if m != nil {
		return m.CreatedOn
	}
	return 0
}

func (m *Group) GetParticipants() int32 {
	if m != nil {
		return m.Participants
	}
	return 0
}

func (m *Group) GetEditedOn() int64 {
	if m != nil {
		return m.EditedOn
	}
	return 0
}

func (m *Group) GetFlags() []GroupFlags {
	if m != nil {
		return m.Flags
	}
	return nil
}

// GroupFull
type GroupFull struct {
	Group          *Group              `protobuf:"bytes,1,req,name=Group" json:"Group,omitempty"`
	Users          []*User             `protobuf:"bytes,2,rep,name=Users" json:"Users,omitempty"`
	Participants   []*GroupParticipant `protobuf:"bytes,3,rep,name=Participants" json:"Participants,omitempty"`
	NotifySettings *PeerNotifySettings `protobuf:"bytes,4,req,name=NotifySettings" json:"NotifySettings,omitempty"`
}

func (m *GroupFull) Reset()         { *m = GroupFull{} }
func (m *GroupFull) String() string { return proto.CompactTextString(m) }
func (*GroupFull) ProtoMessage()    {}
func (*GroupFull) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_d4fac55f94c1174d, []int{14}
}
func (m *GroupFull) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupFull) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupFull.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GroupFull) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupFull.Merge(dst, src)
}
func (m *GroupFull) XXX_Size() int {
	return m.Size()
}
func (m *GroupFull) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupFull.DiscardUnknown(m)
}

var xxx_messageInfo_GroupFull proto.InternalMessageInfo

func (m *GroupFull) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *GroupFull) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *GroupFull) GetParticipants() []*GroupParticipant {
	if m != nil {
		return m.Participants
	}
	return nil
}

func (m *GroupFull) GetNotifySettings() *PeerNotifySettings {
	if m != nil {
		return m.NotifySettings
	}
	return nil
}

// GroupParticipant
type GroupParticipant struct {
	UserID     int64           `protobuf:"varint,1,req,name=UserID" json:"UserID"`
	FirstName  string          `protobuf:"bytes,2,req,name=FirstName" json:"FirstName"`
	LastName   string          `protobuf:"bytes,3,req,name=LastName" json:"LastName"`
	Type       ParticipantType `protobuf:"varint,4,req,name=Type,enum=msg.ParticipantType" json:"Type"`
	AccessHash uint64          `protobuf:"varint,5,req,name=AccessHash" json:"AccessHash"`
	Username   string          `protobuf:"bytes,6,req,name=Username" json:"Username"`
}

func (m *GroupParticipant) Reset()         { *m = GroupParticipant{} }
func (m *GroupParticipant) String() string { return proto.CompactTextString(m) }
func (*GroupParticipant) ProtoMessage()    {}
func (*GroupParticipant) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_d4fac55f94c1174d, []int{15}
}
func (m *GroupParticipant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupParticipant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupParticipant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GroupParticipant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupParticipant.Merge(dst, src)
}
func (m *GroupParticipant) XXX_Size() int {
	return m.Size()
}
func (m *GroupParticipant) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupParticipant.DiscardUnknown(m)
}

var xxx_messageInfo_GroupParticipant proto.InternalMessageInfo

func (m *GroupParticipant) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *GroupParticipant) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *GroupParticipant) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *GroupParticipant) GetType() ParticipantType {
	if m != nil {
		return m.Type
	}
	return ParticipantTypeMember
}

func (m *GroupParticipant) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *GroupParticipant) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

// Cluster
type Cluster struct {
	ID       int32  `protobuf:"varint,1,req,name=ID" json:"ID"`
	IP       string `protobuf:"bytes,2,req,name=IP" json:"IP"`
	Domain   string `protobuf:"bytes,3,req,name=Domain" json:"Domain"`
	Location string `protobuf:"bytes,4,req,name=Location" json:"Location"`
}

func (m *Cluster) Reset()         { *m = Cluster{} }
func (m *Cluster) String() string { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()    {}
func (*Cluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_d4fac55f94c1174d, []int{16}
}
func (m *Cluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Cluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster.Merge(dst, src)
}
func (m *Cluster) XXX_Size() int {
	return m.Size()
}
func (m *Cluster) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster proto.InternalMessageInfo

func (m *Cluster) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Cluster) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *Cluster) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *Cluster) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func init() {
	proto.RegisterType((*Dialog)(nil), "msg.Dialog")
	proto.RegisterType((*Peer)(nil), "msg.Peer")
	proto.RegisterType((*InputPeer)(nil), "msg.InputPeer")
	proto.RegisterType((*InputUser)(nil), "msg.InputUser")
	proto.RegisterType((*User)(nil), "msg.User")
	proto.RegisterType((*ContactUser)(nil), "msg.ContactUser")
	proto.RegisterType((*UserMessage)(nil), "msg.UserMessage")
	proto.RegisterType((*MessageEntity)(nil), "msg.MessageEntity")
	proto.RegisterType((*RSAPublicKey)(nil), "msg.RSAPublicKey")
	proto.RegisterType((*DHGroup)(nil), "msg.DHGroup")
	proto.RegisterType((*PhoneContact)(nil), "msg.PhoneContact")
	proto.RegisterType((*PeerNotifySettings)(nil), "msg.PeerNotifySettings")
	proto.RegisterType((*InputFile)(nil), "msg.InputFile")
	proto.RegisterType((*Group)(nil), "msg.Group")
	proto.RegisterType((*GroupFull)(nil), "msg.GroupFull")
	proto.RegisterType((*GroupParticipant)(nil), "msg.GroupParticipant")
	proto.RegisterType((*Cluster)(nil), "msg.Cluster")
	proto.RegisterEnum("msg.TypingAction", TypingAction_name, TypingAction_value)
	proto.RegisterEnum("msg.PeerType", PeerType_name, PeerType_value)
	proto.RegisterEnum("msg.UserStatus", UserStatus_name, UserStatus_value)
	proto.RegisterEnum("msg.MediaType", MediaType_name, MediaType_value)
	proto.RegisterEnum("msg.MessageEntityType", MessageEntityType_name, MessageEntityType_value)
	proto.RegisterEnum("msg.GroupFlags", GroupFlags_name, GroupFlags_value)
	proto.RegisterEnum("msg.ParticipantType", ParticipantType_name, ParticipantType_value)
}
func (m *Dialog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dialog) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.PeerID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.PeerType))
	dAtA[i] = 0x18
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.TopMessageID))
	dAtA[i] = 0x20
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.ReadInboxMaxID))
	dAtA[i] = 0x28
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.ReadOutboxMaxID))
	dAtA[i] = 0x30
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.UnreadCount))
	dAtA[i] = 0x39
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i += 8
	if m.NotifySettings != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCoreTypes(dAtA, i, uint64(m.NotifySettings.Size()))
		n1, err := m.NotifySettings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	dAtA[i] = 0x48
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.MentionedCount))
	return i, nil
}

func (m *Peer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Peer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x19
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i += 8
	return i, nil
}

func (m *InputPeer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputPeer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x19
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i += 8
	return i, nil
}

func (m *InputUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.UserID))
	dAtA[i] = 0x11
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i += 8
	return i, nil
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.FirstName)))
	i += copy(dAtA[i:], m.FirstName)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.LastName)))
	i += copy(dAtA[i:], m.LastName)
	dAtA[i] = 0x22
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.Username)))
	i += copy(dAtA[i:], m.Username)
	dAtA[i] = 0x28
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.Status))
	dAtA[i] = 0x30
	i++
	if m.Restricted {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x39
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i += 8
	return i, nil
}

func (m *ContactUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContactUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.FirstName)))
	i += copy(dAtA[i:], m.FirstName)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.LastName)))
	i += copy(dAtA[i:], m.LastName)
	dAtA[i] = 0x21
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i += 8
	dAtA[i] = 0x2a
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.Phone)))
	i += copy(dAtA[i:], m.Phone)
	dAtA[i] = 0x32
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.Username)))
	i += copy(dAtA[i:], m.Username)
	dAtA[i] = 0x38
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.ClientID))
	return i, nil
}

func (m *UserMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.PeerID))
	dAtA[i] = 0x18
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.PeerType))
	dAtA[i] = 0x20
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.CreatedOn))
	dAtA[i] = 0x28
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.EditedOn))
	dAtA[i] = 0x30
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.FwdSenderID))
	dAtA[i] = 0x38
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.FwdChannelID))
	dAtA[i] = 0x40
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.FwdChannelMessageID))
	dAtA[i] = 0x48
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.Flags))
	dAtA[i] = 0x50
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.MessageType))
	dAtA[i] = 0x5a
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.Body)))
	i += copy(dAtA[i:], m.Body)
	dAtA[i] = 0x60
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.SenderID))
	dAtA[i] = 0x68
	i++
	if m.ContentRead {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x70
	i++
	if m.Inbox {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x78
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.ReplyTo))
	dAtA[i] = 0x80
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.MessageAction))
	if m.MessageActionData != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.MessageActionData)))
		i += copy(dAtA[i:], m.MessageActionData)
	}
	if len(m.Entities) > 0 {
		for _, msg := range m.Entities {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCoreTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x98
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.MediaType))
	if m.Media != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.Media)))
		i += copy(dAtA[i:], m.Media)
	}
	return i, nil
}

func (m *MessageEntity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageEntity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x10
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.Offset))
	dAtA[i] = 0x18
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.Length))
	dAtA[i] = 0x20
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.UserID))
	return i, nil
}

func (m *RSAPublicKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RSAPublicKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.FingerPrint))
	dAtA[i] = 0x12
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.N)))
	i += copy(dAtA[i:], m.N)
	dAtA[i] = 0x18
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.E))
	return i, nil
}

func (m *DHGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.FingerPrint))
	dAtA[i] = 0x12
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.Prime)))
	i += copy(dAtA[i:], m.Prime)
	dAtA[i] = 0x18
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.Gen))
	return i, nil
}

func (m *PhoneContact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhoneContact) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.ClientID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.FirstName)))
	i += copy(dAtA[i:], m.FirstName)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.LastName)))
	i += copy(dAtA[i:], m.LastName)
	dAtA[i] = 0x22
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.Phone)))
	i += copy(dAtA[i:], m.Phone)
	return i, nil
}

func (m *PeerNotifySettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerNotifySettings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.Flags))
	dAtA[i] = 0x10
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.MuteUntil))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.Sound)))
	i += copy(dAtA[i:], m.Sound)
	return i, nil
}

func (m *InputFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputFile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.FileID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.TotalParts))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.FileName)))
	i += copy(dAtA[i:], m.FileName)
	dAtA[i] = 0x22
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.MD5Checksum)))
	i += copy(dAtA[i:], m.MD5Checksum)
	dAtA[i] = 0x28
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.ClusterID))
	return i, nil
}

func (m *Group) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Group) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.Title)))
	i += copy(dAtA[i:], m.Title)
	dAtA[i] = 0x18
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.CreatedOn))
	dAtA[i] = 0x20
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.Participants))
	dAtA[i] = 0x28
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.EditedOn))
	if len(m.Flags) > 0 {
		for _, num := range m.Flags {
			dAtA[i] = 0x30
			i++
			i = encodeVarintCoreTypes(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *GroupFull) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupFull) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Group == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("Group")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCoreTypes(dAtA, i, uint64(m.Group.Size()))
		n2, err := m.Group.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Users) > 0 {
		for _, msg := range m.Users {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCoreTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Participants) > 0 {
		for _, msg := range m.Participants {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCoreTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.NotifySettings == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("NotifySettings")
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCoreTypes(dAtA, i, uint64(m.NotifySettings.Size()))
		n3, err := m.NotifySettings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *GroupParticipant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupParticipant) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.UserID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.FirstName)))
	i += copy(dAtA[i:], m.FirstName)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.LastName)))
	i += copy(dAtA[i:], m.LastName)
	dAtA[i] = 0x20
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x28
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.AccessHash))
	dAtA[i] = 0x32
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.Username)))
	i += copy(dAtA[i:], m.Username)
	return i, nil
}

func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.IP)))
	i += copy(dAtA[i:], m.IP)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.Domain)))
	i += copy(dAtA[i:], m.Domain)
	dAtA[i] = 0x22
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.Location)))
	i += copy(dAtA[i:], m.Location)
	return i, nil
}

func encodeVarintCoreTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Dialog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.PeerID))
	n += 1 + sovCoreTypes(uint64(m.PeerType))
	n += 1 + sovCoreTypes(uint64(m.TopMessageID))
	n += 1 + sovCoreTypes(uint64(m.ReadInboxMaxID))
	n += 1 + sovCoreTypes(uint64(m.ReadOutboxMaxID))
	n += 1 + sovCoreTypes(uint64(m.UnreadCount))
	n += 9
	if m.NotifySettings != nil {
		l = m.NotifySettings.Size()
		n += 1 + l + sovCoreTypes(uint64(l))
	}
	n += 1 + sovCoreTypes(uint64(m.MentionedCount))
	return n
}

func (m *Peer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.ID))
	n += 1 + sovCoreTypes(uint64(m.Type))
	n += 9
	return n
}

func (m *InputPeer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.ID))
	n += 1 + sovCoreTypes(uint64(m.Type))
	n += 9
	return n
}

func (m *InputUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.UserID))
	n += 9
	return n
}

func (m *User) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.ID))
	l = len(m.FirstName)
	n += 1 + l + sovCoreTypes(uint64(l))
	l = len(m.LastName)
	n += 1 + l + sovCoreTypes(uint64(l))
	l = len(m.Username)
	n += 1 + l + sovCoreTypes(uint64(l))
	n += 1 + sovCoreTypes(uint64(m.Status))
	n += 2
	n += 9
	return n
}

func (m *ContactUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.ID))
	l = len(m.FirstName)
	n += 1 + l + sovCoreTypes(uint64(l))
	l = len(m.LastName)
	n += 1 + l + sovCoreTypes(uint64(l))
	n += 9
	l = len(m.Phone)
	n += 1 + l + sovCoreTypes(uint64(l))
	l = len(m.Username)
	n += 1 + l + sovCoreTypes(uint64(l))
	n += 1 + sovCoreTypes(uint64(m.ClientID))
	return n
}

func (m *UserMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.ID))
	n += 1 + sovCoreTypes(uint64(m.PeerID))
	n += 1 + sovCoreTypes(uint64(m.PeerType))
	n += 1 + sovCoreTypes(uint64(m.CreatedOn))
	n += 1 + sovCoreTypes(uint64(m.EditedOn))
	n += 1 + sovCoreTypes(uint64(m.FwdSenderID))
	n += 1 + sovCoreTypes(uint64(m.FwdChannelID))
	n += 1 + sovCoreTypes(uint64(m.FwdChannelMessageID))
	n += 1 + sovCoreTypes(uint64(m.Flags))
	n += 1 + sovCoreTypes(uint64(m.MessageType))
	l = len(m.Body)
	n += 1 + l + sovCoreTypes(uint64(l))
	n += 1 + sovCoreTypes(uint64(m.SenderID))
	n += 2
	n += 2
	n += 1 + sovCoreTypes(uint64(m.ReplyTo))
	n += 2 + sovCoreTypes(uint64(m.MessageAction))
	if m.MessageActionData != nil {
		l = len(m.MessageActionData)
		n += 2 + l + sovCoreTypes(uint64(l))
	}
	if len(m.Entities) > 0 {
		for _, e := range m.Entities {
			l = e.Size()
			n += 2 + l + sovCoreTypes(uint64(l))
		}
	}
	n += 2 + sovCoreTypes(uint64(m.MediaType))
	if m.Media != nil {
		l = len(m.Media)
		n += 2 + l + sovCoreTypes(uint64(l))
	}
	return n
}

func (m *MessageEntity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.Type))
	n += 1 + sovCoreTypes(uint64(m.Offset))
	n += 1 + sovCoreTypes(uint64(m.Length))
	n += 1 + sovCoreTypes(uint64(m.UserID))
	return n
}

func (m *RSAPublicKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.FingerPrint))
	l = len(m.N)
	n += 1 + l + sovCoreTypes(uint64(l))
	n += 1 + sovCoreTypes(uint64(m.E))
	return n
}

func (m *DHGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.FingerPrint))
	l = len(m.Prime)
	n += 1 + l + sovCoreTypes(uint64(l))
	n += 1 + sovCoreTypes(uint64(m.Gen))
	return n
}

func (m *PhoneContact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.ClientID))
	l = len(m.FirstName)
	n += 1 + l + sovCoreTypes(uint64(l))
	l = len(m.LastName)
	n += 1 + l + sovCoreTypes(uint64(l))
	l = len(m.Phone)
	n += 1 + l + sovCoreTypes(uint64(l))
	return n
}

func (m *PeerNotifySettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.Flags))
	n += 1 + sovCoreTypes(uint64(m.MuteUntil))
	l = len(m.Sound)
	n += 1 + l + sovCoreTypes(uint64(l))
	return n
}

func (m *InputFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.FileID))
	n += 1 + sovCoreTypes(uint64(m.TotalParts))
	l = len(m.FileName)
	n += 1 + l + sovCoreTypes(uint64(l))
	l = len(m.MD5Checksum)
	n += 1 + l + sovCoreTypes(uint64(l))
	n += 1 + sovCoreTypes(uint64(m.ClusterID))
	return n
}

func (m *Group) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.ID))
	l = len(m.Title)
	n += 1 + l + sovCoreTypes(uint64(l))
	n += 1 + sovCoreTypes(uint64(m.CreatedOn))
	n += 1 + sovCoreTypes(uint64(m.Participants))
	n += 1 + sovCoreTypes(uint64(m.EditedOn))
	if len(m.Flags) > 0 {
		for _, e := range m.Flags {
			n += 1 + sovCoreTypes(uint64(e))
		}
	}
	return n
}

func (m *GroupFull) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovCoreTypes(uint64(l))
	}
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovCoreTypes(uint64(l))
		}
	}
	if len(m.Participants) > 0 {
		for _, e := range m.Participants {
			l = e.Size()
			n += 1 + l + sovCoreTypes(uint64(l))
		}
	}
	if m.NotifySettings != nil {
		l = m.NotifySettings.Size()
		n += 1 + l + sovCoreTypes(uint64(l))
	}
	return n
}

func (m *GroupParticipant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.UserID))
	l = len(m.FirstName)
	n += 1 + l + sovCoreTypes(uint64(l))
	l = len(m.LastName)
	n += 1 + l + sovCoreTypes(uint64(l))
	n += 1 + sovCoreTypes(uint64(m.Type))
	n += 1 + sovCoreTypes(uint64(m.AccessHash))
	l = len(m.Username)
	n += 1 + l + sovCoreTypes(uint64(l))
	return n
}

func (m *Cluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.ID))
	l = len(m.IP)
	n += 1 + l + sovCoreTypes(uint64(l))
	l = len(m.Domain)
	n += 1 + l + sovCoreTypes(uint64(l))
	l = len(m.Location)
	n += 1 + l + sovCoreTypes(uint64(l))
	return n
}

func sovCoreTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCoreTypes(x uint64) (n int) {
	return sovCoreTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Dialog) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dialog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dialog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerID", wireType)
			}
			m.PeerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopMessageID", wireType)
			}
			m.TopMessageID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopMessageID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadInboxMaxID", wireType)
			}
			m.ReadInboxMaxID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadInboxMaxID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOutboxMaxID", wireType)
			}
			m.ReadOutboxMaxID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadOutboxMaxID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnreadCount", wireType)
			}
			m.UnreadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnreadCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000040)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifySettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NotifySettings == nil {
				m.NotifySettings = &PeerNotifySettings{}
			}
			if err := m.NotifySettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MentionedCount", wireType)
			}
			m.MentionedCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MentionedCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PeerID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PeerType")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("TopMessageID")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ReadInboxMaxID")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ReadOutboxMaxID")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UnreadCount")
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Peer) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Peer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Peer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Type")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputPeer) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputPeer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputPeer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (PeerType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Type")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputUser) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UserID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (UserStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Restricted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Restricted = bool(v != 0)
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000040)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FirstName")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("LastName")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Username")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Status")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Restricted")
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContactUser) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContactUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContactUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			m.ClientID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000040)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FirstName")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("LastName")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Phone")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Username")
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ClientID")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerID", wireType)
			}
			m.PeerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedOn", wireType)
			}
			m.CreatedOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedOn |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditedOn", wireType)
			}
			m.EditedOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EditedOn |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwdSenderID", wireType)
			}
			m.FwdSenderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FwdSenderID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwdChannelID", wireType)
			}
			m.FwdChannelID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FwdChannelID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000040)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwdChannelMessageID", wireType)
			}
			m.FwdChannelMessageID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FwdChannelMessageID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000080)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000100)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageType", wireType)
			}
			m.MessageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000200)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000400)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderID", wireType)
			}
			m.SenderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SenderID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000800)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentRead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContentRead = bool(v != 0)
			hasFields[0] |= uint64(0x00001000)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inbox", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Inbox = bool(v != 0)
			hasFields[0] |= uint64(0x00002000)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyTo", wireType)
			}
			m.ReplyTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyTo |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00004000)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageAction", wireType)
			}
			m.MessageAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageAction |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageActionData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageActionData = append(m.MessageActionData[:0], dAtA[iNdEx:postIndex]...)
			if m.MessageActionData == nil {
				m.MessageActionData = []byte{}
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, &MessageEntity{})
			if err := m.Entities[len(m.Entities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaType", wireType)
			}
			m.MediaType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MediaType |= (MediaType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Media = append(m.Media[:0], dAtA[iNdEx:postIndex]...)
			if m.Media == nil {
				m.Media = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PeerID")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PeerType")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("CreatedOn")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("EditedOn")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FwdSenderID")
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FwdChannelID")
	}
	if hasFields[0]&uint64(0x00000080) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FwdChannelMessageID")
	}
	if hasFields[0]&uint64(0x00000100) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Flags")
	}
	if hasFields[0]&uint64(0x00000200) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MessageType")
	}
	if hasFields[0]&uint64(0x00000400) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Body")
	}
	if hasFields[0]&uint64(0x00000800) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("SenderID")
	}
	if hasFields[0]&uint64(0x00001000) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ContentRead")
	}
	if hasFields[0]&uint64(0x00002000) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Inbox")
	}
	if hasFields[0]&uint64(0x00004000) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ReplyTo")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageEntity) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageEntity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageEntity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (MessageEntityType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Type")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Offset")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Length")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RSAPublicKey) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RSAPublicKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RSAPublicKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FingerPrint", wireType)
			}
			m.FingerPrint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FingerPrint |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.N = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field E", wireType)
			}
			m.E = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.E |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FingerPrint")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("N")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("E")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHGroup) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FingerPrint", wireType)
			}
			m.FingerPrint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FingerPrint |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gen", wireType)
			}
			m.Gen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FingerPrint")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Prime")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Gen")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhoneContact) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhoneContact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhoneContact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			m.ClientID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ClientID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FirstName")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("LastName")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Phone")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerNotifySettings) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerNotifySettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerNotifySettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MuteUntil", wireType)
			}
			m.MuteUntil = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MuteUntil |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sound", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sound = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Flags")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputFile) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileID", wireType)
			}
			m.FileID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalParts", wireType)
			}
			m.TotalParts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalParts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MD5Checksum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MD5Checksum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000010)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FileID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("TotalParts")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FileName")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MD5Checksum")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ClusterID")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Group) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedOn", wireType)
			}
			m.CreatedOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedOn |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Participants", wireType)
			}
			m.Participants = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Participants |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditedOn", wireType)
			}
			m.EditedOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EditedOn |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v GroupFlags
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCoreTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (GroupFlags(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Flags = append(m.Flags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCoreTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCoreTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Flags) == 0 {
					m.Flags = make([]GroupFlags, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v GroupFlags
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCoreTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (GroupFlags(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Flags = append(m.Flags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Title")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("CreatedOn")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Participants")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupFull) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupFull: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupFull: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &Group{}
			}
			if err := m.Group.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &User{})
			if err := m.Users[len(m.Users)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Participants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Participants = append(m.Participants, &GroupParticipant{})
			if err := m.Participants[len(m.Participants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifySettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NotifySettings == nil {
				m.NotifySettings = &PeerNotifySettings{}
			}
			if err := m.NotifySettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Group")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("NotifySettings")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupParticipant) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupParticipant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupParticipant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (ParticipantType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000020)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UserID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FirstName")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("LastName")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Type")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Username")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("IP")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Domain")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Location")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCoreTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCoreTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCoreTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCoreTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCoreTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCoreTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("core.types.proto", fileDescriptor_core_types_d4fac55f94c1174d) }

var fileDescriptor_core_types_d4fac55f94c1174d = []byte{
	// 1625 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0x41, 0x6f, 0x23, 0x49,
	0x15, 0x76, 0x75, 0xb7, 0x3d, 0xf1, 0xb3, 0x93, 0xd4, 0xd4, 0x64, 0x32, 0x4d, 0x18, 0x79, 0xad,
	0x16, 0x0c, 0x96, 0xc5, 0x66, 0x57, 0x91, 0x90, 0xe0, 0x84, 0x66, 0xe2, 0x64, 0xd7, 0x62, 0x93,
	0x89, 0x9c, 0x04, 0x24, 0x0e, 0x68, 0x3b, 0xdd, 0x15, 0xa7, 0xb5, 0xed, 0x2a, 0xab, 0xbb, 0x9a,
	0x5d, 0x1f, 0x81, 0x3f, 0x00, 0x12, 0x17, 0xc4, 0x91, 0xdf, 0x81, 0xb8, 0xae, 0x38, 0x8d, 0x38,
	0x71, 0x42, 0x30, 0xf3, 0x0f, 0x90, 0xb8, 0xa3, 0xaa, 0x2e, 0x77, 0x57, 0x77, 0x3b, 0xcc, 0x08,
	0x8d, 0xf6, 0x14, 0xd7, 0xf7, 0xbd, 0xae, 0x7a, 0x5f, 0xd5, 0xab, 0xaf, 0x5e, 0x00, 0x07, 0x3c,
	0xa1, 0x87, 0x62, 0xb5, 0xa4, 0xe9, 0xe1, 0x32, 0xe1, 0x82, 0x13, 0x7b, 0x91, 0xce, 0x0f, 0x3e,
	0x9c, 0x47, 0xe2, 0x2e, 0xbb, 0x39, 0x0c, 0xf8, 0xe2, 0xa3, 0x39, 0x9f, 0xf3, 0x8f, 0x14, 0x77,
	0x93, 0xdd, 0xaa, 0x91, 0x1a, 0xa8, 0x5f, 0xf9, 0x37, 0xde, 0xef, 0x6c, 0xe8, 0x4c, 0x22, 0x3f,
	0xe6, 0x73, 0x32, 0x80, 0xce, 0x05, 0xa5, 0xc9, 0x74, 0xe2, 0xa2, 0xa1, 0x35, 0xb2, 0x5f, 0x74,
	0xbe, 0xfe, 0xc7, 0x07, 0xad, 0x8f, 0xd1, 0x4c, 0xa3, 0x64, 0x08, 0x5b, 0xf2, 0xd7, 0xd5, 0x6a,
	0x49, 0x5d, 0x6b, 0x68, 0x8d, 0xda, 0x2f, 0x1c, 0x19, 0x31, 0x2b, 0x50, 0x32, 0x82, 0xfe, 0x15,
	0x5f, 0x9e, 0xd1, 0x34, 0xf5, 0xe7, 0x74, 0x3a, 0x71, 0x6d, 0x35, 0x4f, 0x1e, 0x55, 0x61, 0xc8,
	0xf7, 0x61, 0x67, 0x46, 0xfd, 0x70, 0xca, 0x6e, 0xf8, 0x57, 0x67, 0xfe, 0x57, 0xd3, 0x89, 0xeb,
	0x18, 0xb1, 0x35, 0x8e, 0x1c, 0xc2, 0xae, 0x44, 0x5e, 0x66, 0xa2, 0x08, 0x6f, 0x1b, 0xe1, 0x75,
	0x92, 0x3c, 0x83, 0xde, 0x35, 0x4b, 0xa8, 0x1f, 0x1e, 0xf3, 0x8c, 0x09, 0xb7, 0x63, 0x24, 0x6b,
	0x12, 0xe4, 0x19, 0xc0, 0xf3, 0x20, 0xa0, 0x69, 0xfa, 0xa9, 0x9f, 0xde, 0xb9, 0x0f, 0x86, 0xd6,
	0xa8, 0x53, 0xa8, 0x36, 0x18, 0xf2, 0x63, 0xd8, 0x39, 0xe7, 0x22, 0xba, 0x5d, 0x5d, 0x52, 0x21,
	0x22, 0x36, 0x4f, 0xdd, 0xad, 0x21, 0x1a, 0xf5, 0x8e, 0x9e, 0x1c, 0x2e, 0xd2, 0xf9, 0xa1, 0x94,
	0x5f, 0xa5, 0x67, 0xb5, 0x70, 0x29, 0xf7, 0x8c, 0x32, 0x11, 0x71, 0x46, 0x75, 0x4e, 0xdd, 0x21,
	0x2a, 0x72, 0xaa, 0x71, 0xde, 0xe7, 0xe0, 0xc8, 0x39, 0xc9, 0x3e, 0x58, 0x8d, 0xc3, 0xb0, 0xa6,
	0x13, 0xe2, 0x82, 0xd3, 0x38, 0x04, 0x85, 0xd4, 0x04, 0xd9, 0xf7, 0x09, 0xf2, 0x04, 0x74, 0xa7,
	0x6c, 0x99, 0x89, 0xff, 0xb9, 0xcc, 0xf7, 0x8c, 0x65, 0x76, 0x8e, 0xb6, 0x0b, 0xad, 0x12, 0xfc,
	0xbf, 0x56, 0xbd, 0xd4, 0xab, 0x5e, 0xa7, 0x34, 0x91, 0xd5, 0x26, 0xff, 0x36, 0xab, 0x2d, 0x47,
	0x6b, 0x93, 0x5a, 0xf7, 0x4e, 0xfa, 0x1b, 0x0b, 0x1c, 0x35, 0xe1, 0x7d, 0x32, 0x3c, 0xe8, 0x9e,
	0x46, 0x49, 0x2a, 0xce, 0xfd, 0x45, 0xae, 0xa5, 0xab, 0x93, 0x2f, 0x61, 0x59, 0xda, 0x9f, 0xf9,
	0x3a, 0xc4, 0x36, 0x42, 0x0a, 0x54, 0x46, 0xc8, 0x55, 0x98, 0x8c, 0x70, 0xcc, 0x88, 0x35, 0x4a,
	0x3e, 0x84, 0xce, 0xa5, 0xf0, 0x45, 0x96, 0xaa, 0xda, 0xdc, 0x39, 0xda, 0x55, 0x1b, 0x26, 0xe9,
	0x1c, 0xd6, 0x1f, 0xe8, 0x20, 0xf2, 0x1d, 0x80, 0x19, 0x4d, 0x45, 0x12, 0x05, 0x82, 0x86, 0xaa,
	0x44, 0xb7, 0x74, 0x84, 0x81, 0xbf, 0x6b, 0x85, 0x7a, 0xff, 0x41, 0xd0, 0x3b, 0xe6, 0x4c, 0xf8,
	0x81, 0xf8, 0x06, 0x36, 0xa3, 0x9a, 0x95, 0x73, 0xef, 0xbd, 0x39, 0x80, 0xf6, 0xc5, 0x1d, 0x67,
	0x54, 0xed, 0xc8, 0x7a, 0x9a, 0x1c, 0xaa, 0x6c, 0x68, 0x67, 0xe3, 0x86, 0x7a, 0xb0, 0x75, 0x1c,
	0x47, 0x94, 0x89, 0xe9, 0x44, 0x29, 0x2f, 0x95, 0x14, 0xb8, 0xf7, 0xab, 0x0e, 0xf4, 0xe4, 0x07,
	0xda, 0x59, 0xc8, 0x9e, 0xa1, 0x3b, 0x9f, 0x4f, 0xaa, 0x2e, 0x9d, 0xcd, 0x7a, 0xab, 0xb3, 0xd9,
	0x1b, 0x9d, 0xcd, 0x83, 0xee, 0x71, 0x42, 0x7d, 0x41, 0xc3, 0x97, 0xac, 0x62, 0x55, 0x25, 0x2c,
	0x67, 0x39, 0x09, 0xa3, 0x3c, 0xc4, 0xb4, 0xa7, 0x02, 0x25, 0x23, 0xe8, 0x9d, 0x7e, 0x19, 0x5e,
	0x52, 0x16, 0xaa, 0x64, 0x3a, 0x95, 0x64, 0x4c, 0x8a, 0x8c, 0xa1, 0x7f, 0xfa, 0x65, 0x78, 0x7c,
	0xe7, 0x33, 0x46, 0xe3, 0x86, 0xfe, 0x0a, 0x47, 0x7e, 0x08, 0x8f, 0xca, 0x71, 0x69, 0xbe, 0x5b,
	0x95, 0x4f, 0x36, 0x85, 0xc8, 0xf3, 0x39, 0x8d, 0xfd, 0x79, 0xea, 0x76, 0x0d, 0xd1, 0x39, 0x24,
	0x3d, 0x54, 0x07, 0xaa, 0x6d, 0x01, 0x43, 0x90, 0x49, 0x48, 0x33, 0x7a, 0xc1, 0xc3, 0x95, 0xdb,
	0x33, 0xce, 0x50, 0x21, 0xf2, 0xfc, 0x0a, 0xa9, 0xfd, 0xea, 0xf9, 0x15, 0x3a, 0x9f, 0xe5, 0x65,
	0x4b, 0x99, 0x90, 0x1e, 0xee, 0x6e, 0x1b, 0xd7, 0xc0, 0x24, 0x64, 0xa6, 0xea, 0x3d, 0x70, 0x77,
	0x8c, 0x88, 0x1c, 0x22, 0x03, 0x78, 0x30, 0xa3, 0xcb, 0x78, 0x75, 0xc5, 0xdd, 0x5d, 0x23, 0xcb,
	0x35, 0x48, 0xc6, 0xb0, 0xad, 0x13, 0x7e, 0x1e, 0x48, 0x9b, 0x75, 0xb1, 0xe1, 0xbd, 0x55, 0x8a,
	0x1c, 0xc1, 0xc3, 0x0a, 0x30, 0xf1, 0x85, 0xef, 0x3e, 0x1c, 0xa2, 0x51, 0x5f, 0xc7, 0x37, 0x69,
	0x72, 0x08, 0x5b, 0x27, 0x4c, 0x44, 0x22, 0xa2, 0xa9, 0x4b, 0x86, 0xf6, 0xa8, 0x77, 0x44, 0xd4,
	0xd5, 0xd7, 0x91, 0x8a, 0x5b, 0xcd, 0x8a, 0x18, 0x72, 0x04, 0xdd, 0x33, 0x1a, 0x46, 0xbe, 0xda,
	0xd7, 0x47, 0x43, 0x34, 0xda, 0x39, 0xda, 0xd1, 0x1f, 0x68, 0x74, 0x5d, 0x5b, 0x05, 0x20, 0xf5,
	0xab, 0x81, 0xbb, 0x67, 0xe4, 0x92, 0x43, 0xde, 0x1f, 0x51, 0x21, 0x30, 0x5f, 0x8b, 0x7c, 0xac,
	0x9d, 0x1b, 0x29, 0x23, 0xda, 0x6f, 0x66, 0xd3, 0xb0, 0xf0, 0xa7, 0xd0, 0x79, 0x79, 0x7b, 0x9b,
	0x52, 0x51, 0x79, 0x54, 0x34, 0x26, 0xd9, 0xcf, 0x28, 0x9b, 0x8b, 0xbb, 0xca, 0xed, 0xd0, 0x98,
	0x64, 0xb5, 0x93, 0x3b, 0x43, 0x54, 0x6c, 0xbf, 0xc6, 0xbc, 0x5f, 0x40, 0x7f, 0x76, 0xf9, 0xfc,
	0x22, 0xbb, 0x89, 0xa3, 0xe0, 0x27, 0x74, 0x25, 0x4f, 0xfc, 0x34, 0x62, 0x73, 0x9a, 0x5c, 0x24,
	0x11, 0x13, 0x95, 0xab, 0x6a, 0x12, 0x84, 0x00, 0x3a, 0xaf, 0x38, 0x14, 0x3a, 0x97, 0xd8, 0x89,
	0x4a, 0x61, 0x7b, 0x8d, 0x9d, 0x78, 0x14, 0x1e, 0x4c, 0x3e, 0xfd, 0x24, 0xe1, 0xd9, 0xf2, 0x9d,
	0xa7, 0x96, 0xb6, 0x94, 0x44, 0x35, 0x03, 0xcc, 0x21, 0xb2, 0x0f, 0xf6, 0x27, 0x94, 0x55, 0x74,
	0x4a, 0xc0, 0xfb, 0x3d, 0x82, 0xbe, 0x32, 0x2e, 0xed, 0xb2, 0x15, 0x77, 0x42, 0x9b, 0xdd, 0xe9,
	0x3d, 0xb9, 0x6d, 0xe1, 0xa2, 0x4e, 0xc3, 0x45, 0xbd, 0x25, 0x90, 0x66, 0xfb, 0x51, 0xde, 0x6b,
	0xd4, 0xbc, 0xd7, 0x1e, 0x74, 0xcf, 0x32, 0x41, 0xaf, 0x99, 0x88, 0x62, 0xd7, 0x32, 0x0e, 0xac,
	0x84, 0xe5, 0xf7, 0x97, 0x3c, 0x63, 0xa1, 0x6b, 0x0f, 0x51, 0xb9, 0xa2, 0x82, 0xbc, 0xbf, 0x20,
	0xfd, 0x8a, 0x9f, 0x46, 0x31, 0x95, 0xce, 0x2a, 0xff, 0x36, 0x5f, 0xf1, 0x1c, 0x95, 0xaf, 0xdc,
	0x15, 0x17, 0x7e, 0x7c, 0xe1, 0x27, 0x22, 0xad, 0xd4, 0x96, 0x81, 0xcb, 0x3d, 0x90, 0xf1, 0xcd,
	0x3d, 0x58, 0xa3, 0xca, 0x8d, 0x26, 0x3f, 0x38, 0xbe, 0xa3, 0xc1, 0x17, 0x69, 0xb6, 0xa8, 0xec,
	0x84, 0x49, 0x28, 0x9f, 0x8e, 0xb3, 0x54, 0xa8, 0x72, 0x6c, 0x1b, 0xcb, 0x95, 0xb0, 0xf7, 0x37,
	0x04, 0xed, 0xbc, 0x60, 0xee, 0x7b, 0x25, 0x0f, 0xa0, 0x7d, 0x15, 0x89, 0xb8, 0x56, 0x20, 0x0a,
	0xaa, 0xbe, 0x04, 0xf6, 0xe6, 0x97, 0x60, 0x04, 0x7d, 0x29, 0x2c, 0x0a, 0xa2, 0xa5, 0xcf, 0x44,
	0xaa, 0xd2, 0x5d, 0x27, 0x52, 0x61, 0x6a, 0x6f, 0x06, 0xda, 0xf0, 0x66, 0x7c, 0x77, 0x7d, 0x96,
	0x9d, 0xa1, 0x5d, 0x74, 0x15, 0x2a, 0x7d, 0x05, 0xeb, 0x63, 0xf5, 0xfe, 0x8a, 0xa0, 0x9b, 0xa3,
	0x59, 0x1c, 0x93, 0xa1, 0x56, 0xa8, 0xb4, 0xf5, 0x8e, 0xa0, 0xfc, 0x68, 0xa6, 0xa5, 0x7f, 0x00,
	0x6d, 0x79, 0x41, 0xe5, 0x99, 0x48, 0xc7, 0xea, 0x16, 0xcd, 0xca, 0x2c, 0xc7, 0xc9, 0x8f, 0x6a,
	0x1a, 0x6c, 0x15, 0xf7, 0xb8, 0x9c, 0xc9, 0x60, 0x6b, 0xa2, 0x9a, 0xed, 0xb2, 0xa3, 0xd2, 0x78,
	0xd7, 0x76, 0xd9, 0xfb, 0x37, 0x02, 0x5c, 0x5f, 0xe3, 0xad, 0x0d, 0xe3, 0xfb, 0xb9, 0x6c, 0x87,
	0xda, 0x3a, 0x1d, 0x65, 0x9d, 0x7b, 0x79, 0xc6, 0x65, 0x16, 0x6f, 0xe9, 0x7d, 0x65, 0xc5, 0x39,
	0x1b, 0x5b, 0xa1, 0xb7, 0xb6, 0x3b, 0x5e, 0x06, 0x0f, 0x74, 0x8d, 0x1a, 0x5d, 0x4c, 0xdb, 0xe8,
	0x62, 0x24, 0x7a, 0x51, 0x51, 0x66, 0x4d, 0x2f, 0xa4, 0xfb, 0x4e, 0xf8, 0xc2, 0x8f, 0x58, 0x45,
	0x90, 0xc6, 0x94, 0x60, 0x1e, 0xf8, 0xea, 0xd9, 0xab, 0xb4, 0xad, 0x6b, 0x74, 0xfc, 0x07, 0x04,
	0xfd, 0xab, 0xd5, 0x32, 0x62, 0x73, 0xfd, 0x04, 0xee, 0x03, 0x31, 0xc7, 0xf9, 0x6f, 0xdc, 0x22,
	0x03, 0x38, 0x30, 0xf1, 0x19, 0x0d, 0x78, 0x12, 0x46, 0x6c, 0xfe, 0x53, 0x1e, 0x05, 0x14, 0xa3,
	0xfb, 0xf9, 0x28, 0xa4, 0x1c, 0x5b, 0xe4, 0x5b, 0xf0, 0xd8, 0xe4, 0xaf, 0x97, 0x31, 0xf7, 0x25,
	0x8f, 0xed, 0xfa, 0x92, 0xc7, 0x3e, 0x0b, 0x68, 0x8c, 0x9d, 0xf1, 0xcf, 0xcb, 0xbe, 0x8c, 0xf4,
	0xf3, 0xdf, 0x97, 0x34, 0xbe, 0xc5, 0xad, 0xf5, 0x48, 0x6e, 0x1e, 0x46, 0x64, 0x1b, 0xba, 0x72,
	0xa4, 0x4a, 0x06, 0x5b, 0x84, 0xc0, 0x8e, 0x0a, 0xcd, 0x96, 0x6b, 0xcc, 0x26, 0xbb, 0xd0, 0x93,
	0x98, 0x6e, 0x81, 0xb0, 0x33, 0xfe, 0x35, 0x02, 0x28, 0x9b, 0x73, 0xf2, 0x18, 0x1e, 0x96, 0xa3,
	0x97, 0xb7, 0xb7, 0x71, 0xc4, 0x28, 0x6e, 0x91, 0x3d, 0xc0, 0x06, 0xcc, 0x14, 0x8a, 0x64, 0xbe,
	0x25, 0x3a, 0xa3, 0x01, 0x65, 0x22, 0x5e, 0x61, 0xab, 0x8a, 0xcb, 0x92, 0xfa, 0x19, 0xa5, 0x5f,
	0x60, 0x9b, 0x3c, 0x81, 0x47, 0x55, 0xfc, 0x8c, 0x33, 0x71, 0x87, 0x9d, 0xf1, 0xe7, 0x46, 0x2b,
	0x20, 0xd3, 0x2e, 0x06, 0x27, 0x8b, 0xa5, 0x58, 0xe1, 0x56, 0x05, 0xbb, 0xb8, 0xe3, 0x82, 0x63,
	0x24, 0x53, 0x2d, 0xb0, 0x09, 0x0f, 0xb2, 0x05, 0x65, 0x02, 0x5b, 0x32, 0xd5, 0x02, 0xd6, 0x8f,
	0x14, 0xb6, 0xc7, 0x7f, 0x46, 0x45, 0x47, 0x53, 0x3e, 0xfd, 0xf2, 0x2c, 0x9a, 0xfd, 0x00, 0x8f,
	0x43, 0xdc, 0x22, 0xdf, 0x86, 0x27, 0x0d, 0x6a, 0x2a, 0xfc, 0x38, 0x0a, 0x30, 0x22, 0x4f, 0xc1,
	0x6d, 0x90, 0xfa, 0x9f, 0x57, 0x6c, 0x11, 0x17, 0xf6, 0x1a, 0xec, 0x75, 0x12, 0x63, 0x9b, 0x1c,
	0xc0, 0x7e, 0x83, 0x39, 0x59, 0xf8, 0x51, 0x8c, 0x9d, 0x8d, 0x73, 0xca, 0x2b, 0x23, 0xfc, 0x39,
	0x6e, 0x8f, 0xff, 0x84, 0x00, 0x4a, 0xb7, 0x23, 0x8f, 0x60, 0xb7, 0x1c, 0xad, 0x37, 0xe9, 0x31,
	0x3c, 0x2c, 0x41, 0xe5, 0xc2, 0x3c, 0xc9, 0x93, 0x2d, 0xe1, 0x73, 0xce, 0x8c, 0x6b, 0x8c, 0xad,
	0xea, 0x4c, 0xcf, 0xc3, 0x45, 0xc4, 0xb0, 0x2d, 0xc5, 0xd7, 0xc0, 0xf4, 0x84, 0xf9, 0x37, 0x31,
	0x0d, 0xb1, 0x23, 0x37, 0xad, 0x24, 0x27, 0xd4, 0x0f, 0x44, 0xf4, 0x4b, 0x69, 0xf8, 0xb8, 0x3d,
	0xbe, 0x81, 0xdd, 0x9a, 0x49, 0xc8, 0xe8, 0x1a, 0x74, 0x46, 0x17, 0x37, 0x34, 0xc1, 0x2d, 0xb9,
	0x4f, 0x35, 0x2a, 0x5f, 0x1f, 0xc9, 0x7d, 0xaa, 0x31, 0x6b, 0x39, 0xd6, 0x8b, 0xa7, 0xaf, 0xfe,
	0x35, 0x68, 0x7d, 0xfd, 0x7a, 0x80, 0x5e, 0xbd, 0x1e, 0xa0, 0x7f, 0xbe, 0x1e, 0xa0, 0xdf, 0xbe,
	0x19, 0xb4, 0x5e, 0xbd, 0x19, 0xb4, 0xfe, 0xfe, 0x66, 0xd0, 0xfa, 0x6f, 0x00, 0x00, 0x00, 0xff,
	0xff, 0xa7, 0x1d, 0x6b, 0xcd, 0x0e, 0x12, 0x00, 0x00,
}

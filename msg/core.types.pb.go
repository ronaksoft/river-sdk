// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: core.types.proto

package msg

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// TypingAction
type TypingAction int32

const (
	TypingActionTyping         TypingAction = 0
	TypingActionRecordingVoice TypingAction = 1
	TypingActionRecordingVideo TypingAction = 2
	TypingActionUploading      TypingAction = 3
	TypingActionCancel         TypingAction = 4
)

var TypingAction_name = map[int32]string{
	0: "TypingActionTyping",
	1: "TypingActionRecordingVoice",
	2: "TypingActionRecordingVideo",
	3: "TypingActionUploading",
	4: "TypingActionCancel",
}
var TypingAction_value = map[string]int32{
	"TypingActionTyping":         0,
	"TypingActionRecordingVoice": 1,
	"TypingActionRecordingVideo": 2,
	"TypingActionUploading":      3,
	"TypingActionCancel":         4,
}

func (x TypingAction) Enum() *TypingAction {
	p := new(TypingAction)
	*p = x
	return p
}
func (x TypingAction) String() string {
	return proto.EnumName(TypingAction_name, int32(x))
}
func (x *TypingAction) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TypingAction_value, data, "TypingAction")
	if err != nil {
		return err
	}
	*x = TypingAction(value)
	return nil
}
func (TypingAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_core_types_ef061dba8cb38769, []int{0}
}

// PeerType
type PeerType int32

const (
	PeerSelf       PeerType = 0
	PeerUser       PeerType = 1
	PeerGroup      PeerType = 2
	PeerSuperGroup PeerType = 3
	PeerChannel    PeerType = 4
)

var PeerType_name = map[int32]string{
	0: "PeerSelf",
	1: "PeerUser",
	2: "PeerGroup",
	3: "PeerSuperGroup",
	4: "PeerChannel",
}
var PeerType_value = map[string]int32{
	"PeerSelf":       0,
	"PeerUser":       1,
	"PeerGroup":      2,
	"PeerSuperGroup": 3,
	"PeerChannel":    4,
}

func (x PeerType) Enum() *PeerType {
	p := new(PeerType)
	*p = x
	return p
}
func (x PeerType) String() string {
	return proto.EnumName(PeerType_name, int32(x))
}
func (x *PeerType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PeerType_value, data, "PeerType")
	if err != nil {
		return err
	}
	*x = PeerType(value)
	return nil
}
func (PeerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_core_types_ef061dba8cb38769, []int{1}
}

type GroupFlags int32

const (
	GroupFlagsEmpty         GroupFlags = 0
	GroupFlagsCreator       GroupFlags = 1
	GroupFlagsLeft          GroupFlags = 2
	GroupFlagsKicked        GroupFlags = 4
	GroupFlagsAdmin         GroupFlags = 8
	GroupFlagsAdminsEnabled GroupFlags = 16
	GroupFlagsDeactivated   GroupFlags = 32
)

var GroupFlags_name = map[int32]string{
	0:  "GroupFlagsEmpty",
	1:  "GroupFlagsCreator",
	2:  "GroupFlagsLeft",
	4:  "GroupFlagsKicked",
	8:  "GroupFlagsAdmin",
	16: "GroupFlagsAdminsEnabled",
	32: "GroupFlagsDeactivated",
}
var GroupFlags_value = map[string]int32{
	"GroupFlagsEmpty":         0,
	"GroupFlagsCreator":       1,
	"GroupFlagsLeft":          2,
	"GroupFlagsKicked":        4,
	"GroupFlagsAdmin":         8,
	"GroupFlagsAdminsEnabled": 16,
	"GroupFlagsDeactivated":   32,
}

func (x GroupFlags) Enum() *GroupFlags {
	p := new(GroupFlags)
	*p = x
	return p
}
func (x GroupFlags) String() string {
	return proto.EnumName(GroupFlags_name, int32(x))
}
func (x *GroupFlags) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GroupFlags_value, data, "GroupFlags")
	if err != nil {
		return err
	}
	*x = GroupFlags(value)
	return nil
}
func (GroupFlags) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_core_types_ef061dba8cb38769, []int{2}
}

// ParticipantType
type ParticipantType int32

const (
	ParticipantTypeCreator ParticipantType = 0
	ParticipantTypeAdmin   ParticipantType = 1
	ParticipantMember      ParticipantType = 2
)

var ParticipantType_name = map[int32]string{
	0: "ParticipantTypeCreator",
	1: "ParticipantTypeAdmin",
	2: "ParticipantMember",
}
var ParticipantType_value = map[string]int32{
	"ParticipantTypeCreator": 0,
	"ParticipantTypeAdmin":   1,
	"ParticipantMember":      2,
}

func (x ParticipantType) Enum() *ParticipantType {
	p := new(ParticipantType)
	*p = x
	return p
}
func (x ParticipantType) String() string {
	return proto.EnumName(ParticipantType_name, int32(x))
}
func (x *ParticipantType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ParticipantType_value, data, "ParticipantType")
	if err != nil {
		return err
	}
	*x = ParticipantType(value)
	return nil
}
func (ParticipantType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_core_types_ef061dba8cb38769, []int{3}
}

// Dialog
type Dialog struct {
	PeerID          int64               `protobuf:"varint,1,req,name=PeerID" json:"PeerID"`
	PeerType        int32               `protobuf:"varint,2,req,name=PeerType" json:"PeerType"`
	TopMessageID    int64               `protobuf:"varint,3,req,name=TopMessageID" json:"TopMessageID"`
	ReadInboxMaxID  int64               `protobuf:"varint,4,req,name=ReadInboxMaxID" json:"ReadInboxMaxID"`
	ReadOutboxMaxID int64               `protobuf:"varint,5,req,name=ReadOutboxMaxID" json:"ReadOutboxMaxID"`
	UnreadCount     int32               `protobuf:"varint,6,req,name=UnreadCount" json:"UnreadCount"`
	AccessHash      uint64              `protobuf:"fixed64,7,req,name=AccessHash" json:"AccessHash"`
	NotifySettings  *PeerNotifySettings `protobuf:"bytes,8,opt,name=NotifySettings" json:"NotifySettings,omitempty"`
}

func (m *Dialog) Reset()         { *m = Dialog{} }
func (m *Dialog) String() string { return proto.CompactTextString(m) }
func (*Dialog) ProtoMessage()    {}
func (*Dialog) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_ef061dba8cb38769, []int{0}
}
func (m *Dialog) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dialog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dialog.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Dialog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dialog.Merge(dst, src)
}
func (m *Dialog) XXX_Size() int {
	return m.Size()
}
func (m *Dialog) XXX_DiscardUnknown() {
	xxx_messageInfo_Dialog.DiscardUnknown(m)
}

var xxx_messageInfo_Dialog proto.InternalMessageInfo

func (m *Dialog) GetPeerID() int64 {
	if m != nil {
		return m.PeerID
	}
	return 0
}

func (m *Dialog) GetPeerType() int32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *Dialog) GetTopMessageID() int64 {
	if m != nil {
		return m.TopMessageID
	}
	return 0
}

func (m *Dialog) GetReadInboxMaxID() int64 {
	if m != nil {
		return m.ReadInboxMaxID
	}
	return 0
}

func (m *Dialog) GetReadOutboxMaxID() int64 {
	if m != nil {
		return m.ReadOutboxMaxID
	}
	return 0
}

func (m *Dialog) GetUnreadCount() int32 {
	if m != nil {
		return m.UnreadCount
	}
	return 0
}

func (m *Dialog) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *Dialog) GetNotifySettings() *PeerNotifySettings {
	if m != nil {
		return m.NotifySettings
	}
	return nil
}

// Peer
type Peer struct {
	ID         int64  `protobuf:"varint,1,req,name=ID" json:"ID"`
	Type       int32  `protobuf:"varint,2,req,name=Type" json:"Type"`
	AccessHash uint64 `protobuf:"fixed64,3,req,name=AccessHash" json:"AccessHash"`
}

func (m *Peer) Reset()         { *m = Peer{} }
func (m *Peer) String() string { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()    {}
func (*Peer) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_ef061dba8cb38769, []int{1}
}
func (m *Peer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Peer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Peer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Peer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Peer.Merge(dst, src)
}
func (m *Peer) XXX_Size() int {
	return m.Size()
}
func (m *Peer) XXX_DiscardUnknown() {
	xxx_messageInfo_Peer.DiscardUnknown(m)
}

var xxx_messageInfo_Peer proto.InternalMessageInfo

func (m *Peer) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Peer) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Peer) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// InputPeer
type InputPeer struct {
	ID         int64    `protobuf:"varint,1,req,name=ID" json:"ID"`
	Type       PeerType `protobuf:"varint,2,req,name=Type,enum=msg.PeerType" json:"Type"`
	AccessHash uint64   `protobuf:"fixed64,3,req,name=AccessHash" json:"AccessHash"`
}

func (m *InputPeer) Reset()         { *m = InputPeer{} }
func (m *InputPeer) String() string { return proto.CompactTextString(m) }
func (*InputPeer) ProtoMessage()    {}
func (*InputPeer) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_ef061dba8cb38769, []int{2}
}
func (m *InputPeer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputPeer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputPeer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InputPeer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputPeer.Merge(dst, src)
}
func (m *InputPeer) XXX_Size() int {
	return m.Size()
}
func (m *InputPeer) XXX_DiscardUnknown() {
	xxx_messageInfo_InputPeer.DiscardUnknown(m)
}

var xxx_messageInfo_InputPeer proto.InternalMessageInfo

func (m *InputPeer) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *InputPeer) GetType() PeerType {
	if m != nil {
		return m.Type
	}
	return PeerSelf
}

func (m *InputPeer) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// InputPeer
type InputUser struct {
	UserID     int64  `protobuf:"varint,1,req,name=UserID" json:"UserID"`
	AccessHash uint64 `protobuf:"fixed64,2,req,name=AccessHash" json:"AccessHash"`
}

func (m *InputUser) Reset()         { *m = InputUser{} }
func (m *InputUser) String() string { return proto.CompactTextString(m) }
func (*InputUser) ProtoMessage()    {}
func (*InputUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_ef061dba8cb38769, []int{3}
}
func (m *InputUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InputUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputUser.Merge(dst, src)
}
func (m *InputUser) XXX_Size() int {
	return m.Size()
}
func (m *InputUser) XXX_DiscardUnknown() {
	xxx_messageInfo_InputUser.DiscardUnknown(m)
}

var xxx_messageInfo_InputUser proto.InternalMessageInfo

func (m *InputUser) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *InputUser) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// User
type User struct {
	ID        int64  `protobuf:"varint,1,req,name=ID" json:"ID"`
	FirstName string `protobuf:"bytes,2,req,name=FirstName" json:"FirstName"`
	LastName  string `protobuf:"bytes,3,req,name=LastName" json:"LastName"`
	Username  string `protobuf:"bytes,4,req,name=Username" json:"Username"`
}

func (m *User) Reset()         { *m = User{} }
func (m *User) String() string { return proto.CompactTextString(m) }
func (*User) ProtoMessage()    {}
func (*User) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_ef061dba8cb38769, []int{4}
}
func (m *User) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *User) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_User.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *User) XXX_Merge(src proto.Message) {
	xxx_messageInfo_User.Merge(dst, src)
}
func (m *User) XXX_Size() int {
	return m.Size()
}
func (m *User) XXX_DiscardUnknown() {
	xxx_messageInfo_User.DiscardUnknown(m)
}

var xxx_messageInfo_User proto.InternalMessageInfo

func (m *User) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *User) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *User) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *User) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

// ContactUser
type ContactUser struct {
	ID         int64  `protobuf:"varint,1,req,name=ID" json:"ID"`
	FirstName  string `protobuf:"bytes,2,req,name=FirstName" json:"FirstName"`
	LastName   string `protobuf:"bytes,3,req,name=LastName" json:"LastName"`
	AccessHash uint64 `protobuf:"fixed64,4,req,name=AccessHash" json:"AccessHash"`
	Phone      string `protobuf:"bytes,5,req,name=Phone" json:"Phone"`
	Username   string `protobuf:"bytes,6,req,name=Username" json:"Username"`
	ClientID   int64  `protobuf:"varint,7,req,name=ClientID" json:"ClientID"`
}

func (m *ContactUser) Reset()         { *m = ContactUser{} }
func (m *ContactUser) String() string { return proto.CompactTextString(m) }
func (*ContactUser) ProtoMessage()    {}
func (*ContactUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_ef061dba8cb38769, []int{5}
}
func (m *ContactUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContactUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContactUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ContactUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContactUser.Merge(dst, src)
}
func (m *ContactUser) XXX_Size() int {
	return m.Size()
}
func (m *ContactUser) XXX_DiscardUnknown() {
	xxx_messageInfo_ContactUser.DiscardUnknown(m)
}

var xxx_messageInfo_ContactUser proto.InternalMessageInfo

func (m *ContactUser) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ContactUser) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *ContactUser) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *ContactUser) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *ContactUser) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *ContactUser) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *ContactUser) GetClientID() int64 {
	if m != nil {
		return m.ClientID
	}
	return 0
}

// UserMessage
type UserMessage struct {
	ID                  int64  `protobuf:"varint,1,req,name=ID" json:"ID"`
	PeerID              int64  `protobuf:"varint,2,req,name=PeerID" json:"PeerID"`
	PeerType            int32  `protobuf:"varint,3,req,name=PeerType" json:"PeerType"`
	CreatedOn           int64  `protobuf:"varint,4,req,name=CreatedOn" json:"CreatedOn"`
	EditedOn            int64  `protobuf:"varint,5,req,name=EditedOn" json:"EditedOn"`
	FwdSenderID         int64  `protobuf:"varint,6,req,name=FwdSenderID" json:"FwdSenderID"`
	FwdChannelID        int64  `protobuf:"varint,7,req,name=FwdChannelID" json:"FwdChannelID"`
	FwdChannelMessageID int64  `protobuf:"varint,8,req,name=FwdChannelMessageID" json:"FwdChannelMessageID"`
	Flags               int32  `protobuf:"varint,9,req,name=Flags" json:"Flags"`
	MessageType         int64  `protobuf:"varint,10,req,name=MessageType" json:"MessageType"`
	Body                string `protobuf:"bytes,11,req,name=Body" json:"Body"`
	SenderID            int64  `protobuf:"varint,12,req,name=SenderID" json:"SenderID"`
	ContentRead         bool   `protobuf:"varint,13,req,name=ContentRead" json:"ContentRead"`
	Inbox               bool   `protobuf:"varint,14,req,name=Inbox" json:"Inbox"`
	ReplyTo             int64  `protobuf:"varint,15,opt,name=ReplyTo" json:"ReplyTo"`
	MessageAction       int32  `protobuf:"varint,16,opt,name=MessageAction" json:"MessageAction"`
	MessageActionData   []byte `protobuf:"bytes,17,opt,name=MessageActionData" json:"MessageActionData"`
}

func (m *UserMessage) Reset()         { *m = UserMessage{} }
func (m *UserMessage) String() string { return proto.CompactTextString(m) }
func (*UserMessage) ProtoMessage()    {}
func (*UserMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_ef061dba8cb38769, []int{6}
}
func (m *UserMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UserMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserMessage.Merge(dst, src)
}
func (m *UserMessage) XXX_Size() int {
	return m.Size()
}
func (m *UserMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_UserMessage.DiscardUnknown(m)
}

var xxx_messageInfo_UserMessage proto.InternalMessageInfo

func (m *UserMessage) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UserMessage) GetPeerID() int64 {
	if m != nil {
		return m.PeerID
	}
	return 0
}

func (m *UserMessage) GetPeerType() int32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *UserMessage) GetCreatedOn() int64 {
	if m != nil {
		return m.CreatedOn
	}
	return 0
}

func (m *UserMessage) GetEditedOn() int64 {
	if m != nil {
		return m.EditedOn
	}
	return 0
}

func (m *UserMessage) GetFwdSenderID() int64 {
	if m != nil {
		return m.FwdSenderID
	}
	return 0
}

func (m *UserMessage) GetFwdChannelID() int64 {
	if m != nil {
		return m.FwdChannelID
	}
	return 0
}

func (m *UserMessage) GetFwdChannelMessageID() int64 {
	if m != nil {
		return m.FwdChannelMessageID
	}
	return 0
}

func (m *UserMessage) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *UserMessage) GetMessageType() int64 {
	if m != nil {
		return m.MessageType
	}
	return 0
}

func (m *UserMessage) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

func (m *UserMessage) GetSenderID() int64 {
	if m != nil {
		return m.SenderID
	}
	return 0
}

func (m *UserMessage) GetContentRead() bool {
	if m != nil {
		return m.ContentRead
	}
	return false
}

func (m *UserMessage) GetInbox() bool {
	if m != nil {
		return m.Inbox
	}
	return false
}

func (m *UserMessage) GetReplyTo() int64 {
	if m != nil {
		return m.ReplyTo
	}
	return 0
}

func (m *UserMessage) GetMessageAction() int32 {
	if m != nil {
		return m.MessageAction
	}
	return 0
}

func (m *UserMessage) GetMessageActionData() []byte {
	if m != nil {
		return m.MessageActionData
	}
	return nil
}

// RSAPublicKey
type RSAPublicKey struct {
	FingerPrint int64  `protobuf:"varint,1,req,name=FingerPrint" json:"FingerPrint"`
	N           string `protobuf:"bytes,2,req,name=N" json:"N"`
	E           uint32 `protobuf:"varint,3,req,name=E" json:"E"`
}

func (m *RSAPublicKey) Reset()         { *m = RSAPublicKey{} }
func (m *RSAPublicKey) String() string { return proto.CompactTextString(m) }
func (*RSAPublicKey) ProtoMessage()    {}
func (*RSAPublicKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_ef061dba8cb38769, []int{7}
}
func (m *RSAPublicKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RSAPublicKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RSAPublicKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RSAPublicKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RSAPublicKey.Merge(dst, src)
}
func (m *RSAPublicKey) XXX_Size() int {
	return m.Size()
}
func (m *RSAPublicKey) XXX_DiscardUnknown() {
	xxx_messageInfo_RSAPublicKey.DiscardUnknown(m)
}

var xxx_messageInfo_RSAPublicKey proto.InternalMessageInfo

func (m *RSAPublicKey) GetFingerPrint() int64 {
	if m != nil {
		return m.FingerPrint
	}
	return 0
}

func (m *RSAPublicKey) GetN() string {
	if m != nil {
		return m.N
	}
	return ""
}

func (m *RSAPublicKey) GetE() uint32 {
	if m != nil {
		return m.E
	}
	return 0
}

// DHGroup
type DHGroup struct {
	FingerPrint int64  `protobuf:"varint,1,req,name=FingerPrint" json:"FingerPrint"`
	Prime       string `protobuf:"bytes,2,req,name=Prime" json:"Prime"`
	Gen         int32  `protobuf:"varint,3,req,name=Gen" json:"Gen"`
}

func (m *DHGroup) Reset()         { *m = DHGroup{} }
func (m *DHGroup) String() string { return proto.CompactTextString(m) }
func (*DHGroup) ProtoMessage()    {}
func (*DHGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_ef061dba8cb38769, []int{8}
}
func (m *DHGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DHGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DHGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHGroup.Merge(dst, src)
}
func (m *DHGroup) XXX_Size() int {
	return m.Size()
}
func (m *DHGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_DHGroup.DiscardUnknown(m)
}

var xxx_messageInfo_DHGroup proto.InternalMessageInfo

func (m *DHGroup) GetFingerPrint() int64 {
	if m != nil {
		return m.FingerPrint
	}
	return 0
}

func (m *DHGroup) GetPrime() string {
	if m != nil {
		return m.Prime
	}
	return ""
}

func (m *DHGroup) GetGen() int32 {
	if m != nil {
		return m.Gen
	}
	return 0
}

// PhoneContact
type PhoneContact struct {
	ClientID  int64  `protobuf:"varint,1,req,name=ClientID" json:"ClientID"`
	FirstName string `protobuf:"bytes,2,req,name=FirstName" json:"FirstName"`
	LastName  string `protobuf:"bytes,3,req,name=LastName" json:"LastName"`
	Phone     string `protobuf:"bytes,4,req,name=Phone" json:"Phone"`
}

func (m *PhoneContact) Reset()         { *m = PhoneContact{} }
func (m *PhoneContact) String() string { return proto.CompactTextString(m) }
func (*PhoneContact) ProtoMessage()    {}
func (*PhoneContact) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_ef061dba8cb38769, []int{9}
}
func (m *PhoneContact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhoneContact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhoneContact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PhoneContact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhoneContact.Merge(dst, src)
}
func (m *PhoneContact) XXX_Size() int {
	return m.Size()
}
func (m *PhoneContact) XXX_DiscardUnknown() {
	xxx_messageInfo_PhoneContact.DiscardUnknown(m)
}

var xxx_messageInfo_PhoneContact proto.InternalMessageInfo

func (m *PhoneContact) GetClientID() int64 {
	if m != nil {
		return m.ClientID
	}
	return 0
}

func (m *PhoneContact) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *PhoneContact) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *PhoneContact) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

// PeerNotifySettings
type PeerNotifySettings struct {
	Flags     int32  `protobuf:"varint,1,req,name=Flags" json:"Flags"`
	MuteUntil int64  `protobuf:"varint,2,opt,name=MuteUntil" json:"MuteUntil"`
	Sound     string `protobuf:"bytes,3,opt,name=Sound" json:"Sound"`
}

func (m *PeerNotifySettings) Reset()         { *m = PeerNotifySettings{} }
func (m *PeerNotifySettings) String() string { return proto.CompactTextString(m) }
func (*PeerNotifySettings) ProtoMessage()    {}
func (*PeerNotifySettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_ef061dba8cb38769, []int{10}
}
func (m *PeerNotifySettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerNotifySettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerNotifySettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PeerNotifySettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerNotifySettings.Merge(dst, src)
}
func (m *PeerNotifySettings) XXX_Size() int {
	return m.Size()
}
func (m *PeerNotifySettings) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerNotifySettings.DiscardUnknown(m)
}

var xxx_messageInfo_PeerNotifySettings proto.InternalMessageInfo

func (m *PeerNotifySettings) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *PeerNotifySettings) GetMuteUntil() int64 {
	if m != nil {
		return m.MuteUntil
	}
	return 0
}

func (m *PeerNotifySettings) GetSound() string {
	if m != nil {
		return m.Sound
	}
	return ""
}

// InputFile
type InputFile struct {
	FileID     int64  `protobuf:"varint,1,req,name=FileID" json:"FileID"`
	TotalParts int32  `protobuf:"varint,2,req,name=TotalParts" json:"TotalParts"`
	FileName   string `protobuf:"bytes,3,req,name=FileName" json:"FileName"`
}

func (m *InputFile) Reset()         { *m = InputFile{} }
func (m *InputFile) String() string { return proto.CompactTextString(m) }
func (*InputFile) ProtoMessage()    {}
func (*InputFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_ef061dba8cb38769, []int{11}
}
func (m *InputFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InputFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputFile.Merge(dst, src)
}
func (m *InputFile) XXX_Size() int {
	return m.Size()
}
func (m *InputFile) XXX_DiscardUnknown() {
	xxx_messageInfo_InputFile.DiscardUnknown(m)
}

var xxx_messageInfo_InputFile proto.InternalMessageInfo

func (m *InputFile) GetFileID() int64 {
	if m != nil {
		return m.FileID
	}
	return 0
}

func (m *InputFile) GetTotalParts() int32 {
	if m != nil {
		return m.TotalParts
	}
	return 0
}

func (m *InputFile) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

// Group
type Group struct {
	ID           int64      `protobuf:"varint,1,req,name=ID" json:"ID"`
	Title        string     `protobuf:"bytes,2,req,name=Title" json:"Title"`
	CreatedOn    int64      `protobuf:"varint,3,req,name=CreatedOn" json:"CreatedOn"`
	Participants int32      `protobuf:"varint,4,req,name=Participants" json:"Participants"`
	EditedOn     int64      `protobuf:"varint,5,opt,name=EditedOn" json:"EditedOn"`
	Flags        GroupFlags `protobuf:"varint,6,opt,name=Flags,enum=msg.GroupFlags" json:"Flags"`
}

func (m *Group) Reset()         { *m = Group{} }
func (m *Group) String() string { return proto.CompactTextString(m) }
func (*Group) ProtoMessage()    {}
func (*Group) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_ef061dba8cb38769, []int{12}
}
func (m *Group) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Group) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Group.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Group) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Group.Merge(dst, src)
}
func (m *Group) XXX_Size() int {
	return m.Size()
}
func (m *Group) XXX_DiscardUnknown() {
	xxx_messageInfo_Group.DiscardUnknown(m)
}

var xxx_messageInfo_Group proto.InternalMessageInfo

func (m *Group) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Group) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Group) GetCreatedOn() int64 {
	if m != nil {
		return m.CreatedOn
	}
	return 0
}

func (m *Group) GetParticipants() int32 {
	if m != nil {
		return m.Participants
	}
	return 0
}

func (m *Group) GetEditedOn() int64 {
	if m != nil {
		return m.EditedOn
	}
	return 0
}

func (m *Group) GetFlags() GroupFlags {
	if m != nil {
		return m.Flags
	}
	return GroupFlagsEmpty
}

// GroupFull
type GroupFull struct {
	Group          *Group              `protobuf:"bytes,1,req,name=Group" json:"Group,omitempty"`
	Users          []*User             `protobuf:"bytes,2,rep,name=Users" json:"Users,omitempty"`
	Participants   []*GroupParticipant `protobuf:"bytes,3,rep,name=Participants" json:"Participants,omitempty"`
	NotifySettings *PeerNotifySettings `protobuf:"bytes,4,req,name=NotifySettings" json:"NotifySettings,omitempty"`
}

func (m *GroupFull) Reset()         { *m = GroupFull{} }
func (m *GroupFull) String() string { return proto.CompactTextString(m) }
func (*GroupFull) ProtoMessage()    {}
func (*GroupFull) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_ef061dba8cb38769, []int{13}
}
func (m *GroupFull) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupFull) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupFull.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GroupFull) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupFull.Merge(dst, src)
}
func (m *GroupFull) XXX_Size() int {
	return m.Size()
}
func (m *GroupFull) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupFull.DiscardUnknown(m)
}

var xxx_messageInfo_GroupFull proto.InternalMessageInfo

func (m *GroupFull) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *GroupFull) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *GroupFull) GetParticipants() []*GroupParticipant {
	if m != nil {
		return m.Participants
	}
	return nil
}

func (m *GroupFull) GetNotifySettings() *PeerNotifySettings {
	if m != nil {
		return m.NotifySettings
	}
	return nil
}

// GroupParticipant
type GroupParticipant struct {
	UserID    int64           `protobuf:"varint,1,req,name=UserID" json:"UserID"`
	InviterID int64           `protobuf:"varint,2,req,name=InviterID" json:"InviterID"`
	Date      int64           `protobuf:"varint,3,req,name=Date" json:"Date"`
	Type      ParticipantType `protobuf:"varint,4,req,name=Type,enum=msg.ParticipantType" json:"Type"`
}

func (m *GroupParticipant) Reset()         { *m = GroupParticipant{} }
func (m *GroupParticipant) String() string { return proto.CompactTextString(m) }
func (*GroupParticipant) ProtoMessage()    {}
func (*GroupParticipant) Descriptor() ([]byte, []int) {
	return fileDescriptor_core_types_ef061dba8cb38769, []int{14}
}
func (m *GroupParticipant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupParticipant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupParticipant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GroupParticipant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupParticipant.Merge(dst, src)
}
func (m *GroupParticipant) XXX_Size() int {
	return m.Size()
}
func (m *GroupParticipant) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupParticipant.DiscardUnknown(m)
}

var xxx_messageInfo_GroupParticipant proto.InternalMessageInfo

func (m *GroupParticipant) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *GroupParticipant) GetInviterID() int64 {
	if m != nil {
		return m.InviterID
	}
	return 0
}

func (m *GroupParticipant) GetDate() int64 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *GroupParticipant) GetType() ParticipantType {
	if m != nil {
		return m.Type
	}
	return ParticipantTypeCreator
}

func init() {
	proto.RegisterType((*Dialog)(nil), "msg.Dialog")
	proto.RegisterType((*Peer)(nil), "msg.Peer")
	proto.RegisterType((*InputPeer)(nil), "msg.InputPeer")
	proto.RegisterType((*InputUser)(nil), "msg.InputUser")
	proto.RegisterType((*User)(nil), "msg.User")
	proto.RegisterType((*ContactUser)(nil), "msg.ContactUser")
	proto.RegisterType((*UserMessage)(nil), "msg.UserMessage")
	proto.RegisterType((*RSAPublicKey)(nil), "msg.RSAPublicKey")
	proto.RegisterType((*DHGroup)(nil), "msg.DHGroup")
	proto.RegisterType((*PhoneContact)(nil), "msg.PhoneContact")
	proto.RegisterType((*PeerNotifySettings)(nil), "msg.PeerNotifySettings")
	proto.RegisterType((*InputFile)(nil), "msg.InputFile")
	proto.RegisterType((*Group)(nil), "msg.Group")
	proto.RegisterType((*GroupFull)(nil), "msg.GroupFull")
	proto.RegisterType((*GroupParticipant)(nil), "msg.GroupParticipant")
	proto.RegisterEnum("msg.TypingAction", TypingAction_name, TypingAction_value)
	proto.RegisterEnum("msg.PeerType", PeerType_name, PeerType_value)
	proto.RegisterEnum("msg.GroupFlags", GroupFlags_name, GroupFlags_value)
	proto.RegisterEnum("msg.ParticipantType", ParticipantType_name, ParticipantType_value)
}
func (m *Dialog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dialog) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.PeerID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.PeerType))
	dAtA[i] = 0x18
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.TopMessageID))
	dAtA[i] = 0x20
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.ReadInboxMaxID))
	dAtA[i] = 0x28
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.ReadOutboxMaxID))
	dAtA[i] = 0x30
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.UnreadCount))
	dAtA[i] = 0x39
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i += 8
	if m.NotifySettings != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCoreTypes(dAtA, i, uint64(m.NotifySettings.Size()))
		n1, err := m.NotifySettings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *Peer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Peer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x19
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i += 8
	return i, nil
}

func (m *InputPeer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputPeer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x19
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i += 8
	return i, nil
}

func (m *InputUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.UserID))
	dAtA[i] = 0x11
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i += 8
	return i, nil
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.FirstName)))
	i += copy(dAtA[i:], m.FirstName)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.LastName)))
	i += copy(dAtA[i:], m.LastName)
	dAtA[i] = 0x22
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.Username)))
	i += copy(dAtA[i:], m.Username)
	return i, nil
}

func (m *ContactUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContactUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.FirstName)))
	i += copy(dAtA[i:], m.FirstName)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.LastName)))
	i += copy(dAtA[i:], m.LastName)
	dAtA[i] = 0x21
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AccessHash))
	i += 8
	dAtA[i] = 0x2a
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.Phone)))
	i += copy(dAtA[i:], m.Phone)
	dAtA[i] = 0x32
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.Username)))
	i += copy(dAtA[i:], m.Username)
	dAtA[i] = 0x38
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.ClientID))
	return i, nil
}

func (m *UserMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.PeerID))
	dAtA[i] = 0x18
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.PeerType))
	dAtA[i] = 0x20
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.CreatedOn))
	dAtA[i] = 0x28
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.EditedOn))
	dAtA[i] = 0x30
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.FwdSenderID))
	dAtA[i] = 0x38
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.FwdChannelID))
	dAtA[i] = 0x40
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.FwdChannelMessageID))
	dAtA[i] = 0x48
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.Flags))
	dAtA[i] = 0x50
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.MessageType))
	dAtA[i] = 0x5a
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.Body)))
	i += copy(dAtA[i:], m.Body)
	dAtA[i] = 0x60
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.SenderID))
	dAtA[i] = 0x68
	i++
	if m.ContentRead {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x70
	i++
	if m.Inbox {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x78
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.ReplyTo))
	dAtA[i] = 0x80
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.MessageAction))
	if m.MessageActionData != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.MessageActionData)))
		i += copy(dAtA[i:], m.MessageActionData)
	}
	return i, nil
}

func (m *RSAPublicKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RSAPublicKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.FingerPrint))
	dAtA[i] = 0x12
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.N)))
	i += copy(dAtA[i:], m.N)
	dAtA[i] = 0x18
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.E))
	return i, nil
}

func (m *DHGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.FingerPrint))
	dAtA[i] = 0x12
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.Prime)))
	i += copy(dAtA[i:], m.Prime)
	dAtA[i] = 0x18
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.Gen))
	return i, nil
}

func (m *PhoneContact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhoneContact) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.ClientID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.FirstName)))
	i += copy(dAtA[i:], m.FirstName)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.LastName)))
	i += copy(dAtA[i:], m.LastName)
	dAtA[i] = 0x22
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.Phone)))
	i += copy(dAtA[i:], m.Phone)
	return i, nil
}

func (m *PeerNotifySettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerNotifySettings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.Flags))
	dAtA[i] = 0x10
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.MuteUntil))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.Sound)))
	i += copy(dAtA[i:], m.Sound)
	return i, nil
}

func (m *InputFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputFile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.FileID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.TotalParts))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.FileName)))
	i += copy(dAtA[i:], m.FileName)
	return i, nil
}

func (m *Group) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Group) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(len(m.Title)))
	i += copy(dAtA[i:], m.Title)
	dAtA[i] = 0x18
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.CreatedOn))
	dAtA[i] = 0x20
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.Participants))
	dAtA[i] = 0x28
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.EditedOn))
	dAtA[i] = 0x30
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.Flags))
	return i, nil
}

func (m *GroupFull) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupFull) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Group == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("Group")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCoreTypes(dAtA, i, uint64(m.Group.Size()))
		n2, err := m.Group.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Users) > 0 {
		for _, msg := range m.Users {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCoreTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Participants) > 0 {
		for _, msg := range m.Participants {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCoreTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.NotifySettings == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("NotifySettings")
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCoreTypes(dAtA, i, uint64(m.NotifySettings.Size()))
		n3, err := m.NotifySettings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *GroupParticipant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupParticipant) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.UserID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.InviterID))
	dAtA[i] = 0x18
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.Date))
	dAtA[i] = 0x20
	i++
	i = encodeVarintCoreTypes(dAtA, i, uint64(m.Type))
	return i, nil
}

func encodeVarintCoreTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Dialog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.PeerID))
	n += 1 + sovCoreTypes(uint64(m.PeerType))
	n += 1 + sovCoreTypes(uint64(m.TopMessageID))
	n += 1 + sovCoreTypes(uint64(m.ReadInboxMaxID))
	n += 1 + sovCoreTypes(uint64(m.ReadOutboxMaxID))
	n += 1 + sovCoreTypes(uint64(m.UnreadCount))
	n += 9
	if m.NotifySettings != nil {
		l = m.NotifySettings.Size()
		n += 1 + l + sovCoreTypes(uint64(l))
	}
	return n
}

func (m *Peer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.ID))
	n += 1 + sovCoreTypes(uint64(m.Type))
	n += 9
	return n
}

func (m *InputPeer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.ID))
	n += 1 + sovCoreTypes(uint64(m.Type))
	n += 9
	return n
}

func (m *InputUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.UserID))
	n += 9
	return n
}

func (m *User) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.ID))
	l = len(m.FirstName)
	n += 1 + l + sovCoreTypes(uint64(l))
	l = len(m.LastName)
	n += 1 + l + sovCoreTypes(uint64(l))
	l = len(m.Username)
	n += 1 + l + sovCoreTypes(uint64(l))
	return n
}

func (m *ContactUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.ID))
	l = len(m.FirstName)
	n += 1 + l + sovCoreTypes(uint64(l))
	l = len(m.LastName)
	n += 1 + l + sovCoreTypes(uint64(l))
	n += 9
	l = len(m.Phone)
	n += 1 + l + sovCoreTypes(uint64(l))
	l = len(m.Username)
	n += 1 + l + sovCoreTypes(uint64(l))
	n += 1 + sovCoreTypes(uint64(m.ClientID))
	return n
}

func (m *UserMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.ID))
	n += 1 + sovCoreTypes(uint64(m.PeerID))
	n += 1 + sovCoreTypes(uint64(m.PeerType))
	n += 1 + sovCoreTypes(uint64(m.CreatedOn))
	n += 1 + sovCoreTypes(uint64(m.EditedOn))
	n += 1 + sovCoreTypes(uint64(m.FwdSenderID))
	n += 1 + sovCoreTypes(uint64(m.FwdChannelID))
	n += 1 + sovCoreTypes(uint64(m.FwdChannelMessageID))
	n += 1 + sovCoreTypes(uint64(m.Flags))
	n += 1 + sovCoreTypes(uint64(m.MessageType))
	l = len(m.Body)
	n += 1 + l + sovCoreTypes(uint64(l))
	n += 1 + sovCoreTypes(uint64(m.SenderID))
	n += 2
	n += 2
	n += 1 + sovCoreTypes(uint64(m.ReplyTo))
	n += 2 + sovCoreTypes(uint64(m.MessageAction))
	if m.MessageActionData != nil {
		l = len(m.MessageActionData)
		n += 2 + l + sovCoreTypes(uint64(l))
	}
	return n
}

func (m *RSAPublicKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.FingerPrint))
	l = len(m.N)
	n += 1 + l + sovCoreTypes(uint64(l))
	n += 1 + sovCoreTypes(uint64(m.E))
	return n
}

func (m *DHGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.FingerPrint))
	l = len(m.Prime)
	n += 1 + l + sovCoreTypes(uint64(l))
	n += 1 + sovCoreTypes(uint64(m.Gen))
	return n
}

func (m *PhoneContact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.ClientID))
	l = len(m.FirstName)
	n += 1 + l + sovCoreTypes(uint64(l))
	l = len(m.LastName)
	n += 1 + l + sovCoreTypes(uint64(l))
	l = len(m.Phone)
	n += 1 + l + sovCoreTypes(uint64(l))
	return n
}

func (m *PeerNotifySettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.Flags))
	n += 1 + sovCoreTypes(uint64(m.MuteUntil))
	l = len(m.Sound)
	n += 1 + l + sovCoreTypes(uint64(l))
	return n
}

func (m *InputFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.FileID))
	n += 1 + sovCoreTypes(uint64(m.TotalParts))
	l = len(m.FileName)
	n += 1 + l + sovCoreTypes(uint64(l))
	return n
}

func (m *Group) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.ID))
	l = len(m.Title)
	n += 1 + l + sovCoreTypes(uint64(l))
	n += 1 + sovCoreTypes(uint64(m.CreatedOn))
	n += 1 + sovCoreTypes(uint64(m.Participants))
	n += 1 + sovCoreTypes(uint64(m.EditedOn))
	n += 1 + sovCoreTypes(uint64(m.Flags))
	return n
}

func (m *GroupFull) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovCoreTypes(uint64(l))
	}
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovCoreTypes(uint64(l))
		}
	}
	if len(m.Participants) > 0 {
		for _, e := range m.Participants {
			l = e.Size()
			n += 1 + l + sovCoreTypes(uint64(l))
		}
	}
	if m.NotifySettings != nil {
		l = m.NotifySettings.Size()
		n += 1 + l + sovCoreTypes(uint64(l))
	}
	return n
}

func (m *GroupParticipant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCoreTypes(uint64(m.UserID))
	n += 1 + sovCoreTypes(uint64(m.InviterID))
	n += 1 + sovCoreTypes(uint64(m.Date))
	n += 1 + sovCoreTypes(uint64(m.Type))
	return n
}

func sovCoreTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCoreTypes(x uint64) (n int) {
	return sovCoreTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Dialog) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dialog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dialog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerID", wireType)
			}
			m.PeerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopMessageID", wireType)
			}
			m.TopMessageID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopMessageID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadInboxMaxID", wireType)
			}
			m.ReadInboxMaxID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadInboxMaxID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOutboxMaxID", wireType)
			}
			m.ReadOutboxMaxID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadOutboxMaxID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnreadCount", wireType)
			}
			m.UnreadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnreadCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000040)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifySettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NotifySettings == nil {
				m.NotifySettings = &PeerNotifySettings{}
			}
			if err := m.NotifySettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PeerID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PeerType")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("TopMessageID")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ReadInboxMaxID")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ReadOutboxMaxID")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UnreadCount")
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Peer) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Peer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Peer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Type")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputPeer) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputPeer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputPeer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (PeerType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Type")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputUser) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UserID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FirstName")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("LastName")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Username")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContactUser) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContactUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContactUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			m.ClientID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000040)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FirstName")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("LastName")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("AccessHash")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Phone")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Username")
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ClientID")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerID", wireType)
			}
			m.PeerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedOn", wireType)
			}
			m.CreatedOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedOn |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditedOn", wireType)
			}
			m.EditedOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EditedOn |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwdSenderID", wireType)
			}
			m.FwdSenderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FwdSenderID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwdChannelID", wireType)
			}
			m.FwdChannelID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FwdChannelID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000040)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwdChannelMessageID", wireType)
			}
			m.FwdChannelMessageID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FwdChannelMessageID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000080)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000100)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageType", wireType)
			}
			m.MessageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000200)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000400)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderID", wireType)
			}
			m.SenderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SenderID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000800)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentRead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContentRead = bool(v != 0)
			hasFields[0] |= uint64(0x00001000)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inbox", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Inbox = bool(v != 0)
			hasFields[0] |= uint64(0x00002000)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyTo", wireType)
			}
			m.ReplyTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyTo |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageAction", wireType)
			}
			m.MessageAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageAction |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageActionData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageActionData = append(m.MessageActionData[:0], dAtA[iNdEx:postIndex]...)
			if m.MessageActionData == nil {
				m.MessageActionData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PeerID")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("PeerType")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("CreatedOn")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("EditedOn")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FwdSenderID")
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FwdChannelID")
	}
	if hasFields[0]&uint64(0x00000080) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FwdChannelMessageID")
	}
	if hasFields[0]&uint64(0x00000100) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Flags")
	}
	if hasFields[0]&uint64(0x00000200) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("MessageType")
	}
	if hasFields[0]&uint64(0x00000400) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Body")
	}
	if hasFields[0]&uint64(0x00000800) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("SenderID")
	}
	if hasFields[0]&uint64(0x00001000) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ContentRead")
	}
	if hasFields[0]&uint64(0x00002000) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Inbox")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RSAPublicKey) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RSAPublicKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RSAPublicKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FingerPrint", wireType)
			}
			m.FingerPrint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FingerPrint |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.N = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field E", wireType)
			}
			m.E = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.E |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FingerPrint")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("N")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("E")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHGroup) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FingerPrint", wireType)
			}
			m.FingerPrint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FingerPrint |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gen", wireType)
			}
			m.Gen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FingerPrint")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Prime")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Gen")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhoneContact) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhoneContact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhoneContact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			m.ClientID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ClientID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FirstName")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("LastName")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Phone")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerNotifySettings) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerNotifySettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerNotifySettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MuteUntil", wireType)
			}
			m.MuteUntil = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MuteUntil |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sound", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sound = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Flags")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputFile) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileID", wireType)
			}
			m.FileID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalParts", wireType)
			}
			m.TotalParts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalParts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FileID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("TotalParts")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("FileName")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Group) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedOn", wireType)
			}
			m.CreatedOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedOn |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Participants", wireType)
			}
			m.Participants = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Participants |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditedOn", wireType)
			}
			m.EditedOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EditedOn |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (GroupFlags(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Title")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("CreatedOn")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Participants")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupFull) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupFull: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupFull: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &Group{}
			}
			if err := m.Group.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &User{})
			if err := m.Users[len(m.Users)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Participants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Participants = append(m.Participants, &GroupParticipant{})
			if err := m.Participants[len(m.Participants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifySettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NotifySettings == nil {
				m.NotifySettings = &PeerNotifySettings{}
			}
			if err := m.NotifySettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Group")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("NotifySettings")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupParticipant) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupParticipant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupParticipant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InviterID", wireType)
			}
			m.InviterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InviterID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (ParticipantType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("UserID")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("InviterID")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Date")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Type")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCoreTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCoreTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCoreTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCoreTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCoreTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCoreTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCoreTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCoreTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("core.types.proto", fileDescriptor_core_types_ef061dba8cb38769) }

var fileDescriptor_core_types_ef061dba8cb38769 = []byte{
	// 1273 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0x3f, 0x6f, 0xdb, 0xc6,
	0x1b, 0xd6, 0x91, 0x94, 0x62, 0xbd, 0x92, 0x65, 0xe6, 0xe2, 0x38, 0xfc, 0xf9, 0x17, 0x28, 0x04,
	0x51, 0xa4, 0x82, 0xdb, 0x2a, 0x85, 0xa7, 0x76, 0x2a, 0x6c, 0xcb, 0x4e, 0x84, 0xc4, 0x8e, 0x21,
	0xdb, 0x1d, 0x3a, 0x04, 0xa5, 0xc9, 0xb3, 0x7c, 0x28, 0x75, 0x24, 0xc8, 0x53, 0x12, 0x8d, 0x5d,
	0x3a, 0x77, 0xe8, 0xd2, 0xa5, 0x5f, 0xa1, 0x5f, 0x23, 0xe8, 0x94, 0x31, 0x53, 0xd1, 0xda, 0x9f,
	0xa1, 0x7b, 0x71, 0x47, 0x8a, 0x3c, 0x52, 0x56, 0x1b, 0x14, 0x45, 0x27, 0xe9, 0x9e, 0xe7, 0xe5,
	0xdd, 0xfb, 0xbc, 0xff, 0xee, 0xc0, 0xf4, 0xc2, 0x98, 0xf4, 0xf9, 0x2c, 0x22, 0x49, 0x3f, 0x8a,
	0x43, 0x1e, 0x62, 0x7d, 0x92, 0x8c, 0x37, 0x3f, 0x19, 0x53, 0x7e, 0x39, 0x3d, 0xef, 0x7b, 0xe1,
	0xe4, 0xd1, 0x38, 0x1c, 0x87, 0x8f, 0x24, 0x77, 0x3e, 0xbd, 0x90, 0x2b, 0xb9, 0x90, 0xff, 0xd2,
	0x6f, 0x9c, 0x6b, 0x0d, 0x1a, 0x03, 0xea, 0x06, 0xe1, 0x18, 0x77, 0xa1, 0x71, 0x4c, 0x48, 0x3c,
	0x1c, 0x58, 0xc8, 0xd6, 0x7a, 0xfa, 0x6e, 0xe3, 0xcd, 0xaf, 0x0f, 0x6a, 0x9f, 0xa2, 0x51, 0x86,
	0x62, 0x1b, 0x56, 0xc4, 0xbf, 0xd3, 0x59, 0x44, 0x2c, 0xcd, 0xd6, 0x7a, 0xf5, 0x5d, 0x43, 0x58,
	0x8c, 0x72, 0x14, 0xf7, 0xa0, 0x7d, 0x1a, 0x46, 0x87, 0x24, 0x49, 0xdc, 0x31, 0x19, 0x0e, 0x2c,
	0x5d, 0xee, 0x93, 0x5a, 0x95, 0x18, 0xfc, 0x31, 0x74, 0x46, 0xc4, 0xf5, 0x87, 0xec, 0x3c, 0x7c,
	0x7d, 0xe8, 0xbe, 0x1e, 0x0e, 0x2c, 0x43, 0xb1, 0xad, 0x70, 0xb8, 0x0f, 0x6b, 0x02, 0x79, 0x3e,
	0xe5, 0xb9, 0x79, 0x5d, 0x31, 0xaf, 0x92, 0xf8, 0x21, 0xb4, 0xce, 0x58, 0x4c, 0x5c, 0x7f, 0x2f,
	0x9c, 0x32, 0x6e, 0x35, 0x14, 0x67, 0x55, 0x02, 0x3f, 0x04, 0xd8, 0xf1, 0x3c, 0x92, 0x24, 0x4f,
	0xdc, 0xe4, 0xd2, 0xba, 0x65, 0x6b, 0xbd, 0x46, 0xae, 0x5a, 0x61, 0xf0, 0x17, 0xd0, 0x39, 0x0a,
	0x39, 0xbd, 0x98, 0x9d, 0x10, 0xce, 0x29, 0x1b, 0x27, 0xd6, 0x8a, 0x8d, 0x7a, 0xad, 0xed, 0x7b,
	0xfd, 0x49, 0x32, 0xee, 0x0b, 0xf9, 0x65, 0x7a, 0x54, 0x31, 0x77, 0xbe, 0x06, 0x43, 0x58, 0xe1,
	0x0d, 0xd0, 0x16, 0xc2, 0xab, 0x0d, 0x07, 0xd8, 0x02, 0x63, 0x21, 0xac, 0x12, 0xa9, 0xb8, 0xa8,
	0x2f, 0x73, 0xd1, 0xe1, 0xd0, 0x1c, 0xb2, 0x68, 0xca, 0xff, 0xf2, 0x98, 0x0f, 0x95, 0x63, 0x3a,
	0xdb, 0xab, 0xb9, 0xf7, 0x02, 0xfc, 0x47, 0xa7, 0x9e, 0x64, 0xa7, 0x9e, 0x25, 0x24, 0x16, 0xf5,
	0x23, 0x7e, 0x17, 0xeb, 0x27, 0x45, 0x2b, 0x9b, 0x6a, 0x4b, 0x37, 0xfd, 0x0e, 0x81, 0x21, 0x37,
	0x5c, 0x26, 0xc3, 0x81, 0xe6, 0x01, 0x8d, 0x13, 0x7e, 0xe4, 0x4e, 0x52, 0x2d, 0xcd, 0xcc, 0xf9,
	0x02, 0x16, 0xc5, 0xfa, 0xcc, 0xcd, 0x4c, 0x74, 0xc5, 0x24, 0x47, 0x85, 0x85, 0x38, 0x85, 0x09,
	0x0b, 0x43, 0xb5, 0x98, 0xa3, 0xce, 0x1f, 0x08, 0x5a, 0x7b, 0x21, 0xe3, 0xae, 0xc7, 0xff, 0x03,
	0x7f, 0xca, 0xe1, 0x31, 0x96, 0x16, 0xe3, 0x26, 0xd4, 0x8f, 0x2f, 0x43, 0x46, 0x64, 0x0b, 0xcc,
	0xb7, 0x49, 0xa1, 0x92, 0xa6, 0xc6, 0x4d, 0x9a, 0xb0, 0x03, 0x2b, 0x7b, 0x01, 0x25, 0x8c, 0x0f,
	0x07, 0xb2, 0xe0, 0x0b, 0x25, 0x39, 0xee, 0x7c, 0x5b, 0x87, 0x96, 0xf8, 0x20, 0x6b, 0x57, 0xbc,
	0xae, 0xe8, 0x4e, 0xf7, 0x13, 0xaa, 0x8b, 0x71, 0xa1, 0xfd, 0xed, 0xb8, 0xd0, 0x6f, 0x1c, 0x17,
	0x0e, 0x34, 0xf7, 0x62, 0xe2, 0x72, 0xe2, 0x3f, 0x67, 0xa5, 0xfe, 0x2f, 0x60, 0xb1, 0xcb, 0xbe,
	0x4f, 0x53, 0x13, 0xb5, 0xe7, 0x73, 0x14, 0xf7, 0xa0, 0x75, 0xf0, 0xca, 0x3f, 0x21, 0xcc, 0x97,
	0xce, 0x34, 0x4a, 0xce, 0xa8, 0x14, 0xde, 0x82, 0xf6, 0xc1, 0x2b, 0x7f, 0xef, 0xd2, 0x65, 0x8c,
	0x04, 0x0b, 0xfa, 0x4b, 0x1c, 0xfe, 0x0c, 0xee, 0x14, 0xeb, 0x62, 0xa2, 0xad, 0x94, 0x3e, 0xb9,
	0xc9, 0x44, 0xe4, 0xe7, 0x20, 0x70, 0xc7, 0x89, 0xd5, 0x54, 0x44, 0xa7, 0x90, 0x18, 0x4c, 0x99,
	0xa1, 0x0c, 0x0b, 0x28, 0x82, 0x54, 0x42, 0xcc, 0x83, 0xdd, 0xd0, 0x9f, 0x59, 0x2d, 0x25, 0x87,
	0x12, 0x11, 0xf9, 0xcb, 0xa5, 0xb6, 0xcb, 0xf9, 0xcb, 0x75, 0x3e, 0x4c, 0xcb, 0x96, 0x30, 0x2e,
	0x06, 0xa3, 0xb5, 0x6a, 0x6b, 0xbd, 0x95, 0xf9, 0x29, 0x0a, 0x21, 0x3c, 0x95, 0x43, 0xd6, 0xea,
	0x28, 0x16, 0x29, 0x84, 0xbb, 0x70, 0x6b, 0x44, 0xa2, 0x60, 0x76, 0x1a, 0x5a, 0x6b, 0x36, 0xca,
	0xbd, 0x9c, 0x83, 0x78, 0x0b, 0x56, 0x33, 0x87, 0x77, 0x3c, 0x4e, 0x43, 0x66, 0x99, 0x36, 0xca,
	0xd5, 0x96, 0x29, 0xbc, 0x0d, 0xb7, 0x4b, 0xc0, 0xc0, 0xe5, 0xae, 0x75, 0xdb, 0x46, 0xbd, 0x76,
	0x66, 0xbf, 0x48, 0x3b, 0x2f, 0xa0, 0x3d, 0x3a, 0xd9, 0x39, 0x9e, 0x9e, 0x07, 0xd4, 0x7b, 0x4a,
	0x66, 0x42, 0xd3, 0x01, 0x65, 0x63, 0x12, 0x1f, 0xc7, 0x94, 0xf1, 0x52, 0x31, 0xaa, 0x04, 0xc6,
	0x80, 0x8e, 0x4a, 0x3d, 0x88, 0x8e, 0x04, 0xb6, 0x2f, 0x4b, 0x70, 0x75, 0x8e, 0xed, 0x3b, 0x04,
	0x6e, 0x0d, 0x9e, 0x3c, 0x8e, 0xc3, 0x69, 0xf4, 0xde, 0x5b, 0x8b, 0xc6, 0x8b, 0x69, 0xa5, 0xc5,
	0x53, 0x08, 0x6f, 0x80, 0xfe, 0x98, 0xb0, 0x52, 0x9d, 0x0b, 0xc0, 0xf9, 0x01, 0x41, 0x5b, 0xb6,
	0x66, 0x36, 0x47, 0x4a, 0xfd, 0x87, 0x6e, 0xee, 0xbf, 0x7f, 0x69, 0x9e, 0xe4, 0x73, 0xc2, 0x58,
	0x98, 0x13, 0x4e, 0x04, 0x78, 0xf1, 0xd6, 0x2a, 0x2a, 0x17, 0x2d, 0x56, 0xae, 0x03, 0xcd, 0xc3,
	0x29, 0x27, 0x67, 0x8c, 0xd3, 0xc0, 0xd2, 0x94, 0x8a, 0x28, 0x60, 0xf1, 0xfd, 0x49, 0x38, 0x65,
	0xbe, 0xa5, 0xdb, 0xa8, 0x38, 0x51, 0x42, 0x4e, 0x92, 0xdd, 0x14, 0x07, 0x34, 0x20, 0x62, 0x74,
	0x88, 0xdf, 0xc5, 0x9b, 0x22, 0x45, 0xf1, 0x07, 0x00, 0xa7, 0x21, 0x77, 0x83, 0x63, 0x37, 0xe6,
	0x49, 0xe9, 0x52, 0x54, 0x70, 0x11, 0x02, 0x61, 0xbf, 0x18, 0x82, 0x39, 0xea, 0xbc, 0x43, 0x50,
	0x4f, 0x73, 0xbc, 0x6c, 0x74, 0x6f, 0x42, 0xfd, 0x94, 0xf2, 0xa0, 0x92, 0x53, 0x09, 0x95, 0xc7,
	0x93, 0x7e, 0xf3, 0x78, 0xea, 0x41, 0x5b, 0x38, 0x43, 0x3d, 0x1a, 0xb9, 0x8c, 0x27, 0x32, 0xd6,
	0x73, 0x5f, 0x4b, 0x4c, 0x65, 0x90, 0xa1, 0x1b, 0x06, 0xd9, 0x47, 0xf3, 0xf0, 0x37, 0x6c, 0xd4,
	0xeb, 0x6c, 0xaf, 0xc9, 0xeb, 0x59, 0xba, 0x2f, 0xe1, 0x52, 0x3e, 0x9c, 0x5f, 0x10, 0x34, 0x53,
	0x6e, 0x1a, 0x04, 0xd8, 0xce, 0x74, 0x4a, 0x85, 0xad, 0x6d, 0x28, 0x3e, 0x1d, 0x65, 0x01, 0x78,
	0x00, 0x75, 0x31, 0xd2, 0x45, 0x34, 0xf5, 0x5e, 0x6b, 0xbb, 0x29, 0x2d, 0x04, 0x32, 0x4a, 0x71,
	0xfc, 0x79, 0x45, 0x89, 0x2e, 0xed, 0xee, 0x16, 0x3b, 0x29, 0x6c, 0x45, 0xda, 0xe2, 0xf3, 0xc8,
	0x90, 0x6e, 0xbc, 0xf7, 0xf3, 0xe8, 0x27, 0x04, 0x66, 0xf5, 0x0c, 0x7c, 0xbf, 0xf2, 0x9c, 0x48,
	0xe5, 0xcf, 0x1f, 0x13, 0x8e, 0xa8, 0xa7, 0x97, 0x94, 0x2b, 0x17, 0x50, 0x96, 0x9c, 0x1c, 0x16,
	0x53, 0x74, 0xe0, 0x72, 0x52, 0xca, 0x9d, 0x44, 0x70, 0x3f, 0x7b, 0x08, 0x19, 0xf2, 0x21, 0xb4,
	0x9e, 0xfa, 0x59, 0x9c, 0x5d, 0x7d, 0x0f, 0x6d, 0xfd, 0x88, 0xa0, 0x7d, 0x3a, 0x8b, 0x28, 0x1b,
	0x67, 0x23, 0x6d, 0x03, 0xb0, 0xba, 0x4e, 0xff, 0x9b, 0x35, 0xdc, 0x85, 0x4d, 0x15, 0x1f, 0x11,
	0x2f, 0x8c, 0x7d, 0xca, 0xc6, 0x5f, 0x86, 0xd4, 0x23, 0x26, 0x5a, 0xce, 0x53, 0x9f, 0x84, 0xa6,
	0x86, 0xff, 0x07, 0x77, 0x55, 0xfe, 0x2c, 0x0a, 0x42, 0x57, 0xf0, 0xa6, 0x5e, 0x3d, 0x72, 0xcf,
	0x65, 0x1e, 0x09, 0x4c, 0x63, 0xeb, 0xab, 0xe2, 0x9e, 0xc5, 0xed, 0xf4, 0xff, 0x09, 0x09, 0x2e,
	0xcc, 0xda, 0x7c, 0x25, 0x22, 0x66, 0x22, 0xbc, 0x0a, 0x4d, 0xb1, 0x92, 0x71, 0x36, 0x35, 0x8c,
	0xa1, 0x23, 0x4d, 0xa7, 0xd1, 0x1c, 0xd3, 0xf1, 0x1a, 0xb4, 0x04, 0x96, 0x5d, 0x69, 0xa6, 0xb1,
	0xf5, 0x33, 0x02, 0x28, 0x2a, 0x10, 0xdf, 0x81, 0xb5, 0x62, 0xb5, 0x3f, 0x89, 0xf8, 0xcc, 0xac,
	0xe1, 0xbb, 0x70, 0xbb, 0x00, 0x65, 0x67, 0x84, 0xe2, 0x38, 0x0c, 0x9d, 0x02, 0x7e, 0x46, 0x2e,
	0xb8, 0xa9, 0xe1, 0xf5, 0x2c, 0xcd, 0x12, 0x7b, 0x4a, 0xbd, 0x6f, 0x88, 0x6f, 0x1a, 0xe5, 0x5d,
	0x77, 0xfc, 0x09, 0x65, 0xe6, 0x0a, 0xfe, 0x3f, 0xdc, 0xab, 0x80, 0xc9, 0x3e, 0x73, 0xcf, 0x03,
	0xe2, 0x9b, 0xa6, 0x88, 0x52, 0x41, 0x0e, 0x88, 0xeb, 0x71, 0xfa, 0x52, 0x34, 0xa4, 0x69, 0x6f,
	0xbd, 0x80, 0xb5, 0x4a, 0x22, 0xf1, 0x26, 0x6c, 0x54, 0xa0, 0xb9, 0x97, 0x35, 0x6c, 0xc1, 0x7a,
	0x85, 0x4b, 0x1d, 0x40, 0x42, 0x96, 0xc2, 0x1c, 0x92, 0xc9, 0x39, 0x89, 0x4d, 0x6d, 0xf7, 0xfe,
	0xdb, 0xdf, 0xbb, 0xb5, 0x37, 0x57, 0x5d, 0xf4, 0xf6, 0xaa, 0x8b, 0x7e, 0xbb, 0xea, 0xa2, 0xef,
	0xaf, 0xbb, 0xb5, 0xb7, 0xd7, 0xdd, 0xda, 0xbb, 0xeb, 0x6e, 0xed, 0xcf, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x6f, 0xfc, 0x8f, 0xe5, 0x94, 0x0d, 0x00, 0x00,
}
